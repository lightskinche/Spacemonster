; Listing generated by Microsoft (R) Optimizing Compiler Version 19.27.29111.0 

	TITLE	C:\Users\Light\source\repos\Spacemonster\Spacemonster-code\glmc\affine.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

msvcjmc	SEGMENT
__09340588_corecrt_math@h DB 01H
__B0C4CEA9_malloc@h DB 01H
__AF08451A_xmmintrin@h DB 01H
__01CC0242_x86@h DB 01H
__8B2C0229_util@h DB 01H
__E45A7869_vec2-ext@h DB 01H
__59A72D6B_vec2@h DB 01H
__422D73DD_vec3-ext@h DB 01H
__878A4D53_vec4-ext@h DB 01H
__5D2A51D9_vec4@h DB 01H
__5865475C_vec3@h DB 01H
__E3FCB8B3_mat4@h DB 01H
__0C756A67_mat4@h DB 01H
__E6B3AE36_mat3@h DB 01H
__093A7CE2_mat3@h DB 01H
__E771C401_mat2@h DB 01H
__08F816D5_mat2@h DB 01H
__CD658D3A_affine@h DB 01H
__1529E0A7_affine-mat@h DB 01H
__40ECD150_affine@h DB 01H
__FC78FBBD_plane@h DB 01H
__40246743_cam@h DB 01H
__EE1FA25F_frustum@h DB 01H
__15D5617C_quat@h DB 01H
__FA5CB3A8_quat@h DB 01H
__DBBFEDC2_euler@h DB 01H
__8776585B_box@h DB 01H
__759F1961_color@h DB 01H
__F66CEB67_corecrt_stdio_config@h DB 01H
__101834BA_corecrt_wstdio@h DB 01H
__AD6A91B7_stdio@h DB 01H
__DAA4108F_io@h DB 01H
__EDB727F9_project@h DB 01H
__9F492AA4_sphere@h DB 01H
__108F9434_ease@h DB 01H
__3C7ABC9F_curve@h DB 01H
__45F73C3A_bezier@h DB 01H
__068BD2DD_ray@h DB 01H
__10D40EFF_affine2d@h DB 01H
__1682C327_vec3@h DB 01H
__13CDD5A2_vec4@h DB 01H
__8C2D01EA_affine@c DB 01H
msvcjmc	ENDS
PUBLIC	_cosf
PUBLIC	_fabsf
PUBLIC	_sinf
PUBLIC	_sqrtf
PUBLIC	_glm_vec3_eq_eps
PUBLIC	_glm_vec3_eq_all
PUBLIC	_glm_vec4_copy
PUBLIC	_glm_vec4_scale
PUBLIC	_glm_vec4_negate_to
PUBLIC	_glm_vec4_negate
PUBLIC	_glm_vec3_copy
PUBLIC	_glm_vec3_zero
PUBLIC	_glm_vec3_dot
PUBLIC	_glm_vec3_norm2
PUBLIC	_glm_vec3_norm
PUBLIC	_glm_vec3_scale
PUBLIC	_glm_vec3_negate_to
PUBLIC	_glm_vec3_negate
PUBLIC	_glm_vec3_normalize_to
PUBLIC	_glm_vec3_cross
PUBLIC	_glm_mat4_copy
PUBLIC	_glm_mat4_identity
PUBLIC	_glm_mul_sse2
PUBLIC	_glm_mul_rot_sse2
PUBLIC	_glm_inv_tr_sse2
PUBLIC	_glm_mul
PUBLIC	_glm_mul_rot
PUBLIC	_glm_inv_tr
PUBLIC	_glm_translate
PUBLIC	_glm_translate_to
PUBLIC	_glm_translate_x
PUBLIC	_glm_translate_y
PUBLIC	_glm_translate_z
PUBLIC	_glm_translate_make
PUBLIC	_glm_scale_to
PUBLIC	_glm_scale_make
PUBLIC	_glm_scale
PUBLIC	_glm_scale_uni
PUBLIC	_glm_rotate_x
PUBLIC	_glm_rotate_y
PUBLIC	_glm_rotate_z
PUBLIC	_glm_rotate_make
PUBLIC	_glm_rotate
PUBLIC	_glm_rotate_at
PUBLIC	_glm_rotate_atm
PUBLIC	_glm_decompose_scalev
PUBLIC	_glm_uniscaled
PUBLIC	_glm_decompose_rs
PUBLIC	_glm_decompose
PUBLIC	_glmc_translate_make
PUBLIC	_glmc_translate_to
PUBLIC	_glmc_translate
PUBLIC	_glmc_translate_x
PUBLIC	_glmc_translate_y
PUBLIC	_glmc_translate_z
PUBLIC	_glmc_scale_make
PUBLIC	_glmc_scale_to
PUBLIC	_glmc_scale
PUBLIC	_glmc_scale_uni
PUBLIC	_glmc_rotate_x
PUBLIC	_glmc_rotate_y
PUBLIC	_glmc_rotate_z
PUBLIC	_glmc_rotate_make
PUBLIC	_glmc_rotate
PUBLIC	_glmc_rotate_at
PUBLIC	_glmc_rotate_atm
PUBLIC	_glmc_decompose_scalev
PUBLIC	_glmc_uniscaled
PUBLIC	_glmc_decompose_rs
PUBLIC	_glmc_decompose
PUBLIC	_glmc_mul
PUBLIC	_glmc_mul_rot
PUBLIC	_glmc_inv_tr
PUBLIC	__JustMyCode_Default
PUBLIC	__real@00000000
PUBLIC	__real@3eb0c6f7a0b5ed8d
PUBLIC	__real@3f800000
PUBLIC	__xmm@3f800000000000000000000000000000
PUBLIC	__xmm@80000000800000008000000080000000
EXTRN	_cos:PROC
EXTRN	_fabs:PROC
EXTRN	_sin:PROC
EXTRN	_sqrt:PROC
EXTRN	@_RTC_CheckStackVars@8:PROC
EXTRN	@__CheckForDebuggerJustMyCode@4:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
;	COMDAT __xmm@80000000800000008000000080000000
CONST	SEGMENT
__xmm@80000000800000008000000080000000 DB 00H, 00H, 00H, 080H, 00H, 00H, 00H
	DB	080H, 00H, 00H, 00H, 080H, 00H, 00H, 00H, 080H
CONST	ENDS
;	COMDAT __xmm@3f800000000000000000000000000000
CONST	SEGMENT
__xmm@3f800000000000000000000000000000 DB 00H, 00H, 00H, 00H, 00H, 00H, 00H
	DB	00H, 00H, 00H, 00H, 00H, 00H, 00H, 080H, '?'
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@3eb0c6f7a0b5ed8d
CONST	SEGMENT
__real@3eb0c6f7a0b5ed8d DQ 03eb0c6f7a0b5ed8dr	; 1e-06
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
; Function compile flags: /Odt
;	COMDAT __JustMyCode_Default
_TEXT	SEGMENT
__JustMyCode_Default PROC				; COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
__JustMyCode_Default ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Light\source\repos\Spacemonster\Spacemonster-code\glmc\affine.c
;	COMDAT _glmc_inv_tr
_TEXT	SEGMENT
_mat$ = 8						; size = 4
_glmc_inv_tr PROC					; COMDAT

; 151  : glmc_inv_tr(mat4 mat) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __8C2D01EA_affine@c
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 152  :   glm_inv_tr(mat);

  00028	8b 45 08	 mov	 eax, DWORD PTR _mat$[ebp]
  0002b	50		 push	 eax
  0002c	e8 00 00 00 00	 call	 _glm_inv_tr
  00031	83 c4 04	 add	 esp, 4

; 153  : }

  00034	5f		 pop	 edi
  00035	5e		 pop	 esi
  00036	5b		 pop	 ebx
  00037	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0003d	3b ec		 cmp	 ebp, esp
  0003f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00044	8b e5		 mov	 esp, ebp
  00046	5d		 pop	 ebp
  00047	c3		 ret	 0
_glmc_inv_tr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Light\source\repos\Spacemonster\Spacemonster-code\glmc\affine.c
;	COMDAT _glmc_mul_rot
_TEXT	SEGMENT
_m1$ = 8						; size = 4
_m2$ = 12						; size = 4
_dest$ = 16						; size = 4
_glmc_mul_rot PROC					; COMDAT

; 145  : glmc_mul_rot(mat4 m1, mat4 m2, mat4 dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __8C2D01EA_affine@c
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 146  :   glm_mul_rot(m1, m2, dest);

  00028	8b 45 10	 mov	 eax, DWORD PTR _dest$[ebp]
  0002b	50		 push	 eax
  0002c	8b 4d 0c	 mov	 ecx, DWORD PTR _m2$[ebp]
  0002f	51		 push	 ecx
  00030	8b 55 08	 mov	 edx, DWORD PTR _m1$[ebp]
  00033	52		 push	 edx
  00034	e8 00 00 00 00	 call	 _glm_mul_rot
  00039	83 c4 0c	 add	 esp, 12			; 0000000cH

; 147  : }

  0003c	5f		 pop	 edi
  0003d	5e		 pop	 esi
  0003e	5b		 pop	 ebx
  0003f	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00045	3b ec		 cmp	 ebp, esp
  00047	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004c	8b e5		 mov	 esp, ebp
  0004e	5d		 pop	 ebp
  0004f	c3		 ret	 0
_glmc_mul_rot ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Light\source\repos\Spacemonster\Spacemonster-code\glmc\affine.c
;	COMDAT _glmc_mul
_TEXT	SEGMENT
_m1$ = 8						; size = 4
_m2$ = 12						; size = 4
_dest$ = 16						; size = 4
_glmc_mul PROC						; COMDAT

; 139  : glmc_mul(mat4 m1, mat4 m2, mat4 dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __8C2D01EA_affine@c
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 140  :   glm_mul(m1, m2, dest);

  00028	8b 45 10	 mov	 eax, DWORD PTR _dest$[ebp]
  0002b	50		 push	 eax
  0002c	8b 4d 0c	 mov	 ecx, DWORD PTR _m2$[ebp]
  0002f	51		 push	 ecx
  00030	8b 55 08	 mov	 edx, DWORD PTR _m1$[ebp]
  00033	52		 push	 edx
  00034	e8 00 00 00 00	 call	 _glm_mul
  00039	83 c4 0c	 add	 esp, 12			; 0000000cH

; 141  : }

  0003c	5f		 pop	 edi
  0003d	5e		 pop	 esi
  0003e	5b		 pop	 ebx
  0003f	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00045	3b ec		 cmp	 ebp, esp
  00047	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004c	8b e5		 mov	 esp, ebp
  0004e	5d		 pop	 ebp
  0004f	c3		 ret	 0
_glmc_mul ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Light\source\repos\Spacemonster\Spacemonster-code\glmc\affine.c
;	COMDAT _glmc_decompose
_TEXT	SEGMENT
_m$ = 8							; size = 4
_t$ = 12						; size = 4
_r$ = 16						; size = 4
_s$ = 20						; size = 4
_glmc_decompose PROC					; COMDAT

; 133  : glmc_decompose(mat4 m, vec4 t, mat4 r, vec3 s) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __8C2D01EA_affine@c
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 134  :   glm_decompose(m, t, r, s);

  00028	8b 45 14	 mov	 eax, DWORD PTR _s$[ebp]
  0002b	50		 push	 eax
  0002c	8b 4d 10	 mov	 ecx, DWORD PTR _r$[ebp]
  0002f	51		 push	 ecx
  00030	8b 55 0c	 mov	 edx, DWORD PTR _t$[ebp]
  00033	52		 push	 edx
  00034	8b 45 08	 mov	 eax, DWORD PTR _m$[ebp]
  00037	50		 push	 eax
  00038	e8 00 00 00 00	 call	 _glm_decompose
  0003d	83 c4 10	 add	 esp, 16			; 00000010H

; 135  : }

  00040	5f		 pop	 edi
  00041	5e		 pop	 esi
  00042	5b		 pop	 ebx
  00043	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00049	3b ec		 cmp	 ebp, esp
  0004b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00050	8b e5		 mov	 esp, ebp
  00052	5d		 pop	 ebp
  00053	c3		 ret	 0
_glmc_decompose ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Light\source\repos\Spacemonster\Spacemonster-code\glmc\affine.c
;	COMDAT _glmc_decompose_rs
_TEXT	SEGMENT
_m$ = 8							; size = 4
_r$ = 12						; size = 4
_s$ = 16						; size = 4
_glmc_decompose_rs PROC					; COMDAT

; 127  : glmc_decompose_rs(mat4 m, mat4 r, vec3 s) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __8C2D01EA_affine@c
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 128  :   glm_decompose_rs(m, r, s);

  00028	8b 45 10	 mov	 eax, DWORD PTR _s$[ebp]
  0002b	50		 push	 eax
  0002c	8b 4d 0c	 mov	 ecx, DWORD PTR _r$[ebp]
  0002f	51		 push	 ecx
  00030	8b 55 08	 mov	 edx, DWORD PTR _m$[ebp]
  00033	52		 push	 edx
  00034	e8 00 00 00 00	 call	 _glm_decompose_rs
  00039	83 c4 0c	 add	 esp, 12			; 0000000cH

; 129  : }

  0003c	5f		 pop	 edi
  0003d	5e		 pop	 esi
  0003e	5b		 pop	 ebx
  0003f	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00045	3b ec		 cmp	 ebp, esp
  00047	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004c	8b e5		 mov	 esp, ebp
  0004e	5d		 pop	 ebp
  0004f	c3		 ret	 0
_glmc_decompose_rs ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Light\source\repos\Spacemonster\Spacemonster-code\glmc\affine.c
;	COMDAT _glmc_uniscaled
_TEXT	SEGMENT
_m$ = 8							; size = 4
_glmc_uniscaled PROC					; COMDAT

; 121  : glmc_uniscaled(mat4 m) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __8C2D01EA_affine@c
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 122  :   return glm_uniscaled(m);

  00028	8b 45 08	 mov	 eax, DWORD PTR _m$[ebp]
  0002b	50		 push	 eax
  0002c	e8 00 00 00 00	 call	 _glm_uniscaled
  00031	83 c4 04	 add	 esp, 4

; 123  : }

  00034	5f		 pop	 edi
  00035	5e		 pop	 esi
  00036	5b		 pop	 ebx
  00037	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0003d	3b ec		 cmp	 ebp, esp
  0003f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00044	8b e5		 mov	 esp, ebp
  00046	5d		 pop	 ebp
  00047	c3		 ret	 0
_glmc_uniscaled ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Light\source\repos\Spacemonster\Spacemonster-code\glmc\affine.c
;	COMDAT _glmc_decompose_scalev
_TEXT	SEGMENT
_m$ = 8							; size = 4
_s$ = 12						; size = 4
_glmc_decompose_scalev PROC				; COMDAT

; 115  : glmc_decompose_scalev(mat4 m, vec3 s) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __8C2D01EA_affine@c
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 116  :   glm_decompose_scalev(m, s);

  00028	8b 45 0c	 mov	 eax, DWORD PTR _s$[ebp]
  0002b	50		 push	 eax
  0002c	8b 4d 08	 mov	 ecx, DWORD PTR _m$[ebp]
  0002f	51		 push	 ecx
  00030	e8 00 00 00 00	 call	 _glm_decompose_scalev
  00035	83 c4 08	 add	 esp, 8

; 117  : }

  00038	5f		 pop	 edi
  00039	5e		 pop	 esi
  0003a	5b		 pop	 ebx
  0003b	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00041	3b ec		 cmp	 ebp, esp
  00043	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00048	8b e5		 mov	 esp, ebp
  0004a	5d		 pop	 ebp
  0004b	c3		 ret	 0
_glmc_decompose_scalev ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Light\source\repos\Spacemonster\Spacemonster-code\glmc\affine.c
;	COMDAT _glmc_rotate_atm
_TEXT	SEGMENT
_m$ = 8							; size = 4
_pivot$ = 12						; size = 4
_angle$ = 16						; size = 4
_axis$ = 20						; size = 4
_glmc_rotate_atm PROC					; COMDAT

; 109  : glmc_rotate_atm(mat4 m, vec3 pivot, float angle, vec3 axis) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __8C2D01EA_affine@c
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 110  :   glm_rotate_atm(m, pivot, angle, axis);

  00028	8b 45 14	 mov	 eax, DWORD PTR _axis$[ebp]
  0002b	50		 push	 eax
  0002c	51		 push	 ecx
  0002d	f3 0f 10 45 10	 movss	 xmm0, DWORD PTR _angle$[ebp]
  00032	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00037	8b 4d 0c	 mov	 ecx, DWORD PTR _pivot$[ebp]
  0003a	51		 push	 ecx
  0003b	8b 55 08	 mov	 edx, DWORD PTR _m$[ebp]
  0003e	52		 push	 edx
  0003f	e8 00 00 00 00	 call	 _glm_rotate_atm
  00044	83 c4 10	 add	 esp, 16			; 00000010H

; 111  : }

  00047	5f		 pop	 edi
  00048	5e		 pop	 esi
  00049	5b		 pop	 ebx
  0004a	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00050	3b ec		 cmp	 ebp, esp
  00052	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00057	8b e5		 mov	 esp, ebp
  00059	5d		 pop	 ebp
  0005a	c3		 ret	 0
_glmc_rotate_atm ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Light\source\repos\Spacemonster\Spacemonster-code\glmc\affine.c
;	COMDAT _glmc_rotate_at
_TEXT	SEGMENT
_m$ = 8							; size = 4
_pivot$ = 12						; size = 4
_angle$ = 16						; size = 4
_axis$ = 20						; size = 4
_glmc_rotate_at PROC					; COMDAT

; 103  : glmc_rotate_at(mat4 m, vec3 pivot, float angle, vec3 axis) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __8C2D01EA_affine@c
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 104  :   glm_rotate_at(m, pivot, angle, axis);

  00028	8b 45 14	 mov	 eax, DWORD PTR _axis$[ebp]
  0002b	50		 push	 eax
  0002c	51		 push	 ecx
  0002d	f3 0f 10 45 10	 movss	 xmm0, DWORD PTR _angle$[ebp]
  00032	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00037	8b 4d 0c	 mov	 ecx, DWORD PTR _pivot$[ebp]
  0003a	51		 push	 ecx
  0003b	8b 55 08	 mov	 edx, DWORD PTR _m$[ebp]
  0003e	52		 push	 edx
  0003f	e8 00 00 00 00	 call	 _glm_rotate_at
  00044	83 c4 10	 add	 esp, 16			; 00000010H

; 105  : }

  00047	5f		 pop	 edi
  00048	5e		 pop	 esi
  00049	5b		 pop	 ebx
  0004a	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00050	3b ec		 cmp	 ebp, esp
  00052	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00057	8b e5		 mov	 esp, ebp
  00059	5d		 pop	 ebp
  0005a	c3		 ret	 0
_glmc_rotate_at ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Light\source\repos\Spacemonster\Spacemonster-code\glmc\affine.c
;	COMDAT _glmc_rotate
_TEXT	SEGMENT
_m$ = 8							; size = 4
_angle$ = 12						; size = 4
_axis$ = 16						; size = 4
_glmc_rotate PROC					; COMDAT

; 97   : glmc_rotate(mat4 m, float angle, vec3 axis) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __8C2D01EA_affine@c
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 98   :   glm_rotate(m, angle, axis);

  00028	8b 45 10	 mov	 eax, DWORD PTR _axis$[ebp]
  0002b	50		 push	 eax
  0002c	51		 push	 ecx
  0002d	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _angle$[ebp]
  00032	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00037	8b 4d 08	 mov	 ecx, DWORD PTR _m$[ebp]
  0003a	51		 push	 ecx
  0003b	e8 00 00 00 00	 call	 _glm_rotate
  00040	83 c4 0c	 add	 esp, 12			; 0000000cH

; 99   : }

  00043	5f		 pop	 edi
  00044	5e		 pop	 esi
  00045	5b		 pop	 ebx
  00046	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0004c	3b ec		 cmp	 ebp, esp
  0004e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00053	8b e5		 mov	 esp, ebp
  00055	5d		 pop	 ebp
  00056	c3		 ret	 0
_glmc_rotate ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Light\source\repos\Spacemonster\Spacemonster-code\glmc\affine.c
;	COMDAT _glmc_rotate_make
_TEXT	SEGMENT
_m$ = 8							; size = 4
_angle$ = 12						; size = 4
_axis$ = 16						; size = 4
_glmc_rotate_make PROC					; COMDAT

; 91   : glmc_rotate_make(mat4 m, float angle, vec3 axis) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __8C2D01EA_affine@c
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 92   :   glm_rotate_make(m, angle, axis);

  00028	8b 45 10	 mov	 eax, DWORD PTR _axis$[ebp]
  0002b	50		 push	 eax
  0002c	51		 push	 ecx
  0002d	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _angle$[ebp]
  00032	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00037	8b 4d 08	 mov	 ecx, DWORD PTR _m$[ebp]
  0003a	51		 push	 ecx
  0003b	e8 00 00 00 00	 call	 _glm_rotate_make
  00040	83 c4 0c	 add	 esp, 12			; 0000000cH

; 93   : }

  00043	5f		 pop	 edi
  00044	5e		 pop	 esi
  00045	5b		 pop	 ebx
  00046	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0004c	3b ec		 cmp	 ebp, esp
  0004e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00053	8b e5		 mov	 esp, ebp
  00055	5d		 pop	 ebp
  00056	c3		 ret	 0
_glmc_rotate_make ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Light\source\repos\Spacemonster\Spacemonster-code\glmc\affine.c
;	COMDAT _glmc_rotate_z
_TEXT	SEGMENT
_m$ = 8							; size = 4
_rad$ = 12						; size = 4
_dest$ = 16						; size = 4
_glmc_rotate_z PROC					; COMDAT

; 85   : glmc_rotate_z(mat4 m, float rad, mat4 dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __8C2D01EA_affine@c
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 86   :   glm_rotate_z(m, rad, dest);

  00028	8b 45 10	 mov	 eax, DWORD PTR _dest$[ebp]
  0002b	50		 push	 eax
  0002c	51		 push	 ecx
  0002d	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _rad$[ebp]
  00032	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00037	8b 4d 08	 mov	 ecx, DWORD PTR _m$[ebp]
  0003a	51		 push	 ecx
  0003b	e8 00 00 00 00	 call	 _glm_rotate_z
  00040	83 c4 0c	 add	 esp, 12			; 0000000cH

; 87   : }

  00043	5f		 pop	 edi
  00044	5e		 pop	 esi
  00045	5b		 pop	 ebx
  00046	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0004c	3b ec		 cmp	 ebp, esp
  0004e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00053	8b e5		 mov	 esp, ebp
  00055	5d		 pop	 ebp
  00056	c3		 ret	 0
_glmc_rotate_z ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Light\source\repos\Spacemonster\Spacemonster-code\glmc\affine.c
;	COMDAT _glmc_rotate_y
_TEXT	SEGMENT
_m$ = 8							; size = 4
_rad$ = 12						; size = 4
_dest$ = 16						; size = 4
_glmc_rotate_y PROC					; COMDAT

; 79   : glmc_rotate_y(mat4 m, float rad, mat4 dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __8C2D01EA_affine@c
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 80   :   glm_rotate_y(m, rad, dest);

  00028	8b 45 10	 mov	 eax, DWORD PTR _dest$[ebp]
  0002b	50		 push	 eax
  0002c	51		 push	 ecx
  0002d	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _rad$[ebp]
  00032	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00037	8b 4d 08	 mov	 ecx, DWORD PTR _m$[ebp]
  0003a	51		 push	 ecx
  0003b	e8 00 00 00 00	 call	 _glm_rotate_y
  00040	83 c4 0c	 add	 esp, 12			; 0000000cH

; 81   : }

  00043	5f		 pop	 edi
  00044	5e		 pop	 esi
  00045	5b		 pop	 ebx
  00046	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0004c	3b ec		 cmp	 ebp, esp
  0004e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00053	8b e5		 mov	 esp, ebp
  00055	5d		 pop	 ebp
  00056	c3		 ret	 0
_glmc_rotate_y ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Light\source\repos\Spacemonster\Spacemonster-code\glmc\affine.c
;	COMDAT _glmc_rotate_x
_TEXT	SEGMENT
_m$ = 8							; size = 4
_rad$ = 12						; size = 4
_dest$ = 16						; size = 4
_glmc_rotate_x PROC					; COMDAT

; 73   : glmc_rotate_x(mat4 m, float rad, mat4 dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __8C2D01EA_affine@c
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 74   :   glm_rotate_x(m, rad, dest);

  00028	8b 45 10	 mov	 eax, DWORD PTR _dest$[ebp]
  0002b	50		 push	 eax
  0002c	51		 push	 ecx
  0002d	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _rad$[ebp]
  00032	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00037	8b 4d 08	 mov	 ecx, DWORD PTR _m$[ebp]
  0003a	51		 push	 ecx
  0003b	e8 00 00 00 00	 call	 _glm_rotate_x
  00040	83 c4 0c	 add	 esp, 12			; 0000000cH

; 75   : }

  00043	5f		 pop	 edi
  00044	5e		 pop	 esi
  00045	5b		 pop	 ebx
  00046	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0004c	3b ec		 cmp	 ebp, esp
  0004e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00053	8b e5		 mov	 esp, ebp
  00055	5d		 pop	 ebp
  00056	c3		 ret	 0
_glmc_rotate_x ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Light\source\repos\Spacemonster\Spacemonster-code\glmc\affine.c
;	COMDAT _glmc_scale_uni
_TEXT	SEGMENT
_m$ = 8							; size = 4
_s$ = 12						; size = 4
_glmc_scale_uni PROC					; COMDAT

; 67   : glmc_scale_uni(mat4 m, float s) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __8C2D01EA_affine@c
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 68   :   glm_scale_uni(m, s);

  00028	51		 push	 ecx
  00029	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _s$[ebp]
  0002e	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00033	8b 45 08	 mov	 eax, DWORD PTR _m$[ebp]
  00036	50		 push	 eax
  00037	e8 00 00 00 00	 call	 _glm_scale_uni
  0003c	83 c4 08	 add	 esp, 8

; 69   : }

  0003f	5f		 pop	 edi
  00040	5e		 pop	 esi
  00041	5b		 pop	 ebx
  00042	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00048	3b ec		 cmp	 ebp, esp
  0004a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004f	8b e5		 mov	 esp, ebp
  00051	5d		 pop	 ebp
  00052	c3		 ret	 0
_glmc_scale_uni ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Light\source\repos\Spacemonster\Spacemonster-code\glmc\affine.c
;	COMDAT _glmc_scale
_TEXT	SEGMENT
_m$ = 8							; size = 4
_v$ = 12						; size = 4
_glmc_scale PROC					; COMDAT

; 61   : glmc_scale(mat4 m, vec3 v) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __8C2D01EA_affine@c
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 62   :   glm_scale(m, v);

  00028	8b 45 0c	 mov	 eax, DWORD PTR _v$[ebp]
  0002b	50		 push	 eax
  0002c	8b 4d 08	 mov	 ecx, DWORD PTR _m$[ebp]
  0002f	51		 push	 ecx
  00030	e8 00 00 00 00	 call	 _glm_scale
  00035	83 c4 08	 add	 esp, 8

; 63   : }

  00038	5f		 pop	 edi
  00039	5e		 pop	 esi
  0003a	5b		 pop	 ebx
  0003b	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00041	3b ec		 cmp	 ebp, esp
  00043	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00048	8b e5		 mov	 esp, ebp
  0004a	5d		 pop	 ebp
  0004b	c3		 ret	 0
_glmc_scale ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Light\source\repos\Spacemonster\Spacemonster-code\glmc\affine.c
;	COMDAT _glmc_scale_to
_TEXT	SEGMENT
_m$ = 8							; size = 4
_v$ = 12						; size = 4
_dest$ = 16						; size = 4
_glmc_scale_to PROC					; COMDAT

; 55   : glmc_scale_to(mat4 m, vec3 v, mat4 dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __8C2D01EA_affine@c
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 56   :   glm_scale_to(m, v, dest);

  00028	8b 45 10	 mov	 eax, DWORD PTR _dest$[ebp]
  0002b	50		 push	 eax
  0002c	8b 4d 0c	 mov	 ecx, DWORD PTR _v$[ebp]
  0002f	51		 push	 ecx
  00030	8b 55 08	 mov	 edx, DWORD PTR _m$[ebp]
  00033	52		 push	 edx
  00034	e8 00 00 00 00	 call	 _glm_scale_to
  00039	83 c4 0c	 add	 esp, 12			; 0000000cH

; 57   : }

  0003c	5f		 pop	 edi
  0003d	5e		 pop	 esi
  0003e	5b		 pop	 ebx
  0003f	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00045	3b ec		 cmp	 ebp, esp
  00047	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004c	8b e5		 mov	 esp, ebp
  0004e	5d		 pop	 ebp
  0004f	c3		 ret	 0
_glmc_scale_to ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Light\source\repos\Spacemonster\Spacemonster-code\glmc\affine.c
;	COMDAT _glmc_scale_make
_TEXT	SEGMENT
_m$ = 8							; size = 4
_v$ = 12						; size = 4
_glmc_scale_make PROC					; COMDAT

; 49   : glmc_scale_make(mat4 m, vec3 v) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __8C2D01EA_affine@c
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 50   :   glm_scale_make(m, v);

  00028	8b 45 0c	 mov	 eax, DWORD PTR _v$[ebp]
  0002b	50		 push	 eax
  0002c	8b 4d 08	 mov	 ecx, DWORD PTR _m$[ebp]
  0002f	51		 push	 ecx
  00030	e8 00 00 00 00	 call	 _glm_scale_make
  00035	83 c4 08	 add	 esp, 8

; 51   : }

  00038	5f		 pop	 edi
  00039	5e		 pop	 esi
  0003a	5b		 pop	 ebx
  0003b	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00041	3b ec		 cmp	 ebp, esp
  00043	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00048	8b e5		 mov	 esp, ebp
  0004a	5d		 pop	 ebp
  0004b	c3		 ret	 0
_glmc_scale_make ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Light\source\repos\Spacemonster\Spacemonster-code\glmc\affine.c
;	COMDAT _glmc_translate_z
_TEXT	SEGMENT
_m$ = 8							; size = 4
_to$ = 12						; size = 4
_glmc_translate_z PROC					; COMDAT

; 43   : glmc_translate_z(mat4 m, float to) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __8C2D01EA_affine@c
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 44   :   glm_translate_z(m, to);

  00028	51		 push	 ecx
  00029	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _to$[ebp]
  0002e	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00033	8b 45 08	 mov	 eax, DWORD PTR _m$[ebp]
  00036	50		 push	 eax
  00037	e8 00 00 00 00	 call	 _glm_translate_z
  0003c	83 c4 08	 add	 esp, 8

; 45   : }

  0003f	5f		 pop	 edi
  00040	5e		 pop	 esi
  00041	5b		 pop	 ebx
  00042	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00048	3b ec		 cmp	 ebp, esp
  0004a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004f	8b e5		 mov	 esp, ebp
  00051	5d		 pop	 ebp
  00052	c3		 ret	 0
_glmc_translate_z ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Light\source\repos\Spacemonster\Spacemonster-code\glmc\affine.c
;	COMDAT _glmc_translate_y
_TEXT	SEGMENT
_m$ = 8							; size = 4
_to$ = 12						; size = 4
_glmc_translate_y PROC					; COMDAT

; 37   : glmc_translate_y(mat4 m, float to) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __8C2D01EA_affine@c
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 38   :   glm_translate_y(m, to);

  00028	51		 push	 ecx
  00029	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _to$[ebp]
  0002e	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00033	8b 45 08	 mov	 eax, DWORD PTR _m$[ebp]
  00036	50		 push	 eax
  00037	e8 00 00 00 00	 call	 _glm_translate_y
  0003c	83 c4 08	 add	 esp, 8

; 39   : }

  0003f	5f		 pop	 edi
  00040	5e		 pop	 esi
  00041	5b		 pop	 ebx
  00042	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00048	3b ec		 cmp	 ebp, esp
  0004a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004f	8b e5		 mov	 esp, ebp
  00051	5d		 pop	 ebp
  00052	c3		 ret	 0
_glmc_translate_y ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Light\source\repos\Spacemonster\Spacemonster-code\glmc\affine.c
;	COMDAT _glmc_translate_x
_TEXT	SEGMENT
_m$ = 8							; size = 4
_to$ = 12						; size = 4
_glmc_translate_x PROC					; COMDAT

; 31   : glmc_translate_x(mat4 m, float to) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __8C2D01EA_affine@c
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 32   :   glm_translate_x(m, to);

  00028	51		 push	 ecx
  00029	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _to$[ebp]
  0002e	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00033	8b 45 08	 mov	 eax, DWORD PTR _m$[ebp]
  00036	50		 push	 eax
  00037	e8 00 00 00 00	 call	 _glm_translate_x
  0003c	83 c4 08	 add	 esp, 8

; 33   : }

  0003f	5f		 pop	 edi
  00040	5e		 pop	 esi
  00041	5b		 pop	 ebx
  00042	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00048	3b ec		 cmp	 ebp, esp
  0004a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004f	8b e5		 mov	 esp, ebp
  00051	5d		 pop	 ebp
  00052	c3		 ret	 0
_glmc_translate_x ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Light\source\repos\Spacemonster\Spacemonster-code\glmc\affine.c
;	COMDAT _glmc_translate
_TEXT	SEGMENT
_m$ = 8							; size = 4
_v$ = 12						; size = 4
_glmc_translate PROC					; COMDAT

; 25   : glmc_translate(mat4 m, vec3 v) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __8C2D01EA_affine@c
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 26   :   glm_translate(m, v);

  00028	8b 45 0c	 mov	 eax, DWORD PTR _v$[ebp]
  0002b	50		 push	 eax
  0002c	8b 4d 08	 mov	 ecx, DWORD PTR _m$[ebp]
  0002f	51		 push	 ecx
  00030	e8 00 00 00 00	 call	 _glm_translate
  00035	83 c4 08	 add	 esp, 8

; 27   : }

  00038	5f		 pop	 edi
  00039	5e		 pop	 esi
  0003a	5b		 pop	 ebx
  0003b	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00041	3b ec		 cmp	 ebp, esp
  00043	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00048	8b e5		 mov	 esp, ebp
  0004a	5d		 pop	 ebp
  0004b	c3		 ret	 0
_glmc_translate ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Light\source\repos\Spacemonster\Spacemonster-code\glmc\affine.c
;	COMDAT _glmc_translate_to
_TEXT	SEGMENT
_m$ = 8							; size = 4
_v$ = 12						; size = 4
_dest$ = 16						; size = 4
_glmc_translate_to PROC					; COMDAT

; 19   : glmc_translate_to(mat4 m, vec3 v, mat4 dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __8C2D01EA_affine@c
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 20   :   glm_translate_to(m, v, dest);

  00028	8b 45 10	 mov	 eax, DWORD PTR _dest$[ebp]
  0002b	50		 push	 eax
  0002c	8b 4d 0c	 mov	 ecx, DWORD PTR _v$[ebp]
  0002f	51		 push	 ecx
  00030	8b 55 08	 mov	 edx, DWORD PTR _m$[ebp]
  00033	52		 push	 edx
  00034	e8 00 00 00 00	 call	 _glm_translate_to
  00039	83 c4 0c	 add	 esp, 12			; 0000000cH

; 21   : }

  0003c	5f		 pop	 edi
  0003d	5e		 pop	 esi
  0003e	5b		 pop	 ebx
  0003f	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00045	3b ec		 cmp	 ebp, esp
  00047	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004c	8b e5		 mov	 esp, ebp
  0004e	5d		 pop	 ebp
  0004f	c3		 ret	 0
_glmc_translate_to ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Light\source\repos\Spacemonster\Spacemonster-code\glmc\affine.c
;	COMDAT _glmc_translate_make
_TEXT	SEGMENT
_m$ = 8							; size = 4
_v$ = 12						; size = 4
_glmc_translate_make PROC				; COMDAT

; 13   : glmc_translate_make(mat4 m, vec3 v) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __8C2D01EA_affine@c
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 14   :   glm_translate_make(m, v);

  00028	8b 45 0c	 mov	 eax, DWORD PTR _v$[ebp]
  0002b	50		 push	 eax
  0002c	8b 4d 08	 mov	 ecx, DWORD PTR _m$[ebp]
  0002f	51		 push	 ecx
  00030	e8 00 00 00 00	 call	 _glm_translate_make
  00035	83 c4 08	 add	 esp, 8

; 15   : }

  00038	5f		 pop	 edi
  00039	5e		 pop	 esi
  0003a	5b		 pop	 ebx
  0003b	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00041	3b ec		 cmp	 ebp, esp
  00043	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00048	8b e5		 mov	 esp, ebp
  0004a	5d		 pop	 ebp
  0004b	c3		 ret	 0
_glmc_translate_make ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Light\source\repos\Spacemonster\Spacemonster-code\include\affine.h
;	COMDAT _glm_decompose
_TEXT	SEGMENT
_m$ = 8							; size = 4
_t$ = 12						; size = 4
_r$ = 16						; size = 4
_s$ = 20						; size = 4
_glm_decompose PROC					; COMDAT

; 481  : glm_decompose(mat4 m, vec4 t, mat4 r, vec3 s) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __40ECD150_affine@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 482  :   glm_vec4_copy(m[3], t);

  00028	8b 45 0c	 mov	 eax, DWORD PTR _t$[ebp]
  0002b	50		 push	 eax
  0002c	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  00031	6b d1 03	 imul	 edx, ecx, 3
  00034	03 55 08	 add	 edx, DWORD PTR _m$[ebp]
  00037	52		 push	 edx
  00038	e8 00 00 00 00	 call	 _glm_vec4_copy
  0003d	83 c4 08	 add	 esp, 8

; 483  :   glm_decompose_rs(m, r, s);

  00040	8b 45 14	 mov	 eax, DWORD PTR _s$[ebp]
  00043	50		 push	 eax
  00044	8b 4d 10	 mov	 ecx, DWORD PTR _r$[ebp]
  00047	51		 push	 ecx
  00048	8b 55 08	 mov	 edx, DWORD PTR _m$[ebp]
  0004b	52		 push	 edx
  0004c	e8 00 00 00 00	 call	 _glm_decompose_rs
  00051	83 c4 0c	 add	 esp, 12			; 0000000cH

; 484  : }

  00054	5f		 pop	 edi
  00055	5e		 pop	 esi
  00056	5b		 pop	 ebx
  00057	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0005d	3b ec		 cmp	 ebp, esp
  0005f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00064	8b e5		 mov	 esp, ebp
  00066	5d		 pop	 ebp
  00067	c3		 ret	 0
_glm_decompose ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Light\source\repos\Spacemonster\Spacemonster-code\include\affine.h
;	COMDAT _glm_decompose_rs
_TEXT	SEGMENT
tv243 = -256						; size = 4
_v$ = -56						; size = 12
_t$ = -32						; size = 16
__$ArrayPad$ = -4					; size = 4
_m$ = 8							; size = 4
_r$ = 12						; size = 4
_s$ = 16						; size = 4
_glm_decompose_rs PROC					; COMDAT

; 441  : glm_decompose_rs(mat4 m, mat4 r, vec3 s) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 f0	 and	 esp, -16		; fffffff0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec 08 01 00
	00		 sub	 esp, 264		; 00000108H
  0001c	56		 push	 esi
  0001d	57		 push	 edi
  0001e	8d bd f8 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-264]
  00024	b9 42 00 00 00	 mov	 ecx, 66			; 00000042H
  00029	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002e	f3 ab		 rep stosd
  00030	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00035	33 c5		 xor	 eax, ebp
  00037	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0003a	b9 00 00 00 00	 mov	 ecx, OFFSET __40ECD150_affine@h
  0003f	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 442  :   CGLM_ALIGN(16) vec4 t = {0.0f, 0.0f, 0.0f, 1.0f};

  00044	0f 57 c0	 xorps	 xmm0, xmm0
  00047	f3 0f 11 45 e0	 movss	 DWORD PTR _t$[ebp], xmm0
  0004c	0f 57 c0	 xorps	 xmm0, xmm0
  0004f	f3 0f 11 45 e4	 movss	 DWORD PTR _t$[ebp+4], xmm0
  00054	0f 57 c0	 xorps	 xmm0, xmm0
  00057	f3 0f 11 45 e8	 movss	 DWORD PTR _t$[ebp+8], xmm0
  0005c	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00064	f3 0f 11 45 ec	 movss	 DWORD PTR _t$[ebp+12], xmm0

; 443  :   CGLM_ALIGN(8)  vec3 v;
; 444  : 
; 445  :   glm_vec4_copy(m[0], r[0]);

  00069	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  0006e	6b c8 00	 imul	 ecx, eax, 0
  00071	03 4b 0c	 add	 ecx, DWORD PTR _r$[ebx]
  00074	51		 push	 ecx
  00075	ba 10 00 00 00	 mov	 edx, 16			; 00000010H
  0007a	6b c2 00	 imul	 eax, edx, 0
  0007d	03 43 08	 add	 eax, DWORD PTR _m$[ebx]
  00080	50		 push	 eax
  00081	e8 00 00 00 00	 call	 _glm_vec4_copy
  00086	83 c4 08	 add	 esp, 8

; 446  :   glm_vec4_copy(m[1], r[1]);

  00089	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  0008e	c1 e0 00	 shl	 eax, 0
  00091	03 43 0c	 add	 eax, DWORD PTR _r$[ebx]
  00094	50		 push	 eax
  00095	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  0009a	c1 e1 00	 shl	 ecx, 0
  0009d	03 4b 08	 add	 ecx, DWORD PTR _m$[ebx]
  000a0	51		 push	 ecx
  000a1	e8 00 00 00 00	 call	 _glm_vec4_copy
  000a6	83 c4 08	 add	 esp, 8

; 447  :   glm_vec4_copy(m[2], r[2]);

  000a9	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  000ae	d1 e0		 shl	 eax, 1
  000b0	03 43 0c	 add	 eax, DWORD PTR _r$[ebx]
  000b3	50		 push	 eax
  000b4	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  000b9	d1 e1		 shl	 ecx, 1
  000bb	03 4b 08	 add	 ecx, DWORD PTR _m$[ebx]
  000be	51		 push	 ecx
  000bf	e8 00 00 00 00	 call	 _glm_vec4_copy
  000c4	83 c4 08	 add	 esp, 8

; 448  :   glm_vec4_copy(t,    r[3]);

  000c7	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  000cc	6b c8 03	 imul	 ecx, eax, 3
  000cf	03 4b 0c	 add	 ecx, DWORD PTR _r$[ebx]
  000d2	51		 push	 ecx
  000d3	8d 55 e0	 lea	 edx, DWORD PTR _t$[ebp]
  000d6	52		 push	 edx
  000d7	e8 00 00 00 00	 call	 _glm_vec4_copy
  000dc	83 c4 08	 add	 esp, 8

; 449  : 
; 450  :   s[0] = glm_vec3_norm(m[0]);

  000df	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  000e4	6b c8 00	 imul	 ecx, eax, 0
  000e7	03 4b 08	 add	 ecx, DWORD PTR _m$[ebx]
  000ea	51		 push	 ecx
  000eb	e8 00 00 00 00	 call	 _glm_vec3_norm
  000f0	83 c4 04	 add	 esp, 4
  000f3	ba 04 00 00 00	 mov	 edx, 4
  000f8	6b c2 00	 imul	 eax, edx, 0
  000fb	8b 4b 10	 mov	 ecx, DWORD PTR _s$[ebx]
  000fe	d9 1c 01	 fstp	 DWORD PTR [ecx+eax]

; 451  :   s[1] = glm_vec3_norm(m[1]);

  00101	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  00106	c1 e0 00	 shl	 eax, 0
  00109	03 43 08	 add	 eax, DWORD PTR _m$[ebx]
  0010c	50		 push	 eax
  0010d	e8 00 00 00 00	 call	 _glm_vec3_norm
  00112	83 c4 04	 add	 esp, 4
  00115	b9 04 00 00 00	 mov	 ecx, 4
  0011a	c1 e1 00	 shl	 ecx, 0
  0011d	8b 53 10	 mov	 edx, DWORD PTR _s$[ebx]
  00120	d9 1c 0a	 fstp	 DWORD PTR [edx+ecx]

; 452  :   s[2] = glm_vec3_norm(m[2]);

  00123	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  00128	d1 e0		 shl	 eax, 1
  0012a	03 43 08	 add	 eax, DWORD PTR _m$[ebx]
  0012d	50		 push	 eax
  0012e	e8 00 00 00 00	 call	 _glm_vec3_norm
  00133	83 c4 04	 add	 esp, 4
  00136	b9 04 00 00 00	 mov	 ecx, 4
  0013b	d1 e1		 shl	 ecx, 1
  0013d	8b 53 10	 mov	 edx, DWORD PTR _s$[ebx]
  00140	d9 1c 0a	 fstp	 DWORD PTR [edx+ecx]

; 453  : 
; 454  :   glm_vec4_scale(r[0], 1.0f/s[0], r[0]);

  00143	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  00148	6b c8 00	 imul	 ecx, eax, 0
  0014b	03 4b 0c	 add	 ecx, DWORD PTR _r$[ebx]
  0014e	51		 push	 ecx
  0014f	ba 04 00 00 00	 mov	 edx, 4
  00154	6b c2 00	 imul	 eax, edx, 0
  00157	8b 4b 10	 mov	 ecx, DWORD PTR _s$[ebx]
  0015a	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00162	f3 0f 5e 04 01	 divss	 xmm0, DWORD PTR [ecx+eax]
  00167	51		 push	 ecx
  00168	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0016d	ba 10 00 00 00	 mov	 edx, 16			; 00000010H
  00172	6b c2 00	 imul	 eax, edx, 0
  00175	03 43 0c	 add	 eax, DWORD PTR _r$[ebx]
  00178	50		 push	 eax
  00179	e8 00 00 00 00	 call	 _glm_vec4_scale
  0017e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 455  :   glm_vec4_scale(r[1], 1.0f/s[1], r[1]);

  00181	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  00186	c1 e0 00	 shl	 eax, 0
  00189	03 43 0c	 add	 eax, DWORD PTR _r$[ebx]
  0018c	50		 push	 eax
  0018d	b9 04 00 00 00	 mov	 ecx, 4
  00192	c1 e1 00	 shl	 ecx, 0
  00195	8b 53 10	 mov	 edx, DWORD PTR _s$[ebx]
  00198	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  001a0	f3 0f 5e 04 0a	 divss	 xmm0, DWORD PTR [edx+ecx]
  001a5	51		 push	 ecx
  001a6	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001ab	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  001b0	c1 e0 00	 shl	 eax, 0
  001b3	03 43 0c	 add	 eax, DWORD PTR _r$[ebx]
  001b6	50		 push	 eax
  001b7	e8 00 00 00 00	 call	 _glm_vec4_scale
  001bc	83 c4 0c	 add	 esp, 12			; 0000000cH

; 456  :   glm_vec4_scale(r[2], 1.0f/s[2], r[2]);

  001bf	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  001c4	d1 e0		 shl	 eax, 1
  001c6	03 43 0c	 add	 eax, DWORD PTR _r$[ebx]
  001c9	50		 push	 eax
  001ca	b9 04 00 00 00	 mov	 ecx, 4
  001cf	d1 e1		 shl	 ecx, 1
  001d1	8b 53 10	 mov	 edx, DWORD PTR _s$[ebx]
  001d4	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  001dc	f3 0f 5e 04 0a	 divss	 xmm0, DWORD PTR [edx+ecx]
  001e1	51		 push	 ecx
  001e2	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001e7	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  001ec	d1 e0		 shl	 eax, 1
  001ee	03 43 0c	 add	 eax, DWORD PTR _r$[ebx]
  001f1	50		 push	 eax
  001f2	e8 00 00 00 00	 call	 _glm_vec4_scale
  001f7	83 c4 0c	 add	 esp, 12			; 0000000cH

; 457  : 
; 458  :   /* Note from Apple Open Source (asume that the matrix is orthonormal):
; 459  :      check for a coordinate system flip.  If the determinant
; 460  :      is -1, then negate the matrix and the scaling factors. */
; 461  :   glm_vec3_cross(m[0], m[1], v);

  001fa	8d 45 c8	 lea	 eax, DWORD PTR _v$[ebp]
  001fd	50		 push	 eax
  001fe	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  00203	c1 e1 00	 shl	 ecx, 0
  00206	03 4b 08	 add	 ecx, DWORD PTR _m$[ebx]
  00209	51		 push	 ecx
  0020a	ba 10 00 00 00	 mov	 edx, 16			; 00000010H
  0020f	6b c2 00	 imul	 eax, edx, 0
  00212	03 43 08	 add	 eax, DWORD PTR _m$[ebx]
  00215	50		 push	 eax
  00216	e8 00 00 00 00	 call	 _glm_vec3_cross
  0021b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 462  :   if (glm_vec3_dot(v, m[2]) < 0.0f) {

  0021e	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  00223	d1 e0		 shl	 eax, 1
  00225	03 43 08	 add	 eax, DWORD PTR _m$[ebx]
  00228	50		 push	 eax
  00229	8d 4d c8	 lea	 ecx, DWORD PTR _v$[ebp]
  0022c	51		 push	 ecx
  0022d	e8 00 00 00 00	 call	 _glm_vec3_dot
  00232	83 c4 08	 add	 esp, 8
  00235	d9 9d 00 ff ff
	ff		 fstp	 DWORD PTR tv243[ebp]
  0023b	0f 57 c0	 xorps	 xmm0, xmm0
  0023e	0f 2f 85 00 ff
	ff ff		 comiss	 xmm0, DWORD PTR tv243[ebp]
  00245	76 47		 jbe	 SHORT $LN2@glm_decomp

; 463  :     glm_vec4_negate(r[0]);

  00247	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  0024c	6b c8 00	 imul	 ecx, eax, 0
  0024f	03 4b 0c	 add	 ecx, DWORD PTR _r$[ebx]
  00252	51		 push	 ecx
  00253	e8 00 00 00 00	 call	 _glm_vec4_negate
  00258	83 c4 04	 add	 esp, 4

; 464  :     glm_vec4_negate(r[1]);

  0025b	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  00260	c1 e0 00	 shl	 eax, 0
  00263	03 43 0c	 add	 eax, DWORD PTR _r$[ebx]
  00266	50		 push	 eax
  00267	e8 00 00 00 00	 call	 _glm_vec4_negate
  0026c	83 c4 04	 add	 esp, 4

; 465  :     glm_vec4_negate(r[2]);

  0026f	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  00274	d1 e0		 shl	 eax, 1
  00276	03 43 0c	 add	 eax, DWORD PTR _r$[ebx]
  00279	50		 push	 eax
  0027a	e8 00 00 00 00	 call	 _glm_vec4_negate
  0027f	83 c4 04	 add	 esp, 4

; 466  :     glm_vec3_negate(s);

  00282	8b 43 10	 mov	 eax, DWORD PTR _s$[ebx]
  00285	50		 push	 eax
  00286	e8 00 00 00 00	 call	 _glm_vec3_negate
  0028b	83 c4 04	 add	 esp, 4
$LN2@glm_decomp:

; 467  :   }
; 468  : }

  0028e	52		 push	 edx
  0028f	8b cd		 mov	 ecx, ebp
  00291	50		 push	 eax
  00292	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN7@glm_decomp
  00298	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  0029d	58		 pop	 eax
  0029e	5a		 pop	 edx
  0029f	5f		 pop	 edi
  002a0	5e		 pop	 esi
  002a1	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002a4	33 cd		 xor	 ecx, ebp
  002a6	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002ab	8b e5		 mov	 esp, ebp
  002ad	5d		 pop	 ebp
  002ae	8b e3		 mov	 esp, ebx
  002b0	5b		 pop	 ebx
  002b1	c3		 ret	 0
  002b2	66 90		 npad	 2
$LN7@glm_decomp:
  002b4	02 00 00 00	 DD	 2
  002b8	00 00 00 00	 DD	 $LN6@glm_decomp
$LN6@glm_decomp:
  002bc	e0 ff ff ff	 DD	 -32			; ffffffe0H
  002c0	10 00 00 00	 DD	 16			; 00000010H
  002c4	00 00 00 00	 DD	 $LN4@glm_decomp
  002c8	c8 ff ff ff	 DD	 -56			; ffffffc8H
  002cc	0c 00 00 00	 DD	 12			; 0000000cH
  002d0	00 00 00 00	 DD	 $LN5@glm_decomp
$LN5@glm_decomp:
  002d4	76		 DB	 118			; 00000076H
  002d5	00		 DB	 0
$LN4@glm_decomp:
  002d6	74		 DB	 116			; 00000074H
  002d7	00		 DB	 0
_glm_decompose_rs ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Light\source\repos\Spacemonster\Spacemonster-code\include\affine.h
;	COMDAT _glm_uniscaled
_TEXT	SEGMENT
_s$ = -24						; size = 12
__$ArrayPad$ = -4					; size = 4
_m$ = 8							; size = 4
_glm_uniscaled PROC					; COMDAT

; 425  : glm_uniscaled(mat4 m) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 f8	 and	 esp, -8			; fffffff8H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec e0 00 00
	00		 sub	 esp, 224		; 000000e0H
  0001c	56		 push	 esi
  0001d	57		 push	 edi
  0001e	8d bd 20 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-224]
  00024	b9 38 00 00 00	 mov	 ecx, 56			; 00000038H
  00029	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002e	f3 ab		 rep stosd
  00030	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00035	33 c5		 xor	 eax, ebp
  00037	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0003a	b9 00 00 00 00	 mov	 ecx, OFFSET __40ECD150_affine@h
  0003f	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 426  :   CGLM_ALIGN(8) vec3 s;
; 427  :   glm_decompose_scalev(m, s);

  00044	8d 45 e8	 lea	 eax, DWORD PTR _s$[ebp]
  00047	50		 push	 eax
  00048	8b 4b 08	 mov	 ecx, DWORD PTR _m$[ebx]
  0004b	51		 push	 ecx
  0004c	e8 00 00 00 00	 call	 _glm_decompose_scalev
  00051	83 c4 08	 add	 esp, 8

; 428  :   return glm_vec3_eq_all(s);

  00054	8d 45 e8	 lea	 eax, DWORD PTR _s$[ebp]
  00057	50		 push	 eax
  00058	e8 00 00 00 00	 call	 _glm_vec3_eq_all
  0005d	83 c4 04	 add	 esp, 4

; 429  : }

  00060	52		 push	 edx
  00061	8b cd		 mov	 ecx, ebp
  00063	50		 push	 eax
  00064	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN5@glm_unisca
  0006a	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  0006f	58		 pop	 eax
  00070	5a		 pop	 edx
  00071	5f		 pop	 edi
  00072	5e		 pop	 esi
  00073	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00076	33 cd		 xor	 ecx, ebp
  00078	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0007d	8b e5		 mov	 esp, ebp
  0007f	5d		 pop	 ebp
  00080	8b e3		 mov	 esp, ebx
  00082	5b		 pop	 ebx
  00083	c3		 ret	 0
$LN5@glm_unisca:
  00084	01 00 00 00	 DD	 1
  00088	00 00 00 00	 DD	 $LN4@glm_unisca
$LN4@glm_unisca:
  0008c	e8 ff ff ff	 DD	 -24			; ffffffe8H
  00090	0c 00 00 00	 DD	 12			; 0000000cH
  00094	00 00 00 00	 DD	 $LN3@glm_unisca
$LN3@glm_unisca:
  00098	73		 DB	 115			; 00000073H
  00099	00		 DB	 0
_glm_uniscaled ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Light\source\repos\Spacemonster\Spacemonster-code\include\affine.h
;	COMDAT _glm_decompose_scalev
_TEXT	SEGMENT
_m$ = 8							; size = 4
_s$ = 12						; size = 4
_glm_decompose_scalev PROC				; COMDAT

; 409  : glm_decompose_scalev(mat4 m, vec3 s) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __40ECD150_affine@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 410  :   s[0] = glm_vec3_norm(m[0]);

  00028	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  0002d	6b c8 00	 imul	 ecx, eax, 0
  00030	03 4d 08	 add	 ecx, DWORD PTR _m$[ebp]
  00033	51		 push	 ecx
  00034	e8 00 00 00 00	 call	 _glm_vec3_norm
  00039	83 c4 04	 add	 esp, 4
  0003c	ba 04 00 00 00	 mov	 edx, 4
  00041	6b c2 00	 imul	 eax, edx, 0
  00044	8b 4d 0c	 mov	 ecx, DWORD PTR _s$[ebp]
  00047	d9 1c 01	 fstp	 DWORD PTR [ecx+eax]

; 411  :   s[1] = glm_vec3_norm(m[1]);

  0004a	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  0004f	c1 e0 00	 shl	 eax, 0
  00052	03 45 08	 add	 eax, DWORD PTR _m$[ebp]
  00055	50		 push	 eax
  00056	e8 00 00 00 00	 call	 _glm_vec3_norm
  0005b	83 c4 04	 add	 esp, 4
  0005e	b9 04 00 00 00	 mov	 ecx, 4
  00063	c1 e1 00	 shl	 ecx, 0
  00066	8b 55 0c	 mov	 edx, DWORD PTR _s$[ebp]
  00069	d9 1c 0a	 fstp	 DWORD PTR [edx+ecx]

; 412  :   s[2] = glm_vec3_norm(m[2]);

  0006c	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  00071	d1 e0		 shl	 eax, 1
  00073	03 45 08	 add	 eax, DWORD PTR _m$[ebp]
  00076	50		 push	 eax
  00077	e8 00 00 00 00	 call	 _glm_vec3_norm
  0007c	83 c4 04	 add	 esp, 4
  0007f	b9 04 00 00 00	 mov	 ecx, 4
  00084	d1 e1		 shl	 ecx, 1
  00086	8b 55 0c	 mov	 edx, DWORD PTR _s$[ebp]
  00089	d9 1c 0a	 fstp	 DWORD PTR [edx+ecx]

; 413  : }

  0008c	5f		 pop	 edi
  0008d	5e		 pop	 esi
  0008e	5b		 pop	 ebx
  0008f	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00095	3b ec		 cmp	 ebp, esp
  00097	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0009c	8b e5		 mov	 esp, ebp
  0009e	5d		 pop	 ebp
  0009f	c3		 ret	 0
_glm_decompose_scalev ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Light\source\repos\Spacemonster\Spacemonster-code\include\affine.h
;	COMDAT _glm_rotate_atm
_TEXT	SEGMENT
_pivotInv$ = -24					; size = 12
__$ArrayPad$ = -4					; size = 4
_m$ = 8							; size = 4
_pivot$ = 12						; size = 4
_angle$ = 16						; size = 4
_axis$ = 20						; size = 4
_glm_rotate_atm PROC					; COMDAT

; 391  : glm_rotate_atm(mat4 m, vec3 pivot, float angle, vec3 axis) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 f8	 and	 esp, -8			; fffffff8H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec e0 00 00
	00		 sub	 esp, 224		; 000000e0H
  0001c	56		 push	 esi
  0001d	57		 push	 edi
  0001e	8d bd 20 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-224]
  00024	b9 38 00 00 00	 mov	 ecx, 56			; 00000038H
  00029	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002e	f3 ab		 rep stosd
  00030	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00035	33 c5		 xor	 eax, ebp
  00037	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0003a	b9 00 00 00 00	 mov	 ecx, OFFSET __40ECD150_affine@h
  0003f	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 392  :   CGLM_ALIGN(8) vec3 pivotInv;
; 393  : 
; 394  :   glm_vec3_negate_to(pivot, pivotInv);

  00044	8d 45 e8	 lea	 eax, DWORD PTR _pivotInv$[ebp]
  00047	50		 push	 eax
  00048	8b 4b 0c	 mov	 ecx, DWORD PTR _pivot$[ebx]
  0004b	51		 push	 ecx
  0004c	e8 00 00 00 00	 call	 _glm_vec3_negate_to
  00051	83 c4 08	 add	 esp, 8

; 395  : 
; 396  :   glm_translate_make(m, pivot);

  00054	8b 43 0c	 mov	 eax, DWORD PTR _pivot$[ebx]
  00057	50		 push	 eax
  00058	8b 4b 08	 mov	 ecx, DWORD PTR _m$[ebx]
  0005b	51		 push	 ecx
  0005c	e8 00 00 00 00	 call	 _glm_translate_make
  00061	83 c4 08	 add	 esp, 8

; 397  :   glm_rotate(m, angle, axis);

  00064	8b 43 14	 mov	 eax, DWORD PTR _axis$[ebx]
  00067	50		 push	 eax
  00068	51		 push	 ecx
  00069	f3 0f 10 43 10	 movss	 xmm0, DWORD PTR _angle$[ebx]
  0006e	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00073	8b 4b 08	 mov	 ecx, DWORD PTR _m$[ebx]
  00076	51		 push	 ecx
  00077	e8 00 00 00 00	 call	 _glm_rotate
  0007c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 398  :   glm_translate(m, pivotInv);

  0007f	8d 45 e8	 lea	 eax, DWORD PTR _pivotInv$[ebp]
  00082	50		 push	 eax
  00083	8b 4b 08	 mov	 ecx, DWORD PTR _m$[ebx]
  00086	51		 push	 ecx
  00087	e8 00 00 00 00	 call	 _glm_translate
  0008c	83 c4 08	 add	 esp, 8

; 399  : }

  0008f	52		 push	 edx
  00090	8b cd		 mov	 ecx, ebp
  00092	50		 push	 eax
  00093	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN5@glm_rotate
  00099	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  0009e	58		 pop	 eax
  0009f	5a		 pop	 edx
  000a0	5f		 pop	 edi
  000a1	5e		 pop	 esi
  000a2	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000a5	33 cd		 xor	 ecx, ebp
  000a7	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000ac	8b e5		 mov	 esp, ebp
  000ae	5d		 pop	 ebp
  000af	8b e3		 mov	 esp, ebx
  000b1	5b		 pop	 ebx
  000b2	c3		 ret	 0
  000b3	90		 npad	 1
$LN5@glm_rotate:
  000b4	01 00 00 00	 DD	 1
  000b8	00 00 00 00	 DD	 $LN4@glm_rotate
$LN4@glm_rotate:
  000bc	e8 ff ff ff	 DD	 -24			; ffffffe8H
  000c0	0c 00 00 00	 DD	 12			; 0000000cH
  000c4	00 00 00 00	 DD	 $LN3@glm_rotate
$LN3@glm_rotate:
  000c8	70		 DB	 112			; 00000070H
  000c9	69		 DB	 105			; 00000069H
  000ca	76		 DB	 118			; 00000076H
  000cb	6f		 DB	 111			; 0000006fH
  000cc	74		 DB	 116			; 00000074H
  000cd	49		 DB	 73			; 00000049H
  000ce	6e		 DB	 110			; 0000006eH
  000cf	76		 DB	 118			; 00000076H
  000d0	00		 DB	 0
_glm_rotate_atm ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Light\source\repos\Spacemonster\Spacemonster-code\include\affine.h
;	COMDAT _glm_rotate_at
_TEXT	SEGMENT
_pivotInv$ = -24					; size = 12
__$ArrayPad$ = -4					; size = 4
_m$ = 8							; size = 4
_pivot$ = 12						; size = 4
_angle$ = 16						; size = 4
_axis$ = 20						; size = 4
_glm_rotate_at PROC					; COMDAT

; 366  : glm_rotate_at(mat4 m, vec3 pivot, float angle, vec3 axis) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 f8	 and	 esp, -8			; fffffff8H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec e0 00 00
	00		 sub	 esp, 224		; 000000e0H
  0001c	56		 push	 esi
  0001d	57		 push	 edi
  0001e	8d bd 20 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-224]
  00024	b9 38 00 00 00	 mov	 ecx, 56			; 00000038H
  00029	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002e	f3 ab		 rep stosd
  00030	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00035	33 c5		 xor	 eax, ebp
  00037	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0003a	b9 00 00 00 00	 mov	 ecx, OFFSET __40ECD150_affine@h
  0003f	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 367  :   CGLM_ALIGN(8) vec3 pivotInv;
; 368  : 
; 369  :   glm_vec3_negate_to(pivot, pivotInv);

  00044	8d 45 e8	 lea	 eax, DWORD PTR _pivotInv$[ebp]
  00047	50		 push	 eax
  00048	8b 4b 0c	 mov	 ecx, DWORD PTR _pivot$[ebx]
  0004b	51		 push	 ecx
  0004c	e8 00 00 00 00	 call	 _glm_vec3_negate_to
  00051	83 c4 08	 add	 esp, 8

; 370  : 
; 371  :   glm_translate(m, pivot);

  00054	8b 43 0c	 mov	 eax, DWORD PTR _pivot$[ebx]
  00057	50		 push	 eax
  00058	8b 4b 08	 mov	 ecx, DWORD PTR _m$[ebx]
  0005b	51		 push	 ecx
  0005c	e8 00 00 00 00	 call	 _glm_translate
  00061	83 c4 08	 add	 esp, 8

; 372  :   glm_rotate(m, angle, axis);

  00064	8b 43 14	 mov	 eax, DWORD PTR _axis$[ebx]
  00067	50		 push	 eax
  00068	51		 push	 ecx
  00069	f3 0f 10 43 10	 movss	 xmm0, DWORD PTR _angle$[ebx]
  0006e	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00073	8b 4b 08	 mov	 ecx, DWORD PTR _m$[ebx]
  00076	51		 push	 ecx
  00077	e8 00 00 00 00	 call	 _glm_rotate
  0007c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 373  :   glm_translate(m, pivotInv);

  0007f	8d 45 e8	 lea	 eax, DWORD PTR _pivotInv$[ebp]
  00082	50		 push	 eax
  00083	8b 4b 08	 mov	 ecx, DWORD PTR _m$[ebx]
  00086	51		 push	 ecx
  00087	e8 00 00 00 00	 call	 _glm_translate
  0008c	83 c4 08	 add	 esp, 8

; 374  : }

  0008f	52		 push	 edx
  00090	8b cd		 mov	 ecx, ebp
  00092	50		 push	 eax
  00093	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN5@glm_rotate
  00099	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  0009e	58		 pop	 eax
  0009f	5a		 pop	 edx
  000a0	5f		 pop	 edi
  000a1	5e		 pop	 esi
  000a2	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000a5	33 cd		 xor	 ecx, ebp
  000a7	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000ac	8b e5		 mov	 esp, ebp
  000ae	5d		 pop	 ebp
  000af	8b e3		 mov	 esp, ebx
  000b1	5b		 pop	 ebx
  000b2	c3		 ret	 0
  000b3	90		 npad	 1
$LN5@glm_rotate:
  000b4	01 00 00 00	 DD	 1
  000b8	00 00 00 00	 DD	 $LN4@glm_rotate
$LN4@glm_rotate:
  000bc	e8 ff ff ff	 DD	 -24			; ffffffe8H
  000c0	0c 00 00 00	 DD	 12			; 0000000cH
  000c4	00 00 00 00	 DD	 $LN3@glm_rotate
$LN3@glm_rotate:
  000c8	70		 DB	 112			; 00000070H
  000c9	69		 DB	 105			; 00000069H
  000ca	76		 DB	 118			; 00000076H
  000cb	6f		 DB	 111			; 0000006fH
  000cc	74		 DB	 116			; 00000074H
  000cd	49		 DB	 73			; 00000049H
  000ce	6e		 DB	 110			; 0000006eH
  000cf	76		 DB	 118			; 00000076H
  000d0	00		 DB	 0
_glm_rotate_at ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Light\source\repos\Spacemonster\Spacemonster-code\include\affine.h
;	COMDAT _glm_rotate
_TEXT	SEGMENT
_rot$ = -80						; size = 64
__$ArrayPad$ = -4					; size = 4
_m$ = 8							; size = 4
_angle$ = 12						; size = 4
_axis$ = 16						; size = 4
_glm_rotate PROC					; COMDAT

; 349  : glm_rotate(mat4 m, float angle, vec3 axis) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 f0	 and	 esp, -16		; fffffff0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec 18 01 00
	00		 sub	 esp, 280		; 00000118H
  0001c	56		 push	 esi
  0001d	57		 push	 edi
  0001e	8d bd e8 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-280]
  00024	b9 46 00 00 00	 mov	 ecx, 70			; 00000046H
  00029	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002e	f3 ab		 rep stosd
  00030	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00035	33 c5		 xor	 eax, ebp
  00037	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0003a	b9 00 00 00 00	 mov	 ecx, OFFSET __40ECD150_affine@h
  0003f	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 350  :   CGLM_ALIGN_MAT mat4 rot;
; 351  :   glm_rotate_make(rot, angle, axis);

  00044	8b 43 10	 mov	 eax, DWORD PTR _axis$[ebx]
  00047	50		 push	 eax
  00048	51		 push	 ecx
  00049	f3 0f 10 43 0c	 movss	 xmm0, DWORD PTR _angle$[ebx]
  0004e	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00053	8d 4d b0	 lea	 ecx, DWORD PTR _rot$[ebp]
  00056	51		 push	 ecx
  00057	e8 00 00 00 00	 call	 _glm_rotate_make
  0005c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 352  :   glm_mul_rot(m, rot, m);

  0005f	8b 43 08	 mov	 eax, DWORD PTR _m$[ebx]
  00062	50		 push	 eax
  00063	8d 4d b0	 lea	 ecx, DWORD PTR _rot$[ebp]
  00066	51		 push	 ecx
  00067	8b 53 08	 mov	 edx, DWORD PTR _m$[ebx]
  0006a	52		 push	 edx
  0006b	e8 00 00 00 00	 call	 _glm_mul_rot
  00070	83 c4 0c	 add	 esp, 12			; 0000000cH

; 353  : }

  00073	52		 push	 edx
  00074	8b cd		 mov	 ecx, ebp
  00076	50		 push	 eax
  00077	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN5@glm_rotate
  0007d	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00082	58		 pop	 eax
  00083	5a		 pop	 edx
  00084	5f		 pop	 edi
  00085	5e		 pop	 esi
  00086	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00089	33 cd		 xor	 ecx, ebp
  0008b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00090	8b e5		 mov	 esp, ebp
  00092	5d		 pop	 ebp
  00093	8b e3		 mov	 esp, ebx
  00095	5b		 pop	 ebx
  00096	c3		 ret	 0
  00097	90		 npad	 1
$LN5@glm_rotate:
  00098	01 00 00 00	 DD	 1
  0009c	00 00 00 00	 DD	 $LN4@glm_rotate
$LN4@glm_rotate:
  000a0	b0 ff ff ff	 DD	 -80			; ffffffb0H
  000a4	40 00 00 00	 DD	 64			; 00000040H
  000a8	00 00 00 00	 DD	 $LN3@glm_rotate
$LN3@glm_rotate:
  000ac	72		 DB	 114			; 00000072H
  000ad	6f		 DB	 111			; 0000006fH
  000ae	74		 DB	 116			; 00000074H
  000af	00		 DB	 0
_glm_rotate ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Light\source\repos\Spacemonster\Spacemonster-code\include\affine.h
;	COMDAT _glm_rotate_make
_TEXT	SEGMENT
_c$ = -84						; size = 4
_vs$ = -72						; size = 12
_v$ = -48						; size = 12
_axisn$ = -24						; size = 12
__$ArrayPad$ = -4					; size = 4
_m$ = 8							; size = 4
_angle$ = 12						; size = 4
_axis$ = 16						; size = 4
_glm_rotate_make PROC					; COMDAT

; 318  : glm_rotate_make(mat4 m, float angle, vec3 axis) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 f8	 and	 esp, -8			; fffffff8H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec 18 01 00
	00		 sub	 esp, 280		; 00000118H
  0001c	56		 push	 esi
  0001d	57		 push	 edi
  0001e	8d bd e8 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-280]
  00024	b9 46 00 00 00	 mov	 ecx, 70			; 00000046H
  00029	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002e	f3 ab		 rep stosd
  00030	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00035	33 c5		 xor	 eax, ebp
  00037	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0003a	b9 00 00 00 00	 mov	 ecx, OFFSET __40ECD150_affine@h
  0003f	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 319  :   CGLM_ALIGN(8) vec3 axisn, v, vs;
; 320  :   float c;
; 321  : 
; 322  :   c = cosf(angle);

  00044	51		 push	 ecx
  00045	f3 0f 10 43 0c	 movss	 xmm0, DWORD PTR _angle$[ebx]
  0004a	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0004f	e8 00 00 00 00	 call	 _cosf
  00054	83 c4 04	 add	 esp, 4
  00057	d9 5d ac	 fstp	 DWORD PTR _c$[ebp]

; 323  : 
; 324  :   glm_vec3_normalize_to(axis, axisn);

  0005a	8d 45 e8	 lea	 eax, DWORD PTR _axisn$[ebp]
  0005d	50		 push	 eax
  0005e	8b 4b 10	 mov	 ecx, DWORD PTR _axis$[ebx]
  00061	51		 push	 ecx
  00062	e8 00 00 00 00	 call	 _glm_vec3_normalize_to
  00067	83 c4 08	 add	 esp, 8

; 325  :   glm_vec3_scale(axisn, 1.0f - c, v);

  0006a	8d 45 d0	 lea	 eax, DWORD PTR _v$[ebp]
  0006d	50		 push	 eax
  0006e	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00076	f3 0f 5c 45 ac	 subss	 xmm0, DWORD PTR _c$[ebp]
  0007b	51		 push	 ecx
  0007c	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00081	8d 4d e8	 lea	 ecx, DWORD PTR _axisn$[ebp]
  00084	51		 push	 ecx
  00085	e8 00 00 00 00	 call	 _glm_vec3_scale
  0008a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 326  :   glm_vec3_scale(axisn, sinf(angle), vs);

  0008d	8d 45 b8	 lea	 eax, DWORD PTR _vs$[ebp]
  00090	50		 push	 eax
  00091	51		 push	 ecx
  00092	f3 0f 10 43 0c	 movss	 xmm0, DWORD PTR _angle$[ebx]
  00097	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0009c	e8 00 00 00 00	 call	 _sinf
  000a1	d9 1c 24	 fstp	 DWORD PTR [esp]
  000a4	8d 4d e8	 lea	 ecx, DWORD PTR _axisn$[ebp]
  000a7	51		 push	 ecx
  000a8	e8 00 00 00 00	 call	 _glm_vec3_scale
  000ad	83 c4 0c	 add	 esp, 12			; 0000000cH

; 327  : 
; 328  :   glm_vec3_scale(axisn, v[0], m[0]);

  000b0	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  000b5	6b c8 00	 imul	 ecx, eax, 0
  000b8	03 4b 08	 add	 ecx, DWORD PTR _m$[ebx]
  000bb	51		 push	 ecx
  000bc	ba 04 00 00 00	 mov	 edx, 4
  000c1	6b c2 00	 imul	 eax, edx, 0
  000c4	51		 push	 ecx
  000c5	f3 0f 10 44 05
	d0		 movss	 xmm0, DWORD PTR _v$[ebp+eax]
  000cb	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000d0	8d 4d e8	 lea	 ecx, DWORD PTR _axisn$[ebp]
  000d3	51		 push	 ecx
  000d4	e8 00 00 00 00	 call	 _glm_vec3_scale
  000d9	83 c4 0c	 add	 esp, 12			; 0000000cH

; 329  :   glm_vec3_scale(axisn, v[1], m[1]);

  000dc	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  000e1	c1 e0 00	 shl	 eax, 0
  000e4	03 43 08	 add	 eax, DWORD PTR _m$[ebx]
  000e7	50		 push	 eax
  000e8	b9 04 00 00 00	 mov	 ecx, 4
  000ed	c1 e1 00	 shl	 ecx, 0
  000f0	51		 push	 ecx
  000f1	f3 0f 10 44 0d
	d0		 movss	 xmm0, DWORD PTR _v$[ebp+ecx]
  000f7	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000fc	8d 55 e8	 lea	 edx, DWORD PTR _axisn$[ebp]
  000ff	52		 push	 edx
  00100	e8 00 00 00 00	 call	 _glm_vec3_scale
  00105	83 c4 0c	 add	 esp, 12			; 0000000cH

; 330  :   glm_vec3_scale(axisn, v[2], m[2]);

  00108	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  0010d	d1 e0		 shl	 eax, 1
  0010f	03 43 08	 add	 eax, DWORD PTR _m$[ebx]
  00112	50		 push	 eax
  00113	b9 04 00 00 00	 mov	 ecx, 4
  00118	d1 e1		 shl	 ecx, 1
  0011a	51		 push	 ecx
  0011b	f3 0f 10 44 0d
	d0		 movss	 xmm0, DWORD PTR _v$[ebp+ecx]
  00121	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00126	8d 55 e8	 lea	 edx, DWORD PTR _axisn$[ebp]
  00129	52		 push	 edx
  0012a	e8 00 00 00 00	 call	 _glm_vec3_scale
  0012f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 331  : 
; 332  :   m[0][0] += c;       m[1][0] -= vs[2];   m[2][0] += vs[1];

  00132	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  00137	6b c8 00	 imul	 ecx, eax, 0
  0013a	03 4b 08	 add	 ecx, DWORD PTR _m$[ebx]
  0013d	ba 04 00 00 00	 mov	 edx, 4
  00142	6b c2 00	 imul	 eax, edx, 0
  00145	f3 0f 10 04 01	 movss	 xmm0, DWORD PTR [ecx+eax]
  0014a	f3 0f 58 45 ac	 addss	 xmm0, DWORD PTR _c$[ebp]
  0014f	b9 04 00 00 00	 mov	 ecx, 4
  00154	6b d1 00	 imul	 edx, ecx, 0
  00157	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  0015c	6b c8 00	 imul	 ecx, eax, 0
  0015f	03 4b 08	 add	 ecx, DWORD PTR _m$[ebx]
  00162	f3 0f 11 04 11	 movss	 DWORD PTR [ecx+edx], xmm0
  00167	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  0016c	c1 e0 00	 shl	 eax, 0
  0016f	03 43 08	 add	 eax, DWORD PTR _m$[ebx]
  00172	b9 04 00 00 00	 mov	 ecx, 4
  00177	6b d1 00	 imul	 edx, ecx, 0
  0017a	b9 04 00 00 00	 mov	 ecx, 4
  0017f	d1 e1		 shl	 ecx, 1
  00181	f3 0f 10 04 10	 movss	 xmm0, DWORD PTR [eax+edx]
  00186	f3 0f 5c 44 0d
	b8		 subss	 xmm0, DWORD PTR _vs$[ebp+ecx]
  0018c	ba 04 00 00 00	 mov	 edx, 4
  00191	6b c2 00	 imul	 eax, edx, 0
  00194	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  00199	c1 e1 00	 shl	 ecx, 0
  0019c	03 4b 08	 add	 ecx, DWORD PTR _m$[ebx]
  0019f	f3 0f 11 04 01	 movss	 DWORD PTR [ecx+eax], xmm0
  001a4	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  001a9	d1 e0		 shl	 eax, 1
  001ab	03 43 08	 add	 eax, DWORD PTR _m$[ebx]
  001ae	b9 04 00 00 00	 mov	 ecx, 4
  001b3	6b d1 00	 imul	 edx, ecx, 0
  001b6	b9 04 00 00 00	 mov	 ecx, 4
  001bb	c1 e1 00	 shl	 ecx, 0
  001be	f3 0f 10 04 10	 movss	 xmm0, DWORD PTR [eax+edx]
  001c3	f3 0f 58 44 0d
	b8		 addss	 xmm0, DWORD PTR _vs$[ebp+ecx]
  001c9	ba 04 00 00 00	 mov	 edx, 4
  001ce	6b c2 00	 imul	 eax, edx, 0
  001d1	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  001d6	d1 e1		 shl	 ecx, 1
  001d8	03 4b 08	 add	 ecx, DWORD PTR _m$[ebx]
  001db	f3 0f 11 04 01	 movss	 DWORD PTR [ecx+eax], xmm0

; 333  :   m[0][1] += vs[2];   m[1][1] += c;       m[2][1] -= vs[0];

  001e0	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  001e5	6b c8 00	 imul	 ecx, eax, 0
  001e8	03 4b 08	 add	 ecx, DWORD PTR _m$[ebx]
  001eb	ba 04 00 00 00	 mov	 edx, 4
  001f0	c1 e2 00	 shl	 edx, 0
  001f3	b8 04 00 00 00	 mov	 eax, 4
  001f8	d1 e0		 shl	 eax, 1
  001fa	f3 0f 10 04 11	 movss	 xmm0, DWORD PTR [ecx+edx]
  001ff	f3 0f 58 44 05
	b8		 addss	 xmm0, DWORD PTR _vs$[ebp+eax]
  00205	b9 04 00 00 00	 mov	 ecx, 4
  0020a	c1 e1 00	 shl	 ecx, 0
  0020d	ba 10 00 00 00	 mov	 edx, 16			; 00000010H
  00212	6b c2 00	 imul	 eax, edx, 0
  00215	03 43 08	 add	 eax, DWORD PTR _m$[ebx]
  00218	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  0021d	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  00222	c1 e0 00	 shl	 eax, 0
  00225	03 43 08	 add	 eax, DWORD PTR _m$[ebx]
  00228	b9 04 00 00 00	 mov	 ecx, 4
  0022d	c1 e1 00	 shl	 ecx, 0
  00230	f3 0f 10 04 08	 movss	 xmm0, DWORD PTR [eax+ecx]
  00235	f3 0f 58 45 ac	 addss	 xmm0, DWORD PTR _c$[ebp]
  0023a	ba 04 00 00 00	 mov	 edx, 4
  0023f	c1 e2 00	 shl	 edx, 0
  00242	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  00247	c1 e0 00	 shl	 eax, 0
  0024a	03 43 08	 add	 eax, DWORD PTR _m$[ebx]
  0024d	f3 0f 11 04 10	 movss	 DWORD PTR [eax+edx], xmm0
  00252	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  00257	d1 e0		 shl	 eax, 1
  00259	03 43 08	 add	 eax, DWORD PTR _m$[ebx]
  0025c	b9 04 00 00 00	 mov	 ecx, 4
  00261	c1 e1 00	 shl	 ecx, 0
  00264	ba 04 00 00 00	 mov	 edx, 4
  00269	6b d2 00	 imul	 edx, edx, 0
  0026c	f3 0f 10 04 08	 movss	 xmm0, DWORD PTR [eax+ecx]
  00271	f3 0f 5c 44 15
	b8		 subss	 xmm0, DWORD PTR _vs$[ebp+edx]
  00277	b8 04 00 00 00	 mov	 eax, 4
  0027c	c1 e0 00	 shl	 eax, 0
  0027f	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  00284	d1 e1		 shl	 ecx, 1
  00286	03 4b 08	 add	 ecx, DWORD PTR _m$[ebx]
  00289	f3 0f 11 04 01	 movss	 DWORD PTR [ecx+eax], xmm0

; 334  :   m[0][2] -= vs[1];   m[1][2] += vs[0];   m[2][2] += c;

  0028e	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  00293	6b c8 00	 imul	 ecx, eax, 0
  00296	03 4b 08	 add	 ecx, DWORD PTR _m$[ebx]
  00299	ba 04 00 00 00	 mov	 edx, 4
  0029e	d1 e2		 shl	 edx, 1
  002a0	b8 04 00 00 00	 mov	 eax, 4
  002a5	c1 e0 00	 shl	 eax, 0
  002a8	f3 0f 10 04 11	 movss	 xmm0, DWORD PTR [ecx+edx]
  002ad	f3 0f 5c 44 05
	b8		 subss	 xmm0, DWORD PTR _vs$[ebp+eax]
  002b3	b9 04 00 00 00	 mov	 ecx, 4
  002b8	d1 e1		 shl	 ecx, 1
  002ba	ba 10 00 00 00	 mov	 edx, 16			; 00000010H
  002bf	6b c2 00	 imul	 eax, edx, 0
  002c2	03 43 08	 add	 eax, DWORD PTR _m$[ebx]
  002c5	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  002ca	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  002cf	c1 e0 00	 shl	 eax, 0
  002d2	03 43 08	 add	 eax, DWORD PTR _m$[ebx]
  002d5	b9 04 00 00 00	 mov	 ecx, 4
  002da	d1 e1		 shl	 ecx, 1
  002dc	ba 04 00 00 00	 mov	 edx, 4
  002e1	6b d2 00	 imul	 edx, edx, 0
  002e4	f3 0f 10 04 08	 movss	 xmm0, DWORD PTR [eax+ecx]
  002e9	f3 0f 58 44 15
	b8		 addss	 xmm0, DWORD PTR _vs$[ebp+edx]
  002ef	b8 04 00 00 00	 mov	 eax, 4
  002f4	d1 e0		 shl	 eax, 1
  002f6	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  002fb	c1 e1 00	 shl	 ecx, 0
  002fe	03 4b 08	 add	 ecx, DWORD PTR _m$[ebx]
  00301	f3 0f 11 04 01	 movss	 DWORD PTR [ecx+eax], xmm0
  00306	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  0030b	d1 e0		 shl	 eax, 1
  0030d	03 43 08	 add	 eax, DWORD PTR _m$[ebx]
  00310	b9 04 00 00 00	 mov	 ecx, 4
  00315	d1 e1		 shl	 ecx, 1
  00317	f3 0f 10 04 08	 movss	 xmm0, DWORD PTR [eax+ecx]
  0031c	f3 0f 58 45 ac	 addss	 xmm0, DWORD PTR _c$[ebp]
  00321	ba 04 00 00 00	 mov	 edx, 4
  00326	d1 e2		 shl	 edx, 1
  00328	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  0032d	d1 e0		 shl	 eax, 1
  0032f	03 43 08	 add	 eax, DWORD PTR _m$[ebx]
  00332	f3 0f 11 04 10	 movss	 DWORD PTR [eax+edx], xmm0

; 335  : 
; 336  :   m[0][3] = m[1][3] = m[2][3] = m[3][0] = m[3][1] = m[3][2] = 0.0f;

  00337	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  0033c	6b c8 03	 imul	 ecx, eax, 3
  0033f	03 4b 08	 add	 ecx, DWORD PTR _m$[ebx]
  00342	ba 04 00 00 00	 mov	 edx, 4
  00347	d1 e2		 shl	 edx, 1
  00349	0f 57 c0	 xorps	 xmm0, xmm0
  0034c	f3 0f 11 04 11	 movss	 DWORD PTR [ecx+edx], xmm0
  00351	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  00356	6b c8 03	 imul	 ecx, eax, 3
  00359	03 4b 08	 add	 ecx, DWORD PTR _m$[ebx]
  0035c	ba 04 00 00 00	 mov	 edx, 4
  00361	c1 e2 00	 shl	 edx, 0
  00364	0f 57 c0	 xorps	 xmm0, xmm0
  00367	f3 0f 11 04 11	 movss	 DWORD PTR [ecx+edx], xmm0
  0036c	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  00371	6b c8 03	 imul	 ecx, eax, 3
  00374	03 4b 08	 add	 ecx, DWORD PTR _m$[ebx]
  00377	ba 04 00 00 00	 mov	 edx, 4
  0037c	6b c2 00	 imul	 eax, edx, 0
  0037f	0f 57 c0	 xorps	 xmm0, xmm0
  00382	f3 0f 11 04 01	 movss	 DWORD PTR [ecx+eax], xmm0
  00387	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  0038c	d1 e1		 shl	 ecx, 1
  0038e	03 4b 08	 add	 ecx, DWORD PTR _m$[ebx]
  00391	ba 04 00 00 00	 mov	 edx, 4
  00396	6b c2 03	 imul	 eax, edx, 3
  00399	0f 57 c0	 xorps	 xmm0, xmm0
  0039c	f3 0f 11 04 01	 movss	 DWORD PTR [ecx+eax], xmm0
  003a1	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  003a6	c1 e1 00	 shl	 ecx, 0
  003a9	03 4b 08	 add	 ecx, DWORD PTR _m$[ebx]
  003ac	ba 04 00 00 00	 mov	 edx, 4
  003b1	6b c2 03	 imul	 eax, edx, 3
  003b4	0f 57 c0	 xorps	 xmm0, xmm0
  003b7	f3 0f 11 04 01	 movss	 DWORD PTR [ecx+eax], xmm0
  003bc	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  003c1	6b d1 00	 imul	 edx, ecx, 0
  003c4	03 53 08	 add	 edx, DWORD PTR _m$[ebx]
  003c7	b8 04 00 00 00	 mov	 eax, 4
  003cc	6b c8 03	 imul	 ecx, eax, 3
  003cf	0f 57 c0	 xorps	 xmm0, xmm0
  003d2	f3 0f 11 04 0a	 movss	 DWORD PTR [edx+ecx], xmm0

; 337  :   m[3][3] = 1.0f;

  003d7	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  003dc	6b c8 03	 imul	 ecx, eax, 3
  003df	03 4b 08	 add	 ecx, DWORD PTR _m$[ebx]
  003e2	ba 04 00 00 00	 mov	 edx, 4
  003e7	6b c2 03	 imul	 eax, edx, 3
  003ea	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  003f2	f3 0f 11 04 01	 movss	 DWORD PTR [ecx+eax], xmm0

; 338  : }

  003f7	52		 push	 edx
  003f8	8b cd		 mov	 ecx, ebp
  003fa	50		 push	 eax
  003fb	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN7@glm_rotate
  00401	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00406	58		 pop	 eax
  00407	5a		 pop	 edx
  00408	5f		 pop	 edi
  00409	5e		 pop	 esi
  0040a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0040d	33 cd		 xor	 ecx, ebp
  0040f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00414	8b e5		 mov	 esp, ebp
  00416	5d		 pop	 ebp
  00417	8b e3		 mov	 esp, ebx
  00419	5b		 pop	 ebx
  0041a	c3		 ret	 0
  0041b	90		 npad	 1
$LN7@glm_rotate:
  0041c	03 00 00 00	 DD	 3
  00420	00 00 00 00	 DD	 $LN6@glm_rotate
$LN6@glm_rotate:
  00424	e8 ff ff ff	 DD	 -24			; ffffffe8H
  00428	0c 00 00 00	 DD	 12			; 0000000cH
  0042c	00 00 00 00	 DD	 $LN3@glm_rotate
  00430	d0 ff ff ff	 DD	 -48			; ffffffd0H
  00434	0c 00 00 00	 DD	 12			; 0000000cH
  00438	00 00 00 00	 DD	 $LN4@glm_rotate
  0043c	b8 ff ff ff	 DD	 -72			; ffffffb8H
  00440	0c 00 00 00	 DD	 12			; 0000000cH
  00444	00 00 00 00	 DD	 $LN5@glm_rotate
$LN5@glm_rotate:
  00448	76		 DB	 118			; 00000076H
  00449	73		 DB	 115			; 00000073H
  0044a	00		 DB	 0
$LN4@glm_rotate:
  0044b	76		 DB	 118			; 00000076H
  0044c	00		 DB	 0
$LN3@glm_rotate:
  0044d	61		 DB	 97			; 00000061H
  0044e	78		 DB	 120			; 00000078H
  0044f	69		 DB	 105			; 00000069H
  00450	73		 DB	 115			; 00000073H
  00451	6e		 DB	 110			; 0000006eH
  00452	00		 DB	 0
_glm_rotate_make ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Light\source\repos\Spacemonster\Spacemonster-code\include\affine.h
;	COMDAT _glm_rotate_z
_TEXT	SEGMENT
_s$ = -104						; size = 4
_c$ = -92						; size = 4
_t$ = -80						; size = 64
__$ArrayPad$ = -4					; size = 4
_m$ = 8							; size = 4
_angle$ = 12						; size = 4
_dest$ = 16						; size = 4
_glm_rotate_z PROC					; COMDAT

; 292  : glm_rotate_z(mat4 m, float angle, mat4 dest) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 f0	 and	 esp, -16		; fffffff0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec 38 01 00
	00		 sub	 esp, 312		; 00000138H
  0001c	56		 push	 esi
  0001d	57		 push	 edi
  0001e	8d bd c8 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-312]
  00024	b9 4e 00 00 00	 mov	 ecx, 78			; 0000004eH
  00029	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002e	f3 ab		 rep stosd
  00030	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00035	33 c5		 xor	 eax, ebp
  00037	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0003a	b9 00 00 00 00	 mov	 ecx, OFFSET __40ECD150_affine@h
  0003f	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 293  :   CGLM_ALIGN_MAT mat4 t = GLM_MAT4_IDENTITY_INIT;

  00044	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  0004c	f3 0f 11 45 b0	 movss	 DWORD PTR _t$[ebp], xmm0
  00051	0f 57 c0	 xorps	 xmm0, xmm0
  00054	f3 0f 11 45 b4	 movss	 DWORD PTR _t$[ebp+4], xmm0
  00059	0f 57 c0	 xorps	 xmm0, xmm0
  0005c	f3 0f 11 45 b8	 movss	 DWORD PTR _t$[ebp+8], xmm0
  00061	0f 57 c0	 xorps	 xmm0, xmm0
  00064	f3 0f 11 45 bc	 movss	 DWORD PTR _t$[ebp+12], xmm0
  00069	0f 57 c0	 xorps	 xmm0, xmm0
  0006c	f3 0f 11 45 c0	 movss	 DWORD PTR _t$[ebp+16], xmm0
  00071	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00079	f3 0f 11 45 c4	 movss	 DWORD PTR _t$[ebp+20], xmm0
  0007e	0f 57 c0	 xorps	 xmm0, xmm0
  00081	f3 0f 11 45 c8	 movss	 DWORD PTR _t$[ebp+24], xmm0
  00086	0f 57 c0	 xorps	 xmm0, xmm0
  00089	f3 0f 11 45 cc	 movss	 DWORD PTR _t$[ebp+28], xmm0
  0008e	0f 57 c0	 xorps	 xmm0, xmm0
  00091	f3 0f 11 45 d0	 movss	 DWORD PTR _t$[ebp+32], xmm0
  00096	0f 57 c0	 xorps	 xmm0, xmm0
  00099	f3 0f 11 45 d4	 movss	 DWORD PTR _t$[ebp+36], xmm0
  0009e	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  000a6	f3 0f 11 45 d8	 movss	 DWORD PTR _t$[ebp+40], xmm0
  000ab	0f 57 c0	 xorps	 xmm0, xmm0
  000ae	f3 0f 11 45 dc	 movss	 DWORD PTR _t$[ebp+44], xmm0
  000b3	0f 57 c0	 xorps	 xmm0, xmm0
  000b6	f3 0f 11 45 e0	 movss	 DWORD PTR _t$[ebp+48], xmm0
  000bb	0f 57 c0	 xorps	 xmm0, xmm0
  000be	f3 0f 11 45 e4	 movss	 DWORD PTR _t$[ebp+52], xmm0
  000c3	0f 57 c0	 xorps	 xmm0, xmm0
  000c6	f3 0f 11 45 e8	 movss	 DWORD PTR _t$[ebp+56], xmm0
  000cb	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  000d3	f3 0f 11 45 ec	 movss	 DWORD PTR _t$[ebp+60], xmm0

; 294  :   float c, s;
; 295  : 
; 296  :   c = cosf(angle);

  000d8	51		 push	 ecx
  000d9	f3 0f 10 43 0c	 movss	 xmm0, DWORD PTR _angle$[ebx]
  000de	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000e3	e8 00 00 00 00	 call	 _cosf
  000e8	83 c4 04	 add	 esp, 4
  000eb	d9 5d a4	 fstp	 DWORD PTR _c$[ebp]

; 297  :   s = sinf(angle);

  000ee	51		 push	 ecx
  000ef	f3 0f 10 43 0c	 movss	 xmm0, DWORD PTR _angle$[ebx]
  000f4	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000f9	e8 00 00 00 00	 call	 _sinf
  000fe	83 c4 04	 add	 esp, 4
  00101	d9 5d 98	 fstp	 DWORD PTR _s$[ebp]

; 298  : 
; 299  :   t[0][0] =  c;

  00104	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  00109	6b c8 00	 imul	 ecx, eax, 0
  0010c	8d 54 0d b0	 lea	 edx, DWORD PTR _t$[ebp+ecx]
  00110	b8 04 00 00 00	 mov	 eax, 4
  00115	6b c8 00	 imul	 ecx, eax, 0
  00118	f3 0f 10 45 a4	 movss	 xmm0, DWORD PTR _c$[ebp]
  0011d	f3 0f 11 04 0a	 movss	 DWORD PTR [edx+ecx], xmm0

; 300  :   t[0][1] =  s;

  00122	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  00127	6b c8 00	 imul	 ecx, eax, 0
  0012a	8d 54 0d b0	 lea	 edx, DWORD PTR _t$[ebp+ecx]
  0012e	b8 04 00 00 00	 mov	 eax, 4
  00133	c1 e0 00	 shl	 eax, 0
  00136	f3 0f 10 45 98	 movss	 xmm0, DWORD PTR _s$[ebp]
  0013b	f3 0f 11 04 02	 movss	 DWORD PTR [edx+eax], xmm0

; 301  :   t[1][0] = -s;

  00140	f3 0f 10 45 98	 movss	 xmm0, DWORD PTR _s$[ebp]
  00145	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
  0014c	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  00151	c1 e0 00	 shl	 eax, 0
  00154	8d 4c 05 b0	 lea	 ecx, DWORD PTR _t$[ebp+eax]
  00158	ba 04 00 00 00	 mov	 edx, 4
  0015d	6b c2 00	 imul	 eax, edx, 0
  00160	f3 0f 11 04 01	 movss	 DWORD PTR [ecx+eax], xmm0

; 302  :   t[1][1] =  c;

  00165	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  0016a	c1 e0 00	 shl	 eax, 0
  0016d	8d 4c 05 b0	 lea	 ecx, DWORD PTR _t$[ebp+eax]
  00171	ba 04 00 00 00	 mov	 edx, 4
  00176	c1 e2 00	 shl	 edx, 0
  00179	f3 0f 10 45 a4	 movss	 xmm0, DWORD PTR _c$[ebp]
  0017e	f3 0f 11 04 11	 movss	 DWORD PTR [ecx+edx], xmm0

; 303  : 
; 304  :   glm_mul_rot(m, t, dest);

  00183	8b 43 10	 mov	 eax, DWORD PTR _dest$[ebx]
  00186	50		 push	 eax
  00187	8d 4d b0	 lea	 ecx, DWORD PTR _t$[ebp]
  0018a	51		 push	 ecx
  0018b	8b 53 08	 mov	 edx, DWORD PTR _m$[ebx]
  0018e	52		 push	 edx
  0018f	e8 00 00 00 00	 call	 _glm_mul_rot
  00194	83 c4 0c	 add	 esp, 12			; 0000000cH

; 305  : }

  00197	52		 push	 edx
  00198	8b cd		 mov	 ecx, ebp
  0019a	50		 push	 eax
  0019b	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN5@glm_rotate
  001a1	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  001a6	58		 pop	 eax
  001a7	5a		 pop	 edx
  001a8	5f		 pop	 edi
  001a9	5e		 pop	 esi
  001aa	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001ad	33 cd		 xor	 ecx, ebp
  001af	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001b4	8b e5		 mov	 esp, ebp
  001b6	5d		 pop	 ebp
  001b7	8b e3		 mov	 esp, ebx
  001b9	5b		 pop	 ebx
  001ba	c3		 ret	 0
  001bb	90		 npad	 1
$LN5@glm_rotate:
  001bc	01 00 00 00	 DD	 1
  001c0	00 00 00 00	 DD	 $LN4@glm_rotate
$LN4@glm_rotate:
  001c4	b0 ff ff ff	 DD	 -80			; ffffffb0H
  001c8	40 00 00 00	 DD	 64			; 00000040H
  001cc	00 00 00 00	 DD	 $LN3@glm_rotate
$LN3@glm_rotate:
  001d0	74		 DB	 116			; 00000074H
  001d1	00		 DB	 0
_glm_rotate_z ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Light\source\repos\Spacemonster\Spacemonster-code\include\affine.h
;	COMDAT _glm_rotate_y
_TEXT	SEGMENT
_s$ = -104						; size = 4
_c$ = -92						; size = 4
_t$ = -80						; size = 64
__$ArrayPad$ = -4					; size = 4
_m$ = 8							; size = 4
_angle$ = 12						; size = 4
_dest$ = 16						; size = 4
_glm_rotate_y PROC					; COMDAT

; 267  : glm_rotate_y(mat4 m, float angle, mat4 dest) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 f0	 and	 esp, -16		; fffffff0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec 38 01 00
	00		 sub	 esp, 312		; 00000138H
  0001c	56		 push	 esi
  0001d	57		 push	 edi
  0001e	8d bd c8 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-312]
  00024	b9 4e 00 00 00	 mov	 ecx, 78			; 0000004eH
  00029	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002e	f3 ab		 rep stosd
  00030	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00035	33 c5		 xor	 eax, ebp
  00037	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0003a	b9 00 00 00 00	 mov	 ecx, OFFSET __40ECD150_affine@h
  0003f	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 268  :   CGLM_ALIGN_MAT mat4 t = GLM_MAT4_IDENTITY_INIT;

  00044	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  0004c	f3 0f 11 45 b0	 movss	 DWORD PTR _t$[ebp], xmm0
  00051	0f 57 c0	 xorps	 xmm0, xmm0
  00054	f3 0f 11 45 b4	 movss	 DWORD PTR _t$[ebp+4], xmm0
  00059	0f 57 c0	 xorps	 xmm0, xmm0
  0005c	f3 0f 11 45 b8	 movss	 DWORD PTR _t$[ebp+8], xmm0
  00061	0f 57 c0	 xorps	 xmm0, xmm0
  00064	f3 0f 11 45 bc	 movss	 DWORD PTR _t$[ebp+12], xmm0
  00069	0f 57 c0	 xorps	 xmm0, xmm0
  0006c	f3 0f 11 45 c0	 movss	 DWORD PTR _t$[ebp+16], xmm0
  00071	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00079	f3 0f 11 45 c4	 movss	 DWORD PTR _t$[ebp+20], xmm0
  0007e	0f 57 c0	 xorps	 xmm0, xmm0
  00081	f3 0f 11 45 c8	 movss	 DWORD PTR _t$[ebp+24], xmm0
  00086	0f 57 c0	 xorps	 xmm0, xmm0
  00089	f3 0f 11 45 cc	 movss	 DWORD PTR _t$[ebp+28], xmm0
  0008e	0f 57 c0	 xorps	 xmm0, xmm0
  00091	f3 0f 11 45 d0	 movss	 DWORD PTR _t$[ebp+32], xmm0
  00096	0f 57 c0	 xorps	 xmm0, xmm0
  00099	f3 0f 11 45 d4	 movss	 DWORD PTR _t$[ebp+36], xmm0
  0009e	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  000a6	f3 0f 11 45 d8	 movss	 DWORD PTR _t$[ebp+40], xmm0
  000ab	0f 57 c0	 xorps	 xmm0, xmm0
  000ae	f3 0f 11 45 dc	 movss	 DWORD PTR _t$[ebp+44], xmm0
  000b3	0f 57 c0	 xorps	 xmm0, xmm0
  000b6	f3 0f 11 45 e0	 movss	 DWORD PTR _t$[ebp+48], xmm0
  000bb	0f 57 c0	 xorps	 xmm0, xmm0
  000be	f3 0f 11 45 e4	 movss	 DWORD PTR _t$[ebp+52], xmm0
  000c3	0f 57 c0	 xorps	 xmm0, xmm0
  000c6	f3 0f 11 45 e8	 movss	 DWORD PTR _t$[ebp+56], xmm0
  000cb	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  000d3	f3 0f 11 45 ec	 movss	 DWORD PTR _t$[ebp+60], xmm0

; 269  :   float c, s;
; 270  : 
; 271  :   c = cosf(angle);

  000d8	51		 push	 ecx
  000d9	f3 0f 10 43 0c	 movss	 xmm0, DWORD PTR _angle$[ebx]
  000de	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000e3	e8 00 00 00 00	 call	 _cosf
  000e8	83 c4 04	 add	 esp, 4
  000eb	d9 5d a4	 fstp	 DWORD PTR _c$[ebp]

; 272  :   s = sinf(angle);

  000ee	51		 push	 ecx
  000ef	f3 0f 10 43 0c	 movss	 xmm0, DWORD PTR _angle$[ebx]
  000f4	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000f9	e8 00 00 00 00	 call	 _sinf
  000fe	83 c4 04	 add	 esp, 4
  00101	d9 5d 98	 fstp	 DWORD PTR _s$[ebp]

; 273  : 
; 274  :   t[0][0] =  c;

  00104	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  00109	6b c8 00	 imul	 ecx, eax, 0
  0010c	8d 54 0d b0	 lea	 edx, DWORD PTR _t$[ebp+ecx]
  00110	b8 04 00 00 00	 mov	 eax, 4
  00115	6b c8 00	 imul	 ecx, eax, 0
  00118	f3 0f 10 45 a4	 movss	 xmm0, DWORD PTR _c$[ebp]
  0011d	f3 0f 11 04 0a	 movss	 DWORD PTR [edx+ecx], xmm0

; 275  :   t[0][2] = -s;

  00122	f3 0f 10 45 98	 movss	 xmm0, DWORD PTR _s$[ebp]
  00127	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
  0012e	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  00133	6b c8 00	 imul	 ecx, eax, 0
  00136	8d 54 0d b0	 lea	 edx, DWORD PTR _t$[ebp+ecx]
  0013a	b8 04 00 00 00	 mov	 eax, 4
  0013f	d1 e0		 shl	 eax, 1
  00141	f3 0f 11 04 02	 movss	 DWORD PTR [edx+eax], xmm0

; 276  :   t[2][0] =  s;

  00146	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  0014b	d1 e0		 shl	 eax, 1
  0014d	8d 4c 05 b0	 lea	 ecx, DWORD PTR _t$[ebp+eax]
  00151	ba 04 00 00 00	 mov	 edx, 4
  00156	6b c2 00	 imul	 eax, edx, 0
  00159	f3 0f 10 45 98	 movss	 xmm0, DWORD PTR _s$[ebp]
  0015e	f3 0f 11 04 01	 movss	 DWORD PTR [ecx+eax], xmm0

; 277  :   t[2][2] =  c;

  00163	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  00168	d1 e0		 shl	 eax, 1
  0016a	8d 4c 05 b0	 lea	 ecx, DWORD PTR _t$[ebp+eax]
  0016e	ba 04 00 00 00	 mov	 edx, 4
  00173	d1 e2		 shl	 edx, 1
  00175	f3 0f 10 45 a4	 movss	 xmm0, DWORD PTR _c$[ebp]
  0017a	f3 0f 11 04 11	 movss	 DWORD PTR [ecx+edx], xmm0

; 278  : 
; 279  :   glm_mul_rot(m, t, dest);

  0017f	8b 43 10	 mov	 eax, DWORD PTR _dest$[ebx]
  00182	50		 push	 eax
  00183	8d 4d b0	 lea	 ecx, DWORD PTR _t$[ebp]
  00186	51		 push	 ecx
  00187	8b 53 08	 mov	 edx, DWORD PTR _m$[ebx]
  0018a	52		 push	 edx
  0018b	e8 00 00 00 00	 call	 _glm_mul_rot
  00190	83 c4 0c	 add	 esp, 12			; 0000000cH

; 280  : }

  00193	52		 push	 edx
  00194	8b cd		 mov	 ecx, ebp
  00196	50		 push	 eax
  00197	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN5@glm_rotate
  0019d	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  001a2	58		 pop	 eax
  001a3	5a		 pop	 edx
  001a4	5f		 pop	 edi
  001a5	5e		 pop	 esi
  001a6	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001a9	33 cd		 xor	 ecx, ebp
  001ab	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001b0	8b e5		 mov	 esp, ebp
  001b2	5d		 pop	 ebp
  001b3	8b e3		 mov	 esp, ebx
  001b5	5b		 pop	 ebx
  001b6	c3		 ret	 0
  001b7	90		 npad	 1
$LN5@glm_rotate:
  001b8	01 00 00 00	 DD	 1
  001bc	00 00 00 00	 DD	 $LN4@glm_rotate
$LN4@glm_rotate:
  001c0	b0 ff ff ff	 DD	 -80			; ffffffb0H
  001c4	40 00 00 00	 DD	 64			; 00000040H
  001c8	00 00 00 00	 DD	 $LN3@glm_rotate
$LN3@glm_rotate:
  001cc	74		 DB	 116			; 00000074H
  001cd	00		 DB	 0
_glm_rotate_y ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Light\source\repos\Spacemonster\Spacemonster-code\include\affine.h
;	COMDAT _glm_rotate_x
_TEXT	SEGMENT
_s$ = -104						; size = 4
_c$ = -92						; size = 4
_t$ = -80						; size = 64
__$ArrayPad$ = -4					; size = 4
_m$ = 8							; size = 4
_angle$ = 12						; size = 4
_dest$ = 16						; size = 4
_glm_rotate_x PROC					; COMDAT

; 242  : glm_rotate_x(mat4 m, float angle, mat4 dest) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 f0	 and	 esp, -16		; fffffff0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec 38 01 00
	00		 sub	 esp, 312		; 00000138H
  0001c	56		 push	 esi
  0001d	57		 push	 edi
  0001e	8d bd c8 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-312]
  00024	b9 4e 00 00 00	 mov	 ecx, 78			; 0000004eH
  00029	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002e	f3 ab		 rep stosd
  00030	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00035	33 c5		 xor	 eax, ebp
  00037	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0003a	b9 00 00 00 00	 mov	 ecx, OFFSET __40ECD150_affine@h
  0003f	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 243  :   CGLM_ALIGN_MAT mat4 t = GLM_MAT4_IDENTITY_INIT;

  00044	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  0004c	f3 0f 11 45 b0	 movss	 DWORD PTR _t$[ebp], xmm0
  00051	0f 57 c0	 xorps	 xmm0, xmm0
  00054	f3 0f 11 45 b4	 movss	 DWORD PTR _t$[ebp+4], xmm0
  00059	0f 57 c0	 xorps	 xmm0, xmm0
  0005c	f3 0f 11 45 b8	 movss	 DWORD PTR _t$[ebp+8], xmm0
  00061	0f 57 c0	 xorps	 xmm0, xmm0
  00064	f3 0f 11 45 bc	 movss	 DWORD PTR _t$[ebp+12], xmm0
  00069	0f 57 c0	 xorps	 xmm0, xmm0
  0006c	f3 0f 11 45 c0	 movss	 DWORD PTR _t$[ebp+16], xmm0
  00071	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00079	f3 0f 11 45 c4	 movss	 DWORD PTR _t$[ebp+20], xmm0
  0007e	0f 57 c0	 xorps	 xmm0, xmm0
  00081	f3 0f 11 45 c8	 movss	 DWORD PTR _t$[ebp+24], xmm0
  00086	0f 57 c0	 xorps	 xmm0, xmm0
  00089	f3 0f 11 45 cc	 movss	 DWORD PTR _t$[ebp+28], xmm0
  0008e	0f 57 c0	 xorps	 xmm0, xmm0
  00091	f3 0f 11 45 d0	 movss	 DWORD PTR _t$[ebp+32], xmm0
  00096	0f 57 c0	 xorps	 xmm0, xmm0
  00099	f3 0f 11 45 d4	 movss	 DWORD PTR _t$[ebp+36], xmm0
  0009e	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  000a6	f3 0f 11 45 d8	 movss	 DWORD PTR _t$[ebp+40], xmm0
  000ab	0f 57 c0	 xorps	 xmm0, xmm0
  000ae	f3 0f 11 45 dc	 movss	 DWORD PTR _t$[ebp+44], xmm0
  000b3	0f 57 c0	 xorps	 xmm0, xmm0
  000b6	f3 0f 11 45 e0	 movss	 DWORD PTR _t$[ebp+48], xmm0
  000bb	0f 57 c0	 xorps	 xmm0, xmm0
  000be	f3 0f 11 45 e4	 movss	 DWORD PTR _t$[ebp+52], xmm0
  000c3	0f 57 c0	 xorps	 xmm0, xmm0
  000c6	f3 0f 11 45 e8	 movss	 DWORD PTR _t$[ebp+56], xmm0
  000cb	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  000d3	f3 0f 11 45 ec	 movss	 DWORD PTR _t$[ebp+60], xmm0

; 244  :   float c, s;
; 245  : 
; 246  :   c = cosf(angle);

  000d8	51		 push	 ecx
  000d9	f3 0f 10 43 0c	 movss	 xmm0, DWORD PTR _angle$[ebx]
  000de	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000e3	e8 00 00 00 00	 call	 _cosf
  000e8	83 c4 04	 add	 esp, 4
  000eb	d9 5d a4	 fstp	 DWORD PTR _c$[ebp]

; 247  :   s = sinf(angle);

  000ee	51		 push	 ecx
  000ef	f3 0f 10 43 0c	 movss	 xmm0, DWORD PTR _angle$[ebx]
  000f4	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000f9	e8 00 00 00 00	 call	 _sinf
  000fe	83 c4 04	 add	 esp, 4
  00101	d9 5d 98	 fstp	 DWORD PTR _s$[ebp]

; 248  : 
; 249  :   t[1][1] =  c;

  00104	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  00109	c1 e0 00	 shl	 eax, 0
  0010c	8d 4c 05 b0	 lea	 ecx, DWORD PTR _t$[ebp+eax]
  00110	ba 04 00 00 00	 mov	 edx, 4
  00115	c1 e2 00	 shl	 edx, 0
  00118	f3 0f 10 45 a4	 movss	 xmm0, DWORD PTR _c$[ebp]
  0011d	f3 0f 11 04 11	 movss	 DWORD PTR [ecx+edx], xmm0

; 250  :   t[1][2] =  s;

  00122	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  00127	c1 e0 00	 shl	 eax, 0
  0012a	8d 4c 05 b0	 lea	 ecx, DWORD PTR _t$[ebp+eax]
  0012e	ba 04 00 00 00	 mov	 edx, 4
  00133	d1 e2		 shl	 edx, 1
  00135	f3 0f 10 45 98	 movss	 xmm0, DWORD PTR _s$[ebp]
  0013a	f3 0f 11 04 11	 movss	 DWORD PTR [ecx+edx], xmm0

; 251  :   t[2][1] = -s;

  0013f	f3 0f 10 45 98	 movss	 xmm0, DWORD PTR _s$[ebp]
  00144	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
  0014b	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  00150	d1 e0		 shl	 eax, 1
  00152	8d 4c 05 b0	 lea	 ecx, DWORD PTR _t$[ebp+eax]
  00156	ba 04 00 00 00	 mov	 edx, 4
  0015b	c1 e2 00	 shl	 edx, 0
  0015e	f3 0f 11 04 11	 movss	 DWORD PTR [ecx+edx], xmm0

; 252  :   t[2][2] =  c;

  00163	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  00168	d1 e0		 shl	 eax, 1
  0016a	8d 4c 05 b0	 lea	 ecx, DWORD PTR _t$[ebp+eax]
  0016e	ba 04 00 00 00	 mov	 edx, 4
  00173	d1 e2		 shl	 edx, 1
  00175	f3 0f 10 45 a4	 movss	 xmm0, DWORD PTR _c$[ebp]
  0017a	f3 0f 11 04 11	 movss	 DWORD PTR [ecx+edx], xmm0

; 253  : 
; 254  :   glm_mul_rot(m, t, dest);

  0017f	8b 43 10	 mov	 eax, DWORD PTR _dest$[ebx]
  00182	50		 push	 eax
  00183	8d 4d b0	 lea	 ecx, DWORD PTR _t$[ebp]
  00186	51		 push	 ecx
  00187	8b 53 08	 mov	 edx, DWORD PTR _m$[ebx]
  0018a	52		 push	 edx
  0018b	e8 00 00 00 00	 call	 _glm_mul_rot
  00190	83 c4 0c	 add	 esp, 12			; 0000000cH

; 255  : }

  00193	52		 push	 edx
  00194	8b cd		 mov	 ecx, ebp
  00196	50		 push	 eax
  00197	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN5@glm_rotate
  0019d	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  001a2	58		 pop	 eax
  001a3	5a		 pop	 edx
  001a4	5f		 pop	 edi
  001a5	5e		 pop	 esi
  001a6	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001a9	33 cd		 xor	 ecx, ebp
  001ab	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001b0	8b e5		 mov	 esp, ebp
  001b2	5d		 pop	 ebp
  001b3	8b e3		 mov	 esp, ebx
  001b5	5b		 pop	 ebx
  001b6	c3		 ret	 0
  001b7	90		 npad	 1
$LN5@glm_rotate:
  001b8	01 00 00 00	 DD	 1
  001bc	00 00 00 00	 DD	 $LN4@glm_rotate
$LN4@glm_rotate:
  001c0	b0 ff ff ff	 DD	 -80			; ffffffb0H
  001c4	40 00 00 00	 DD	 64			; 00000040H
  001c8	00 00 00 00	 DD	 $LN3@glm_rotate
$LN3@glm_rotate:
  001cc	74		 DB	 116			; 00000074H
  001cd	00		 DB	 0
_glm_rotate_x ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Light\source\repos\Spacemonster\Spacemonster-code\include\affine.h
;	COMDAT _glm_scale_uni
_TEXT	SEGMENT
_v$ = -24						; size = 12
__$ArrayPad$ = -4					; size = 4
_m$ = 8							; size = 4
_s$ = 12						; size = 4
_glm_scale_uni PROC					; COMDAT

; 227  : glm_scale_uni(mat4 m, float s) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 f8	 and	 esp, -8			; fffffff8H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec e0 00 00
	00		 sub	 esp, 224		; 000000e0H
  0001c	56		 push	 esi
  0001d	57		 push	 edi
  0001e	8d bd 20 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-224]
  00024	b9 38 00 00 00	 mov	 ecx, 56			; 00000038H
  00029	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002e	f3 ab		 rep stosd
  00030	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00035	33 c5		 xor	 eax, ebp
  00037	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0003a	b9 00 00 00 00	 mov	 ecx, OFFSET __40ECD150_affine@h
  0003f	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 228  :   CGLM_ALIGN(8) vec3 v = { s, s, s };

  00044	f3 0f 10 43 0c	 movss	 xmm0, DWORD PTR _s$[ebx]
  00049	f3 0f 11 45 e8	 movss	 DWORD PTR _v$[ebp], xmm0
  0004e	f3 0f 10 43 0c	 movss	 xmm0, DWORD PTR _s$[ebx]
  00053	f3 0f 11 45 ec	 movss	 DWORD PTR _v$[ebp+4], xmm0
  00058	f3 0f 10 43 0c	 movss	 xmm0, DWORD PTR _s$[ebx]
  0005d	f3 0f 11 45 f0	 movss	 DWORD PTR _v$[ebp+8], xmm0

; 229  :   glm_scale_to(m, v, m);

  00062	8b 43 08	 mov	 eax, DWORD PTR _m$[ebx]
  00065	50		 push	 eax
  00066	8d 4d e8	 lea	 ecx, DWORD PTR _v$[ebp]
  00069	51		 push	 ecx
  0006a	8b 53 08	 mov	 edx, DWORD PTR _m$[ebx]
  0006d	52		 push	 edx
  0006e	e8 00 00 00 00	 call	 _glm_scale_to
  00073	83 c4 0c	 add	 esp, 12			; 0000000cH

; 230  : }

  00076	52		 push	 edx
  00077	8b cd		 mov	 ecx, ebp
  00079	50		 push	 eax
  0007a	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN5@glm_scale_
  00080	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00085	58		 pop	 eax
  00086	5a		 pop	 edx
  00087	5f		 pop	 edi
  00088	5e		 pop	 esi
  00089	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0008c	33 cd		 xor	 ecx, ebp
  0008e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00093	8b e5		 mov	 esp, ebp
  00095	5d		 pop	 ebp
  00096	8b e3		 mov	 esp, ebx
  00098	5b		 pop	 ebx
  00099	c3		 ret	 0
  0009a	66 90		 npad	 2
$LN5@glm_scale_:
  0009c	01 00 00 00	 DD	 1
  000a0	00 00 00 00	 DD	 $LN4@glm_scale_
$LN4@glm_scale_:
  000a4	e8 ff ff ff	 DD	 -24			; ffffffe8H
  000a8	0c 00 00 00	 DD	 12			; 0000000cH
  000ac	00 00 00 00	 DD	 $LN3@glm_scale_
$LN3@glm_scale_:
  000b0	76		 DB	 118			; 00000076H
  000b1	00		 DB	 0
_glm_scale_uni ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Light\source\repos\Spacemonster\Spacemonster-code\include\affine.h
;	COMDAT _glm_scale
_TEXT	SEGMENT
_m$ = 8							; size = 4
_v$ = 12						; size = 4
_glm_scale PROC						; COMDAT

; 214  : glm_scale(mat4 m, vec3 v) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __40ECD150_affine@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 215  :   glm_scale_to(m, v, m);

  00028	8b 45 08	 mov	 eax, DWORD PTR _m$[ebp]
  0002b	50		 push	 eax
  0002c	8b 4d 0c	 mov	 ecx, DWORD PTR _v$[ebp]
  0002f	51		 push	 ecx
  00030	8b 55 08	 mov	 edx, DWORD PTR _m$[ebp]
  00033	52		 push	 edx
  00034	e8 00 00 00 00	 call	 _glm_scale_to
  00039	83 c4 0c	 add	 esp, 12			; 0000000cH

; 216  : }

  0003c	5f		 pop	 edi
  0003d	5e		 pop	 esi
  0003e	5b		 pop	 ebx
  0003f	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00045	3b ec		 cmp	 ebp, esp
  00047	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004c	8b e5		 mov	 esp, ebp
  0004e	5d		 pop	 ebp
  0004f	c3		 ret	 0
_glm_scale ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Light\source\repos\Spacemonster\Spacemonster-code\include\affine.h
;	COMDAT _glm_scale_make
_TEXT	SEGMENT
_m$ = 8							; size = 4
_v$ = 12						; size = 4
_glm_scale_make PROC					; COMDAT

; 198  : glm_scale_make(mat4 m, vec3 v) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __40ECD150_affine@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 199  :   glm_mat4_identity(m);

  00028	8b 45 08	 mov	 eax, DWORD PTR _m$[ebp]
  0002b	50		 push	 eax
  0002c	e8 00 00 00 00	 call	 _glm_mat4_identity
  00031	83 c4 04	 add	 esp, 4

; 200  :   m[0][0] = v[0];

  00034	b8 04 00 00 00	 mov	 eax, 4
  00039	6b c8 00	 imul	 ecx, eax, 0
  0003c	ba 10 00 00 00	 mov	 edx, 16			; 00000010H
  00041	6b c2 00	 imul	 eax, edx, 0
  00044	03 45 08	 add	 eax, DWORD PTR _m$[ebp]
  00047	ba 04 00 00 00	 mov	 edx, 4
  0004c	6b d2 00	 imul	 edx, edx, 0
  0004f	8b 75 0c	 mov	 esi, DWORD PTR _v$[ebp]
  00052	8b 0c 0e	 mov	 ecx, DWORD PTR [esi+ecx]
  00055	89 0c 10	 mov	 DWORD PTR [eax+edx], ecx

; 201  :   m[1][1] = v[1];

  00058	b8 04 00 00 00	 mov	 eax, 4
  0005d	c1 e0 00	 shl	 eax, 0
  00060	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  00065	c1 e1 00	 shl	 ecx, 0
  00068	03 4d 08	 add	 ecx, DWORD PTR _m$[ebp]
  0006b	ba 04 00 00 00	 mov	 edx, 4
  00070	c1 e2 00	 shl	 edx, 0
  00073	8b 75 0c	 mov	 esi, DWORD PTR _v$[ebp]
  00076	8b 04 06	 mov	 eax, DWORD PTR [esi+eax]
  00079	89 04 11	 mov	 DWORD PTR [ecx+edx], eax

; 202  :   m[2][2] = v[2];

  0007c	b8 04 00 00 00	 mov	 eax, 4
  00081	d1 e0		 shl	 eax, 1
  00083	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  00088	d1 e1		 shl	 ecx, 1
  0008a	03 4d 08	 add	 ecx, DWORD PTR _m$[ebp]
  0008d	ba 04 00 00 00	 mov	 edx, 4
  00092	d1 e2		 shl	 edx, 1
  00094	8b 75 0c	 mov	 esi, DWORD PTR _v$[ebp]
  00097	8b 04 06	 mov	 eax, DWORD PTR [esi+eax]
  0009a	89 04 11	 mov	 DWORD PTR [ecx+edx], eax

; 203  : }

  0009d	5f		 pop	 edi
  0009e	5e		 pop	 esi
  0009f	5b		 pop	 ebx
  000a0	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  000a6	3b ec		 cmp	 ebp, esp
  000a8	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000ad	8b e5		 mov	 esp, ebp
  000af	5d		 pop	 ebp
  000b0	c3		 ret	 0
_glm_scale_make ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Light\source\repos\Spacemonster\Spacemonster-code\include\affine.h
;	COMDAT _glm_scale_to
_TEXT	SEGMENT
_m$ = 8							; size = 4
_v$ = 12						; size = 4
_dest$ = 16						; size = 4
_glm_scale_to PROC					; COMDAT

; 182  : glm_scale_to(mat4 m, vec3 v, mat4 dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __40ECD150_affine@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 183  :   glm_vec4_scale(m[0], v[0], dest[0]);

  00028	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  0002d	6b c8 00	 imul	 ecx, eax, 0
  00030	03 4d 10	 add	 ecx, DWORD PTR _dest$[ebp]
  00033	51		 push	 ecx
  00034	ba 04 00 00 00	 mov	 edx, 4
  00039	6b c2 00	 imul	 eax, edx, 0
  0003c	8b 4d 0c	 mov	 ecx, DWORD PTR _v$[ebp]
  0003f	51		 push	 ecx
  00040	f3 0f 10 04 01	 movss	 xmm0, DWORD PTR [ecx+eax]
  00045	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0004a	ba 10 00 00 00	 mov	 edx, 16			; 00000010H
  0004f	6b c2 00	 imul	 eax, edx, 0
  00052	03 45 08	 add	 eax, DWORD PTR _m$[ebp]
  00055	50		 push	 eax
  00056	e8 00 00 00 00	 call	 _glm_vec4_scale
  0005b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 184  :   glm_vec4_scale(m[1], v[1], dest[1]);

  0005e	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  00063	c1 e0 00	 shl	 eax, 0
  00066	03 45 10	 add	 eax, DWORD PTR _dest$[ebp]
  00069	50		 push	 eax
  0006a	b9 04 00 00 00	 mov	 ecx, 4
  0006f	c1 e1 00	 shl	 ecx, 0
  00072	8b 55 0c	 mov	 edx, DWORD PTR _v$[ebp]
  00075	51		 push	 ecx
  00076	f3 0f 10 04 0a	 movss	 xmm0, DWORD PTR [edx+ecx]
  0007b	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00080	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  00085	c1 e0 00	 shl	 eax, 0
  00088	03 45 08	 add	 eax, DWORD PTR _m$[ebp]
  0008b	50		 push	 eax
  0008c	e8 00 00 00 00	 call	 _glm_vec4_scale
  00091	83 c4 0c	 add	 esp, 12			; 0000000cH

; 185  :   glm_vec4_scale(m[2], v[2], dest[2]);

  00094	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  00099	d1 e0		 shl	 eax, 1
  0009b	03 45 10	 add	 eax, DWORD PTR _dest$[ebp]
  0009e	50		 push	 eax
  0009f	b9 04 00 00 00	 mov	 ecx, 4
  000a4	d1 e1		 shl	 ecx, 1
  000a6	8b 55 0c	 mov	 edx, DWORD PTR _v$[ebp]
  000a9	51		 push	 ecx
  000aa	f3 0f 10 04 0a	 movss	 xmm0, DWORD PTR [edx+ecx]
  000af	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000b4	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  000b9	d1 e0		 shl	 eax, 1
  000bb	03 45 08	 add	 eax, DWORD PTR _m$[ebp]
  000be	50		 push	 eax
  000bf	e8 00 00 00 00	 call	 _glm_vec4_scale
  000c4	83 c4 0c	 add	 esp, 12			; 0000000cH

; 186  : 
; 187  :   glm_vec4_copy(m[3], dest[3]);

  000c7	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  000cc	6b c8 03	 imul	 ecx, eax, 3
  000cf	03 4d 10	 add	 ecx, DWORD PTR _dest$[ebp]
  000d2	51		 push	 ecx
  000d3	ba 10 00 00 00	 mov	 edx, 16			; 00000010H
  000d8	6b c2 03	 imul	 eax, edx, 3
  000db	03 45 08	 add	 eax, DWORD PTR _m$[ebp]
  000de	50		 push	 eax
  000df	e8 00 00 00 00	 call	 _glm_vec4_copy
  000e4	83 c4 08	 add	 esp, 8

; 188  : }

  000e7	5f		 pop	 edi
  000e8	5e		 pop	 esi
  000e9	5b		 pop	 ebx
  000ea	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  000f0	3b ec		 cmp	 ebp, esp
  000f2	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000f7	8b e5		 mov	 esp, ebp
  000f9	5d		 pop	 ebp
  000fa	c3		 ret	 0
_glm_scale_to ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Light\source\repos\Spacemonster\Spacemonster-code\include\affine.h
;	COMDAT _glm_translate_make
_TEXT	SEGMENT
_m$ = 8							; size = 4
_v$ = 12						; size = 4
_glm_translate_make PROC				; COMDAT

; 167  : glm_translate_make(mat4 m, vec3 v) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __40ECD150_affine@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 168  :   glm_mat4_identity(m);

  00028	8b 45 08	 mov	 eax, DWORD PTR _m$[ebp]
  0002b	50		 push	 eax
  0002c	e8 00 00 00 00	 call	 _glm_mat4_identity
  00031	83 c4 04	 add	 esp, 4

; 169  :   glm_vec3_copy(v, m[3]);

  00034	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  00039	6b c8 03	 imul	 ecx, eax, 3
  0003c	03 4d 08	 add	 ecx, DWORD PTR _m$[ebp]
  0003f	51		 push	 ecx
  00040	8b 55 0c	 mov	 edx, DWORD PTR _v$[ebp]
  00043	52		 push	 edx
  00044	e8 00 00 00 00	 call	 _glm_vec3_copy
  00049	83 c4 08	 add	 esp, 8

; 170  : }

  0004c	5f		 pop	 edi
  0004d	5e		 pop	 esi
  0004e	5b		 pop	 ebx
  0004f	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00055	3b ec		 cmp	 ebp, esp
  00057	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005c	8b e5		 mov	 esp, ebp
  0005e	5d		 pop	 ebp
  0005f	c3		 ret	 0
_glm_translate_make ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Light\source\repos\Spacemonster\Spacemonster-code\include\affine.h
;	COMDAT _glm_translate_z
_TEXT	SEGMENT
_m$ = 8							; size = 4
_z$ = 12						; size = 4
_glm_translate_z PROC					; COMDAT

; 145  : glm_translate_z(mat4 m, float z) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __40ECD150_affine@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 146  : #if defined( __SSE__ ) || defined( __SSE2__ )
; 147  :   glmm_store(m[3],

  00028	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  0002d	6b c8 03	 imul	 ecx, eax, 3
  00030	03 4d 08	 add	 ecx, DWORD PTR _m$[ebp]
  00033	0f 10 01	 movups	 xmm0, XMMWORD PTR [ecx]
  00036	f3 0f 10 4d 0c	 movss	 xmm1, DWORD PTR _z$[ebp]
  0003b	0f c6 c9 00	 shufps	 xmm1, xmm1, 0
  0003f	ba 10 00 00 00	 mov	 edx, 16			; 00000010H
  00044	d1 e2		 shl	 edx, 1
  00046	03 55 08	 add	 edx, DWORD PTR _m$[ebp]
  00049	0f 10 12	 movups	 xmm2, XMMWORD PTR [edx]
  0004c	0f 59 d1	 mulps	 xmm2, xmm1
  0004f	0f 58 d0	 addps	 xmm2, xmm0
  00052	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  00057	6b c8 03	 imul	 ecx, eax, 3
  0005a	03 4d 08	 add	 ecx, DWORD PTR _m$[ebp]
  0005d	0f 11 11	 movups	 XMMWORD PTR [ecx], xmm2

; 148  :              _mm_add_ps(_mm_mul_ps(glmm_load(m[2]),
; 149  :                                    _mm_set1_ps(z)),
; 150  :                         glmm_load(m[3])))
; 151  :   ;
; 152  : #else
; 153  :   vec4 v1;
; 154  :   glm_vec4_scale(m[2], z, v1);
; 155  :   glm_vec4_add(v1, m[3], m[3]);
; 156  : #endif
; 157  : }

  00060	5f		 pop	 edi
  00061	5e		 pop	 esi
  00062	5b		 pop	 ebx
  00063	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00069	3b ec		 cmp	 ebp, esp
  0006b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00070	8b e5		 mov	 esp, ebp
  00072	5d		 pop	 ebp
  00073	c3		 ret	 0
_glm_translate_z ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Light\source\repos\Spacemonster\Spacemonster-code\include\affine.h
;	COMDAT _glm_translate_y
_TEXT	SEGMENT
_m$ = 8							; size = 4
_y$ = 12						; size = 4
_glm_translate_y PROC					; COMDAT

; 123  : glm_translate_y(mat4 m, float y) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __40ECD150_affine@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 124  : #if defined( __SSE__ ) || defined( __SSE2__ )
; 125  :   glmm_store(m[3],

  00028	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  0002d	6b c8 03	 imul	 ecx, eax, 3
  00030	03 4d 08	 add	 ecx, DWORD PTR _m$[ebp]
  00033	0f 10 01	 movups	 xmm0, XMMWORD PTR [ecx]
  00036	f3 0f 10 4d 0c	 movss	 xmm1, DWORD PTR _y$[ebp]
  0003b	0f c6 c9 00	 shufps	 xmm1, xmm1, 0
  0003f	ba 10 00 00 00	 mov	 edx, 16			; 00000010H
  00044	c1 e2 00	 shl	 edx, 0
  00047	03 55 08	 add	 edx, DWORD PTR _m$[ebp]
  0004a	0f 10 12	 movups	 xmm2, XMMWORD PTR [edx]
  0004d	0f 59 d1	 mulps	 xmm2, xmm1
  00050	0f 58 d0	 addps	 xmm2, xmm0
  00053	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  00058	6b c8 03	 imul	 ecx, eax, 3
  0005b	03 4d 08	 add	 ecx, DWORD PTR _m$[ebp]
  0005e	0f 11 11	 movups	 XMMWORD PTR [ecx], xmm2

; 126  :              _mm_add_ps(_mm_mul_ps(glmm_load(m[1]),
; 127  :                                    _mm_set1_ps(y)),
; 128  :                         glmm_load(m[3])))
; 129  :   ;
; 130  : #else
; 131  :   vec4 v1;
; 132  :   glm_vec4_scale(m[1], y, v1);
; 133  :   glm_vec4_add(v1, m[3], m[3]);
; 134  : #endif
; 135  : }

  00061	5f		 pop	 edi
  00062	5e		 pop	 esi
  00063	5b		 pop	 ebx
  00064	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0006a	3b ec		 cmp	 ebp, esp
  0006c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00071	8b e5		 mov	 esp, ebp
  00073	5d		 pop	 ebp
  00074	c3		 ret	 0
_glm_translate_y ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Light\source\repos\Spacemonster\Spacemonster-code\include\affine.h
;	COMDAT _glm_translate_x
_TEXT	SEGMENT
_m$ = 8							; size = 4
_x$ = 12						; size = 4
_glm_translate_x PROC					; COMDAT

; 101  : glm_translate_x(mat4 m, float x) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __40ECD150_affine@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 102  : #if defined( __SSE__ ) || defined( __SSE2__ )
; 103  :   glmm_store(m[3],

  00028	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  0002d	6b c8 03	 imul	 ecx, eax, 3
  00030	03 4d 08	 add	 ecx, DWORD PTR _m$[ebp]
  00033	0f 10 01	 movups	 xmm0, XMMWORD PTR [ecx]
  00036	f3 0f 10 4d 0c	 movss	 xmm1, DWORD PTR _x$[ebp]
  0003b	0f c6 c9 00	 shufps	 xmm1, xmm1, 0
  0003f	ba 10 00 00 00	 mov	 edx, 16			; 00000010H
  00044	6b c2 00	 imul	 eax, edx, 0
  00047	03 45 08	 add	 eax, DWORD PTR _m$[ebp]
  0004a	0f 10 10	 movups	 xmm2, XMMWORD PTR [eax]
  0004d	0f 59 d1	 mulps	 xmm2, xmm1
  00050	0f 58 d0	 addps	 xmm2, xmm0
  00053	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  00058	6b d1 03	 imul	 edx, ecx, 3
  0005b	03 55 08	 add	 edx, DWORD PTR _m$[ebp]
  0005e	0f 11 12	 movups	 XMMWORD PTR [edx], xmm2

; 104  :              _mm_add_ps(_mm_mul_ps(glmm_load(m[0]),
; 105  :                                    _mm_set1_ps(x)),
; 106  :                         glmm_load(m[3])))
; 107  :   ;
; 108  : #else
; 109  :   vec4 v1;
; 110  :   glm_vec4_scale(m[0], x, v1);
; 111  :   glm_vec4_add(v1, m[3], m[3]);
; 112  : #endif
; 113  : }

  00061	5f		 pop	 edi
  00062	5e		 pop	 esi
  00063	5b		 pop	 ebx
  00064	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0006a	3b ec		 cmp	 ebp, esp
  0006c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00071	8b e5		 mov	 esp, ebp
  00073	5d		 pop	 ebp
  00074	c3		 ret	 0
_glm_translate_x ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Light\source\repos\Spacemonster\Spacemonster-code\include\affine.h
;	COMDAT _glm_translate_to
_TEXT	SEGMENT
_m$ = 8							; size = 4
_v$ = 12						; size = 4
_dest$ = 16						; size = 4
_glm_translate_to PROC					; COMDAT

; 88   : glm_translate_to(mat4 m, vec3 v, mat4 dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __40ECD150_affine@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 89   :   glm_mat4_copy(m, dest);

  00028	8b 45 10	 mov	 eax, DWORD PTR _dest$[ebp]
  0002b	50		 push	 eax
  0002c	8b 4d 08	 mov	 ecx, DWORD PTR _m$[ebp]
  0002f	51		 push	 ecx
  00030	e8 00 00 00 00	 call	 _glm_mat4_copy
  00035	83 c4 08	 add	 esp, 8

; 90   :   glm_translate(dest, v);

  00038	8b 45 0c	 mov	 eax, DWORD PTR _v$[ebp]
  0003b	50		 push	 eax
  0003c	8b 4d 10	 mov	 ecx, DWORD PTR _dest$[ebp]
  0003f	51		 push	 ecx
  00040	e8 00 00 00 00	 call	 _glm_translate
  00045	83 c4 08	 add	 esp, 8

; 91   : }

  00048	5f		 pop	 edi
  00049	5e		 pop	 esi
  0004a	5b		 pop	 ebx
  0004b	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00051	3b ec		 cmp	 ebp, esp
  00053	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00058	8b e5		 mov	 esp, ebp
  0005a	5d		 pop	 ebp
  0005b	c3		 ret	 0
_glm_translate_to ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Light\source\repos\Spacemonster\Spacemonster-code\include\affine.h
;	COMDAT _glm_translate
_TEXT	SEGMENT
_m$ = 8							; size = 4
_v$ = 12						; size = 4
_glm_translate PROC					; COMDAT

; 52   : glm_translate(mat4 m, vec3 v) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __40ECD150_affine@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 53   : #if defined( __SSE__ ) || defined( __SSE2__ )
; 54   :   glmm_store(m[3],

  00028	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  0002d	6b c8 03	 imul	 ecx, eax, 3
  00030	03 4d 08	 add	 ecx, DWORD PTR _m$[ebp]
  00033	0f 10 01	 movups	 xmm0, XMMWORD PTR [ecx]
  00036	ba 04 00 00 00	 mov	 edx, 4
  0003b	d1 e2		 shl	 edx, 1
  0003d	8b 45 0c	 mov	 eax, DWORD PTR _v$[ebp]
  00040	f3 0f 10 0c 10	 movss	 xmm1, DWORD PTR [eax+edx]
  00045	0f c6 c9 00	 shufps	 xmm1, xmm1, 0
  00049	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  0004e	d1 e1		 shl	 ecx, 1
  00050	03 4d 08	 add	 ecx, DWORD PTR _m$[ebp]
  00053	0f 10 11	 movups	 xmm2, XMMWORD PTR [ecx]
  00056	0f 59 d1	 mulps	 xmm2, xmm1
  00059	0f 58 d0	 addps	 xmm2, xmm0
  0005c	ba 04 00 00 00	 mov	 edx, 4
  00061	c1 e2 00	 shl	 edx, 0
  00064	8b 45 0c	 mov	 eax, DWORD PTR _v$[ebp]
  00067	f3 0f 10 04 10	 movss	 xmm0, DWORD PTR [eax+edx]
  0006c	0f c6 c0 00	 shufps	 xmm0, xmm0, 0
  00070	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  00075	c1 e1 00	 shl	 ecx, 0
  00078	03 4d 08	 add	 ecx, DWORD PTR _m$[ebp]
  0007b	0f 10 09	 movups	 xmm1, XMMWORD PTR [ecx]
  0007e	0f 59 c8	 mulps	 xmm1, xmm0
  00081	ba 04 00 00 00	 mov	 edx, 4
  00086	6b c2 00	 imul	 eax, edx, 0
  00089	8b 4d 0c	 mov	 ecx, DWORD PTR _v$[ebp]
  0008c	f3 0f 10 04 01	 movss	 xmm0, DWORD PTR [ecx+eax]
  00091	0f c6 c0 00	 shufps	 xmm0, xmm0, 0
  00095	ba 10 00 00 00	 mov	 edx, 16			; 00000010H
  0009a	6b c2 00	 imul	 eax, edx, 0
  0009d	03 45 08	 add	 eax, DWORD PTR _m$[ebp]
  000a0	0f 10 18	 movups	 xmm3, XMMWORD PTR [eax]
  000a3	0f 59 d8	 mulps	 xmm3, xmm0
  000a6	0f 58 d9	 addps	 xmm3, xmm1
  000a9	0f 58 da	 addps	 xmm3, xmm2
  000ac	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  000b1	6b d1 03	 imul	 edx, ecx, 3
  000b4	03 55 08	 add	 edx, DWORD PTR _m$[ebp]
  000b7	0f 11 1a	 movups	 XMMWORD PTR [edx], xmm3

; 55   :              _mm_add_ps(_mm_add_ps(_mm_mul_ps(glmm_load(m[0]),
; 56   :                                               _mm_set1_ps(v[0])),
; 57   :                                    _mm_mul_ps(glmm_load(m[1]),
; 58   :                                               _mm_set1_ps(v[1]))),
; 59   :                         _mm_add_ps(_mm_mul_ps(glmm_load(m[2]),
; 60   :                                               _mm_set1_ps(v[2])),
; 61   :                                    glmm_load(m[3]))))
; 62   :   ;
; 63   : #else
; 64   :   vec4 v1, v2, v3;
; 65   : 
; 66   :   glm_vec4_scale(m[0], v[0], v1);
; 67   :   glm_vec4_scale(m[1], v[1], v2);
; 68   :   glm_vec4_scale(m[2], v[2], v3);
; 69   : 
; 70   :   glm_vec4_add(v1, m[3], m[3]);
; 71   :   glm_vec4_add(v2, m[3], m[3]);
; 72   :   glm_vec4_add(v3, m[3], m[3]);
; 73   : #endif
; 74   : }

  000ba	5f		 pop	 edi
  000bb	5e		 pop	 esi
  000bc	5b		 pop	 ebx
  000bd	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  000c3	3b ec		 cmp	 ebp, esp
  000c5	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000ca	8b e5		 mov	 esp, ebp
  000cc	5d		 pop	 ebp
  000cd	c3		 ret	 0
_glm_translate ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Light\source\repos\Spacemonster\Spacemonster-code\include\affine-mat.h
;	COMDAT _glm_inv_tr
_TEXT	SEGMENT
_mat$ = 8						; size = 4
_glm_inv_tr PROC					; COMDAT

; 150  : glm_inv_tr(mat4 mat) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __1529E0A7_affine-mat@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 151  : #if defined( __SSE__ ) || defined( __SSE2__ )
; 152  :   glm_inv_tr_sse2(mat);

  00028	8b 45 08	 mov	 eax, DWORD PTR _mat$[ebp]
  0002b	50		 push	 eax
  0002c	e8 00 00 00 00	 call	 _glm_inv_tr_sse2
  00031	83 c4 04	 add	 esp, 4

; 153  : #else
; 154  :   CGLM_ALIGN_MAT mat3 r;
; 155  :   CGLM_ALIGN(8)  vec3 t;
; 156  : 
; 157  :   /* rotate */
; 158  :   glm_mat4_pick3t(mat, r);
; 159  :   glm_mat4_ins3(r, mat);
; 160  : 
; 161  :   /* translate */
; 162  :   glm_mat3_mulv(r, mat[3], t);
; 163  :   glm_vec3_negate(t);
; 164  :   glm_vec3_copy(t, mat[3]);
; 165  : #endif
; 166  : }

  00034	5f		 pop	 edi
  00035	5e		 pop	 esi
  00036	5b		 pop	 ebx
  00037	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0003d	3b ec		 cmp	 ebp, esp
  0003f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00044	8b e5		 mov	 esp, ebp
  00046	5d		 pop	 ebp
  00047	c3		 ret	 0
_glm_inv_tr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Light\source\repos\Spacemonster\Spacemonster-code\include\affine-mat.h
;	COMDAT _glm_mul_rot
_TEXT	SEGMENT
_m1$ = 8						; size = 4
_m2$ = 12						; size = 4
_dest$ = 16						; size = 4
_glm_mul_rot PROC					; COMDAT

; 103  : glm_mul_rot(mat4 m1, mat4 m2, mat4 dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __1529E0A7_affine-mat@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 104  : #if defined( __SSE__ ) || defined( __SSE2__ )
; 105  :   glm_mul_rot_sse2(m1, m2, dest);

  00028	8b 45 10	 mov	 eax, DWORD PTR _dest$[ebp]
  0002b	50		 push	 eax
  0002c	8b 4d 0c	 mov	 ecx, DWORD PTR _m2$[ebp]
  0002f	51		 push	 ecx
  00030	8b 55 08	 mov	 edx, DWORD PTR _m1$[ebp]
  00033	52		 push	 edx
  00034	e8 00 00 00 00	 call	 _glm_mul_rot_sse2
  00039	83 c4 0c	 add	 esp, 12			; 0000000cH

; 106  : #else
; 107  :   float a00 = m1[0][0], a01 = m1[0][1], a02 = m1[0][2], a03 = m1[0][3],
; 108  :         a10 = m1[1][0], a11 = m1[1][1], a12 = m1[1][2], a13 = m1[1][3],
; 109  :         a20 = m1[2][0], a21 = m1[2][1], a22 = m1[2][2], a23 = m1[2][3],
; 110  :         a30 = m1[3][0], a31 = m1[3][1], a32 = m1[3][2], a33 = m1[3][3],
; 111  : 
; 112  :         b00 = m2[0][0], b01 = m2[0][1], b02 = m2[0][2],
; 113  :         b10 = m2[1][0], b11 = m2[1][1], b12 = m2[1][2],
; 114  :         b20 = m2[2][0], b21 = m2[2][1], b22 = m2[2][2];
; 115  : 
; 116  :   dest[0][0] = a00 * b00 + a10 * b01 + a20 * b02;
; 117  :   dest[0][1] = a01 * b00 + a11 * b01 + a21 * b02;
; 118  :   dest[0][2] = a02 * b00 + a12 * b01 + a22 * b02;
; 119  :   dest[0][3] = a03 * b00 + a13 * b01 + a23 * b02;
; 120  : 
; 121  :   dest[1][0] = a00 * b10 + a10 * b11 + a20 * b12;
; 122  :   dest[1][1] = a01 * b10 + a11 * b11 + a21 * b12;
; 123  :   dest[1][2] = a02 * b10 + a12 * b11 + a22 * b12;
; 124  :   dest[1][3] = a03 * b10 + a13 * b11 + a23 * b12;
; 125  : 
; 126  :   dest[2][0] = a00 * b20 + a10 * b21 + a20 * b22;
; 127  :   dest[2][1] = a01 * b20 + a11 * b21 + a21 * b22;
; 128  :   dest[2][2] = a02 * b20 + a12 * b21 + a22 * b22;
; 129  :   dest[2][3] = a03 * b20 + a13 * b21 + a23 * b22;
; 130  : 
; 131  :   dest[3][0] = a30;
; 132  :   dest[3][1] = a31;
; 133  :   dest[3][2] = a32;
; 134  :   dest[3][3] = a33;
; 135  : #endif
; 136  : }

  0003c	5f		 pop	 edi
  0003d	5e		 pop	 esi
  0003e	5b		 pop	 ebx
  0003f	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00045	3b ec		 cmp	 ebp, esp
  00047	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004c	8b e5		 mov	 esp, ebp
  0004e	5d		 pop	 ebp
  0004f	c3		 ret	 0
_glm_mul_rot ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Light\source\repos\Spacemonster\Spacemonster-code\include\affine-mat.h
;	COMDAT _glm_mul
_TEXT	SEGMENT
_m1$ = 8						; size = 4
_m2$ = 12						; size = 4
_dest$ = 16						; size = 4
_glm_mul PROC						; COMDAT

; 47   : glm_mul(mat4 m1, mat4 m2, mat4 dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __1529E0A7_affine-mat@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 48   : #ifdef __AVX__
; 49   :   glm_mul_avx(m1, m2, dest);
; 50   : #elif defined( __SSE__ ) || defined( __SSE2__ )
; 51   :   glm_mul_sse2(m1, m2, dest);

  00028	8b 45 10	 mov	 eax, DWORD PTR _dest$[ebp]
  0002b	50		 push	 eax
  0002c	8b 4d 0c	 mov	 ecx, DWORD PTR _m2$[ebp]
  0002f	51		 push	 ecx
  00030	8b 55 08	 mov	 edx, DWORD PTR _m1$[ebp]
  00033	52		 push	 edx
  00034	e8 00 00 00 00	 call	 _glm_mul_sse2
  00039	83 c4 0c	 add	 esp, 12			; 0000000cH

; 52   : #else
; 53   :   float a00 = m1[0][0], a01 = m1[0][1], a02 = m1[0][2], a03 = m1[0][3],
; 54   :         a10 = m1[1][0], a11 = m1[1][1], a12 = m1[1][2], a13 = m1[1][3],
; 55   :         a20 = m1[2][0], a21 = m1[2][1], a22 = m1[2][2], a23 = m1[2][3],
; 56   :         a30 = m1[3][0], a31 = m1[3][1], a32 = m1[3][2], a33 = m1[3][3],
; 57   : 
; 58   :         b00 = m2[0][0], b01 = m2[0][1], b02 = m2[0][2],
; 59   :         b10 = m2[1][0], b11 = m2[1][1], b12 = m2[1][2],
; 60   :         b20 = m2[2][0], b21 = m2[2][1], b22 = m2[2][2],
; 61   :         b30 = m2[3][0], b31 = m2[3][1], b32 = m2[3][2], b33 = m2[3][3];
; 62   : 
; 63   :   dest[0][0] = a00 * b00 + a10 * b01 + a20 * b02;
; 64   :   dest[0][1] = a01 * b00 + a11 * b01 + a21 * b02;
; 65   :   dest[0][2] = a02 * b00 + a12 * b01 + a22 * b02;
; 66   :   dest[0][3] = a03 * b00 + a13 * b01 + a23 * b02;
; 67   : 
; 68   :   dest[1][0] = a00 * b10 + a10 * b11 + a20 * b12;
; 69   :   dest[1][1] = a01 * b10 + a11 * b11 + a21 * b12;
; 70   :   dest[1][2] = a02 * b10 + a12 * b11 + a22 * b12;
; 71   :   dest[1][3] = a03 * b10 + a13 * b11 + a23 * b12;
; 72   : 
; 73   :   dest[2][0] = a00 * b20 + a10 * b21 + a20 * b22;
; 74   :   dest[2][1] = a01 * b20 + a11 * b21 + a21 * b22;
; 75   :   dest[2][2] = a02 * b20 + a12 * b21 + a22 * b22;
; 76   :   dest[2][3] = a03 * b20 + a13 * b21 + a23 * b22;
; 77   : 
; 78   :   dest[3][0] = a00 * b30 + a10 * b31 + a20 * b32 + a30 * b33;
; 79   :   dest[3][1] = a01 * b30 + a11 * b31 + a21 * b32 + a31 * b33;
; 80   :   dest[3][2] = a02 * b30 + a12 * b31 + a22 * b32 + a32 * b33;
; 81   :   dest[3][3] = a03 * b30 + a13 * b31 + a23 * b32 + a33 * b33;
; 82   : #endif
; 83   : }

  0003c	5f		 pop	 edi
  0003d	5e		 pop	 esi
  0003e	5b		 pop	 ebx
  0003f	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00045	3b ec		 cmp	 ebp, esp
  00047	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004c	8b e5		 mov	 esp, ebp
  0004e	5d		 pop	 ebp
  0004f	c3		 ret	 0
_glm_mul ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Light\source\repos\Spacemonster\Spacemonster-code\include\simd\sse2\affine.h
;	COMDAT _glm_inv_tr_sse2
_TEXT	SEGMENT
__Tmp0$1 = -320						; size = 16
__Tmp1$2 = -288						; size = 16
__Tmp2$3 = -256						; size = 16
__Tmp3$4 = -224						; size = 16
_x1$ = -192						; size = 16
_x0$ = -160						; size = 16
_r3$ = -128						; size = 16
_r2$ = -96						; size = 16
_r1$ = -64						; size = 16
_r0$ = -32						; size = 16
_mat$ = 8						; size = 4
_glm_inv_tr_sse2 PROC					; COMDAT

; 86   : glm_inv_tr_sse2(mat4 mat) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 f0	 and	 esp, -16		; fffffff0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec 08 02 00
	00		 sub	 esp, 520		; 00000208H
  0001c	56		 push	 esi
  0001d	57		 push	 edi
  0001e	8d bd f8 fd ff
	ff		 lea	 edi, DWORD PTR [ebp-520]
  00024	b9 82 00 00 00	 mov	 ecx, 130		; 00000082H
  00029	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002e	f3 ab		 rep stosd
  00030	b9 00 00 00 00	 mov	 ecx, OFFSET __CD658D3A_affine@h
  00035	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 87   :   __m128 r0, r1, r2, r3, x0, x1;
; 88   : 
; 89   :   r0 = glmm_load(mat[0]);

  0003a	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  0003f	6b c8 00	 imul	 ecx, eax, 0
  00042	03 4b 08	 add	 ecx, DWORD PTR _mat$[ebx]
  00045	0f 10 01	 movups	 xmm0, XMMWORD PTR [ecx]
  00048	0f 29 45 e0	 movaps	 XMMWORD PTR _r0$[ebp], xmm0

; 90   :   r1 = glmm_load(mat[1]);

  0004c	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  00051	c1 e0 00	 shl	 eax, 0
  00054	03 43 08	 add	 eax, DWORD PTR _mat$[ebx]
  00057	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  0005a	0f 29 45 c0	 movaps	 XMMWORD PTR _r1$[ebp], xmm0

; 91   :   r2 = glmm_load(mat[2]);

  0005e	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  00063	d1 e0		 shl	 eax, 1
  00065	03 43 08	 add	 eax, DWORD PTR _mat$[ebx]
  00068	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  0006b	0f 29 45 a0	 movaps	 XMMWORD PTR _r2$[ebp], xmm0

; 92   :   r3 = glmm_load(mat[3]);

  0006f	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  00074	6b c8 03	 imul	 ecx, eax, 3
  00077	03 4b 08	 add	 ecx, DWORD PTR _mat$[ebx]
  0007a	0f 10 01	 movups	 xmm0, XMMWORD PTR [ecx]
  0007d	0f 29 45 80	 movaps	 XMMWORD PTR _r3$[ebp], xmm0

; 93   :   x1 = _mm_set_ps(1.0f, 0.0f, 0.0f, 0.0f);

  00081	0f 28 05 00 00
	00 00		 movaps	 xmm0, XMMWORD PTR __xmm@3f800000000000000000000000000000
  00088	0f 29 85 40 ff
	ff ff		 movaps	 XMMWORD PTR _x1$[ebp], xmm0

; 94   : 
; 95   :   _MM_TRANSPOSE4_PS(r0, r1, r2, x1);

  0008f	0f 28 45 e0	 movaps	 xmm0, XMMWORD PTR _r0$[ebp]
  00093	0f c6 45 c0 44	 shufps	 xmm0, XMMWORD PTR _r1$[ebp], 68 ; 00000044H
  00098	0f 29 85 c0 fe
	ff ff		 movaps	 XMMWORD PTR __Tmp0$1[ebp], xmm0
  0009f	0f 28 45 e0	 movaps	 xmm0, XMMWORD PTR _r0$[ebp]
  000a3	0f c6 45 c0 ee	 shufps	 xmm0, XMMWORD PTR _r1$[ebp], 238 ; 000000eeH
  000a8	0f 29 85 00 ff
	ff ff		 movaps	 XMMWORD PTR __Tmp2$3[ebp], xmm0
  000af	0f 28 45 a0	 movaps	 xmm0, XMMWORD PTR _r2$[ebp]
  000b3	0f c6 85 40 ff
	ff ff 44	 shufps	 xmm0, XMMWORD PTR _x1$[ebp], 68 ; 00000044H
  000bb	0f 29 85 e0 fe
	ff ff		 movaps	 XMMWORD PTR __Tmp1$2[ebp], xmm0
  000c2	0f 28 45 a0	 movaps	 xmm0, XMMWORD PTR _r2$[ebp]
  000c6	0f c6 85 40 ff
	ff ff ee	 shufps	 xmm0, XMMWORD PTR _x1$[ebp], 238 ; 000000eeH
  000ce	0f 29 85 20 ff
	ff ff		 movaps	 XMMWORD PTR __Tmp3$4[ebp], xmm0
  000d5	0f 28 85 c0 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR __Tmp0$1[ebp]
  000dc	0f c6 85 e0 fe
	ff ff 88	 shufps	 xmm0, XMMWORD PTR __Tmp1$2[ebp], 136 ; 00000088H
  000e4	0f 29 45 e0	 movaps	 XMMWORD PTR _r0$[ebp], xmm0
  000e8	0f 28 85 c0 fe
	ff ff		 movaps	 xmm0, XMMWORD PTR __Tmp0$1[ebp]
  000ef	0f c6 85 e0 fe
	ff ff dd	 shufps	 xmm0, XMMWORD PTR __Tmp1$2[ebp], 221 ; 000000ddH
  000f7	0f 29 45 c0	 movaps	 XMMWORD PTR _r1$[ebp], xmm0
  000fb	0f 28 85 00 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR __Tmp2$3[ebp]
  00102	0f c6 85 20 ff
	ff ff 88	 shufps	 xmm0, XMMWORD PTR __Tmp3$4[ebp], 136 ; 00000088H
  0010a	0f 29 45 a0	 movaps	 XMMWORD PTR _r2$[ebp], xmm0
  0010e	0f 28 85 00 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR __Tmp2$3[ebp]
  00115	0f c6 85 20 ff
	ff ff dd	 shufps	 xmm0, XMMWORD PTR __Tmp3$4[ebp], 221 ; 000000ddH
  0011d	0f 29 85 40 ff
	ff ff		 movaps	 XMMWORD PTR _x1$[ebp], xmm0

; 96   : 
; 97   :   x0 = _mm_add_ps(_mm_mul_ps(r0, glmm_shuff1(r3, 0, 0, 0, 0)),

  00124	0f 28 45 80	 movaps	 xmm0, XMMWORD PTR _r3$[ebp]
  00128	0f c6 45 80 55	 shufps	 xmm0, XMMWORD PTR _r3$[ebp], 85 ; 00000055H
  0012d	0f 28 4d c0	 movaps	 xmm1, XMMWORD PTR _r1$[ebp]
  00131	0f 59 c8	 mulps	 xmm1, xmm0
  00134	0f 28 45 80	 movaps	 xmm0, XMMWORD PTR _r3$[ebp]
  00138	0f c6 45 80 00	 shufps	 xmm0, XMMWORD PTR _r3$[ebp], 0
  0013d	0f 28 55 e0	 movaps	 xmm2, XMMWORD PTR _r0$[ebp]
  00141	0f 59 d0	 mulps	 xmm2, xmm0
  00144	0f 58 d1	 addps	 xmm2, xmm1
  00147	0f 29 95 60 ff
	ff ff		 movaps	 XMMWORD PTR _x0$[ebp], xmm2

; 98   :                   _mm_mul_ps(r1, glmm_shuff1(r3, 1, 1, 1, 1)));
; 99   :   x0 = _mm_add_ps(x0, _mm_mul_ps(r2, glmm_shuff1(r3, 2, 2, 2, 2)));

  0014e	0f 28 45 80	 movaps	 xmm0, XMMWORD PTR _r3$[ebp]
  00152	0f c6 45 80 aa	 shufps	 xmm0, XMMWORD PTR _r3$[ebp], 170 ; 000000aaH
  00157	0f 28 4d a0	 movaps	 xmm1, XMMWORD PTR _r2$[ebp]
  0015b	0f 59 c8	 mulps	 xmm1, xmm0
  0015e	0f 28 85 60 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR _x0$[ebp]
  00165	0f 58 c1	 addps	 xmm0, xmm1
  00168	0f 29 85 60 ff
	ff ff		 movaps	 XMMWORD PTR _x0$[ebp], xmm0

; 100  :   x0 = _mm_xor_ps(x0, _mm_set1_ps(-0.f));

  0016f	0f 28 85 60 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR _x0$[ebp]
  00176	0f 57 05 00 00
	00 00		 xorps	 xmm0, XMMWORD PTR __xmm@80000000800000008000000080000000
  0017d	0f 29 85 60 ff
	ff ff		 movaps	 XMMWORD PTR _x0$[ebp], xmm0

; 101  : 
; 102  :   x0 = _mm_add_ps(x0, x1);

  00184	0f 28 85 60 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR _x0$[ebp]
  0018b	0f 58 85 40 ff
	ff ff		 addps	 xmm0, XMMWORD PTR _x1$[ebp]
  00192	0f 29 85 60 ff
	ff ff		 movaps	 XMMWORD PTR _x0$[ebp], xmm0

; 103  : 
; 104  :   glmm_store(mat[0], r0);

  00199	0f 28 45 e0	 movaps	 xmm0, XMMWORD PTR _r0$[ebp]
  0019d	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  001a2	6b c8 00	 imul	 ecx, eax, 0
  001a5	03 4b 08	 add	 ecx, DWORD PTR _mat$[ebx]
  001a8	0f 11 01	 movups	 XMMWORD PTR [ecx], xmm0

; 105  :   glmm_store(mat[1], r1);

  001ab	0f 28 45 c0	 movaps	 xmm0, XMMWORD PTR _r1$[ebp]
  001af	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  001b4	c1 e0 00	 shl	 eax, 0
  001b7	03 43 08	 add	 eax, DWORD PTR _mat$[ebx]
  001ba	0f 11 00	 movups	 XMMWORD PTR [eax], xmm0

; 106  :   glmm_store(mat[2], r2);

  001bd	0f 28 45 a0	 movaps	 xmm0, XMMWORD PTR _r2$[ebp]
  001c1	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  001c6	d1 e0		 shl	 eax, 1
  001c8	03 43 08	 add	 eax, DWORD PTR _mat$[ebx]
  001cb	0f 11 00	 movups	 XMMWORD PTR [eax], xmm0

; 107  :   glmm_store(mat[3], x0);

  001ce	0f 28 85 60 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR _x0$[ebp]
  001d5	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  001da	6b c8 03	 imul	 ecx, eax, 3
  001dd	03 4b 08	 add	 ecx, DWORD PTR _mat$[ebx]
  001e0	0f 11 01	 movups	 XMMWORD PTR [ecx], xmm0

; 108  : }

  001e3	5f		 pop	 edi
  001e4	5e		 pop	 esi
  001e5	8b e5		 mov	 esp, ebp
  001e7	5d		 pop	 ebp
  001e8	8b e3		 mov	 esp, ebx
  001ea	5b		 pop	 ebx
  001eb	c3		 ret	 0
_glm_inv_tr_sse2 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Light\source\repos\Spacemonster\Spacemonster-code\include\simd\sse2\affine.h
;	COMDAT _glm_mul_rot_sse2
_TEXT	SEGMENT
_r$ = -160						; size = 16
_l3$ = -128						; size = 16
_l2$ = -96						; size = 16
_l1$ = -64						; size = 16
_l0$ = -32						; size = 16
_m1$ = 8						; size = 4
_m2$ = 12						; size = 4
_dest$ = 16						; size = 4
_glm_mul_rot_sse2 PROC					; COMDAT

; 54   : glm_mul_rot_sse2(mat4 m1, mat4 m2, mat4 dest) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 f0	 and	 esp, -16		; fffffff0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec 68 01 00
	00		 sub	 esp, 360		; 00000168H
  0001c	56		 push	 esi
  0001d	57		 push	 edi
  0001e	8d bd 98 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-360]
  00024	b9 5a 00 00 00	 mov	 ecx, 90			; 0000005aH
  00029	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002e	f3 ab		 rep stosd
  00030	b9 00 00 00 00	 mov	 ecx, OFFSET __CD658D3A_affine@h
  00035	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 55   :   /* D = R * L (Column-Major) */
; 56   :   __m128 l0, l1, l2, l3, r;
; 57   : 
; 58   :   l0 = glmm_load(m1[0]);

  0003a	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  0003f	6b c8 00	 imul	 ecx, eax, 0
  00042	03 4b 08	 add	 ecx, DWORD PTR _m1$[ebx]
  00045	0f 10 01	 movups	 xmm0, XMMWORD PTR [ecx]
  00048	0f 29 45 e0	 movaps	 XMMWORD PTR _l0$[ebp], xmm0

; 59   :   l1 = glmm_load(m1[1]);

  0004c	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  00051	c1 e0 00	 shl	 eax, 0
  00054	03 43 08	 add	 eax, DWORD PTR _m1$[ebx]
  00057	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  0005a	0f 29 45 c0	 movaps	 XMMWORD PTR _l1$[ebp], xmm0

; 60   :   l2 = glmm_load(m1[2]);

  0005e	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  00063	d1 e0		 shl	 eax, 1
  00065	03 43 08	 add	 eax, DWORD PTR _m1$[ebx]
  00068	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  0006b	0f 29 45 a0	 movaps	 XMMWORD PTR _l2$[ebp], xmm0

; 61   :   l3 = glmm_load(m1[3]);

  0006f	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  00074	6b c8 03	 imul	 ecx, eax, 3
  00077	03 4b 08	 add	 ecx, DWORD PTR _m1$[ebx]
  0007a	0f 10 01	 movups	 xmm0, XMMWORD PTR [ecx]
  0007d	0f 29 45 80	 movaps	 XMMWORD PTR _l3$[ebp], xmm0

; 62   : 
; 63   :   r = glmm_load(m2[0]);

  00081	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  00086	6b c8 00	 imul	 ecx, eax, 0
  00089	03 4b 0c	 add	 ecx, DWORD PTR _m2$[ebx]
  0008c	0f 10 01	 movups	 xmm0, XMMWORD PTR [ecx]
  0008f	0f 29 85 60 ff
	ff ff		 movaps	 XMMWORD PTR _r$[ebp], xmm0

; 64   :   glmm_store(dest[0],

  00096	0f 28 85 60 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR _r$[ebp]
  0009d	0f c6 85 60 ff
	ff ff aa	 shufps	 xmm0, XMMWORD PTR _r$[ebp], 170 ; 000000aaH
  000a5	0f 59 45 a0	 mulps	 xmm0, XMMWORD PTR _l2$[ebp]
  000a9	0f 28 8d 60 ff
	ff ff		 movaps	 xmm1, XMMWORD PTR _r$[ebp]
  000b0	0f c6 8d 60 ff
	ff ff 55	 shufps	 xmm1, XMMWORD PTR _r$[ebp], 85 ; 00000055H
  000b8	0f 59 4d c0	 mulps	 xmm1, XMMWORD PTR _l1$[ebp]
  000bc	0f 28 95 60 ff
	ff ff		 movaps	 xmm2, XMMWORD PTR _r$[ebp]
  000c3	0f c6 95 60 ff
	ff ff 00	 shufps	 xmm2, XMMWORD PTR _r$[ebp], 0
  000cb	0f 59 55 e0	 mulps	 xmm2, XMMWORD PTR _l0$[ebp]
  000cf	0f 58 d1	 addps	 xmm2, xmm1
  000d2	0f 58 d0	 addps	 xmm2, xmm0
  000d5	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  000da	6b c8 00	 imul	 ecx, eax, 0
  000dd	03 4b 10	 add	 ecx, DWORD PTR _dest$[ebx]
  000e0	0f 11 11	 movups	 XMMWORD PTR [ecx], xmm2

; 65   :              _mm_add_ps(_mm_add_ps(_mm_mul_ps(glmm_shuff1x(r, 0), l0),
; 66   :                                    _mm_mul_ps(glmm_shuff1x(r, 1), l1)),
; 67   :                         _mm_mul_ps(glmm_shuff1x(r, 2), l2)));
; 68   : 
; 69   :   r = glmm_load(m2[1]);

  000e3	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  000e8	c1 e0 00	 shl	 eax, 0
  000eb	03 43 0c	 add	 eax, DWORD PTR _m2$[ebx]
  000ee	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  000f1	0f 29 85 60 ff
	ff ff		 movaps	 XMMWORD PTR _r$[ebp], xmm0

; 70   :   glmm_store(dest[1],

  000f8	0f 28 85 60 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR _r$[ebp]
  000ff	0f c6 85 60 ff
	ff ff aa	 shufps	 xmm0, XMMWORD PTR _r$[ebp], 170 ; 000000aaH
  00107	0f 59 45 a0	 mulps	 xmm0, XMMWORD PTR _l2$[ebp]
  0010b	0f 28 8d 60 ff
	ff ff		 movaps	 xmm1, XMMWORD PTR _r$[ebp]
  00112	0f c6 8d 60 ff
	ff ff 55	 shufps	 xmm1, XMMWORD PTR _r$[ebp], 85 ; 00000055H
  0011a	0f 59 4d c0	 mulps	 xmm1, XMMWORD PTR _l1$[ebp]
  0011e	0f 28 95 60 ff
	ff ff		 movaps	 xmm2, XMMWORD PTR _r$[ebp]
  00125	0f c6 95 60 ff
	ff ff 00	 shufps	 xmm2, XMMWORD PTR _r$[ebp], 0
  0012d	0f 59 55 e0	 mulps	 xmm2, XMMWORD PTR _l0$[ebp]
  00131	0f 58 d1	 addps	 xmm2, xmm1
  00134	0f 58 d0	 addps	 xmm2, xmm0
  00137	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  0013c	c1 e0 00	 shl	 eax, 0
  0013f	03 43 10	 add	 eax, DWORD PTR _dest$[ebx]
  00142	0f 11 10	 movups	 XMMWORD PTR [eax], xmm2

; 71   :              _mm_add_ps(_mm_add_ps(_mm_mul_ps(glmm_shuff1x(r, 0), l0),
; 72   :                                    _mm_mul_ps(glmm_shuff1x(r, 1), l1)),
; 73   :                         _mm_mul_ps(glmm_shuff1x(r, 2), l2)));
; 74   : 
; 75   :   r = glmm_load(m2[2]);

  00145	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  0014a	d1 e0		 shl	 eax, 1
  0014c	03 43 0c	 add	 eax, DWORD PTR _m2$[ebx]
  0014f	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  00152	0f 29 85 60 ff
	ff ff		 movaps	 XMMWORD PTR _r$[ebp], xmm0

; 76   :   glmm_store(dest[2],

  00159	0f 28 85 60 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR _r$[ebp]
  00160	0f c6 85 60 ff
	ff ff aa	 shufps	 xmm0, XMMWORD PTR _r$[ebp], 170 ; 000000aaH
  00168	0f 59 45 a0	 mulps	 xmm0, XMMWORD PTR _l2$[ebp]
  0016c	0f 28 8d 60 ff
	ff ff		 movaps	 xmm1, XMMWORD PTR _r$[ebp]
  00173	0f c6 8d 60 ff
	ff ff 55	 shufps	 xmm1, XMMWORD PTR _r$[ebp], 85 ; 00000055H
  0017b	0f 59 4d c0	 mulps	 xmm1, XMMWORD PTR _l1$[ebp]
  0017f	0f 28 95 60 ff
	ff ff		 movaps	 xmm2, XMMWORD PTR _r$[ebp]
  00186	0f c6 95 60 ff
	ff ff 00	 shufps	 xmm2, XMMWORD PTR _r$[ebp], 0
  0018e	0f 59 55 e0	 mulps	 xmm2, XMMWORD PTR _l0$[ebp]
  00192	0f 58 d1	 addps	 xmm2, xmm1
  00195	0f 58 d0	 addps	 xmm2, xmm0
  00198	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  0019d	d1 e0		 shl	 eax, 1
  0019f	03 43 10	 add	 eax, DWORD PTR _dest$[ebx]
  001a2	0f 11 10	 movups	 XMMWORD PTR [eax], xmm2

; 77   :              _mm_add_ps(_mm_add_ps(_mm_mul_ps(glmm_shuff1x(r, 0), l0),
; 78   :                                    _mm_mul_ps(glmm_shuff1x(r, 1), l1)),
; 79   :                         _mm_mul_ps(glmm_shuff1x(r, 2), l2)));
; 80   : 
; 81   :   glmm_store(dest[3], l3);

  001a5	0f 28 45 80	 movaps	 xmm0, XMMWORD PTR _l3$[ebp]
  001a9	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  001ae	6b c8 03	 imul	 ecx, eax, 3
  001b1	03 4b 10	 add	 ecx, DWORD PTR _dest$[ebx]
  001b4	0f 11 01	 movups	 XMMWORD PTR [ecx], xmm0

; 82   : }

  001b7	5f		 pop	 edi
  001b8	5e		 pop	 esi
  001b9	8b e5		 mov	 esp, ebp
  001bb	5d		 pop	 ebp
  001bc	8b e3		 mov	 esp, ebx
  001be	5b		 pop	 ebx
  001bf	c3		 ret	 0
_glm_mul_rot_sse2 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Light\source\repos\Spacemonster\Spacemonster-code\include\simd\sse2\affine.h
;	COMDAT _glm_mul_sse2
_TEXT	SEGMENT
_r$ = -160						; size = 16
_l3$ = -128						; size = 16
_l2$ = -96						; size = 16
_l1$ = -64						; size = 16
_l0$ = -32						; size = 16
_m1$ = 8						; size = 4
_m2$ = 12						; size = 4
_dest$ = 16						; size = 4
_glm_mul_sse2 PROC					; COMDAT

; 17   : glm_mul_sse2(mat4 m1, mat4 m2, mat4 dest) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 f0	 and	 esp, -16		; fffffff0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec 68 01 00
	00		 sub	 esp, 360		; 00000168H
  0001c	56		 push	 esi
  0001d	57		 push	 edi
  0001e	8d bd 98 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-360]
  00024	b9 5a 00 00 00	 mov	 ecx, 90			; 0000005aH
  00029	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002e	f3 ab		 rep stosd
  00030	b9 00 00 00 00	 mov	 ecx, OFFSET __CD658D3A_affine@h
  00035	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 18   :   /* D = R * L (Column-Major) */
; 19   :   __m128 l0, l1, l2, l3, r;
; 20   : 
; 21   :   l0 = glmm_load(m1[0]);

  0003a	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  0003f	6b c8 00	 imul	 ecx, eax, 0
  00042	03 4b 08	 add	 ecx, DWORD PTR _m1$[ebx]
  00045	0f 10 01	 movups	 xmm0, XMMWORD PTR [ecx]
  00048	0f 29 45 e0	 movaps	 XMMWORD PTR _l0$[ebp], xmm0

; 22   :   l1 = glmm_load(m1[1]);

  0004c	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  00051	c1 e0 00	 shl	 eax, 0
  00054	03 43 08	 add	 eax, DWORD PTR _m1$[ebx]
  00057	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  0005a	0f 29 45 c0	 movaps	 XMMWORD PTR _l1$[ebp], xmm0

; 23   :   l2 = glmm_load(m1[2]);

  0005e	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  00063	d1 e0		 shl	 eax, 1
  00065	03 43 08	 add	 eax, DWORD PTR _m1$[ebx]
  00068	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  0006b	0f 29 45 a0	 movaps	 XMMWORD PTR _l2$[ebp], xmm0

; 24   :   l3 = glmm_load(m1[3]);

  0006f	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  00074	6b c8 03	 imul	 ecx, eax, 3
  00077	03 4b 08	 add	 ecx, DWORD PTR _m1$[ebx]
  0007a	0f 10 01	 movups	 xmm0, XMMWORD PTR [ecx]
  0007d	0f 29 45 80	 movaps	 XMMWORD PTR _l3$[ebp], xmm0

; 25   : 
; 26   :   r = glmm_load(m2[0]);

  00081	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  00086	6b c8 00	 imul	 ecx, eax, 0
  00089	03 4b 0c	 add	 ecx, DWORD PTR _m2$[ebx]
  0008c	0f 10 01	 movups	 xmm0, XMMWORD PTR [ecx]
  0008f	0f 29 85 60 ff
	ff ff		 movaps	 XMMWORD PTR _r$[ebp], xmm0

; 27   :   glmm_store(dest[0],

  00096	0f 28 85 60 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR _r$[ebp]
  0009d	0f c6 85 60 ff
	ff ff aa	 shufps	 xmm0, XMMWORD PTR _r$[ebp], 170 ; 000000aaH
  000a5	0f 59 45 a0	 mulps	 xmm0, XMMWORD PTR _l2$[ebp]
  000a9	0f 28 8d 60 ff
	ff ff		 movaps	 xmm1, XMMWORD PTR _r$[ebp]
  000b0	0f c6 8d 60 ff
	ff ff 55	 shufps	 xmm1, XMMWORD PTR _r$[ebp], 85 ; 00000055H
  000b8	0f 59 4d c0	 mulps	 xmm1, XMMWORD PTR _l1$[ebp]
  000bc	0f 28 95 60 ff
	ff ff		 movaps	 xmm2, XMMWORD PTR _r$[ebp]
  000c3	0f c6 95 60 ff
	ff ff 00	 shufps	 xmm2, XMMWORD PTR _r$[ebp], 0
  000cb	0f 59 55 e0	 mulps	 xmm2, XMMWORD PTR _l0$[ebp]
  000cf	0f 58 d1	 addps	 xmm2, xmm1
  000d2	0f 58 d0	 addps	 xmm2, xmm0
  000d5	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  000da	6b c8 00	 imul	 ecx, eax, 0
  000dd	03 4b 10	 add	 ecx, DWORD PTR _dest$[ebx]
  000e0	0f 11 11	 movups	 XMMWORD PTR [ecx], xmm2

; 28   :              _mm_add_ps(_mm_add_ps(_mm_mul_ps(glmm_shuff1x(r, 0), l0),
; 29   :                                    _mm_mul_ps(glmm_shuff1x(r, 1), l1)),
; 30   :                         _mm_mul_ps(glmm_shuff1x(r, 2), l2)));
; 31   : 
; 32   :   r = glmm_load(m2[1]);

  000e3	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  000e8	c1 e0 00	 shl	 eax, 0
  000eb	03 43 0c	 add	 eax, DWORD PTR _m2$[ebx]
  000ee	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  000f1	0f 29 85 60 ff
	ff ff		 movaps	 XMMWORD PTR _r$[ebp], xmm0

; 33   :   glmm_store(dest[1],

  000f8	0f 28 85 60 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR _r$[ebp]
  000ff	0f c6 85 60 ff
	ff ff aa	 shufps	 xmm0, XMMWORD PTR _r$[ebp], 170 ; 000000aaH
  00107	0f 59 45 a0	 mulps	 xmm0, XMMWORD PTR _l2$[ebp]
  0010b	0f 28 8d 60 ff
	ff ff		 movaps	 xmm1, XMMWORD PTR _r$[ebp]
  00112	0f c6 8d 60 ff
	ff ff 55	 shufps	 xmm1, XMMWORD PTR _r$[ebp], 85 ; 00000055H
  0011a	0f 59 4d c0	 mulps	 xmm1, XMMWORD PTR _l1$[ebp]
  0011e	0f 28 95 60 ff
	ff ff		 movaps	 xmm2, XMMWORD PTR _r$[ebp]
  00125	0f c6 95 60 ff
	ff ff 00	 shufps	 xmm2, XMMWORD PTR _r$[ebp], 0
  0012d	0f 59 55 e0	 mulps	 xmm2, XMMWORD PTR _l0$[ebp]
  00131	0f 58 d1	 addps	 xmm2, xmm1
  00134	0f 58 d0	 addps	 xmm2, xmm0
  00137	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  0013c	c1 e0 00	 shl	 eax, 0
  0013f	03 43 10	 add	 eax, DWORD PTR _dest$[ebx]
  00142	0f 11 10	 movups	 XMMWORD PTR [eax], xmm2

; 34   :              _mm_add_ps(_mm_add_ps(_mm_mul_ps(glmm_shuff1x(r, 0), l0),
; 35   :                                    _mm_mul_ps(glmm_shuff1x(r, 1), l1)),
; 36   :                         _mm_mul_ps(glmm_shuff1x(r, 2), l2)));
; 37   : 
; 38   :   r = glmm_load(m2[2]);

  00145	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  0014a	d1 e0		 shl	 eax, 1
  0014c	03 43 0c	 add	 eax, DWORD PTR _m2$[ebx]
  0014f	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  00152	0f 29 85 60 ff
	ff ff		 movaps	 XMMWORD PTR _r$[ebp], xmm0

; 39   :   glmm_store(dest[2],

  00159	0f 28 85 60 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR _r$[ebp]
  00160	0f c6 85 60 ff
	ff ff aa	 shufps	 xmm0, XMMWORD PTR _r$[ebp], 170 ; 000000aaH
  00168	0f 59 45 a0	 mulps	 xmm0, XMMWORD PTR _l2$[ebp]
  0016c	0f 28 8d 60 ff
	ff ff		 movaps	 xmm1, XMMWORD PTR _r$[ebp]
  00173	0f c6 8d 60 ff
	ff ff 55	 shufps	 xmm1, XMMWORD PTR _r$[ebp], 85 ; 00000055H
  0017b	0f 59 4d c0	 mulps	 xmm1, XMMWORD PTR _l1$[ebp]
  0017f	0f 28 95 60 ff
	ff ff		 movaps	 xmm2, XMMWORD PTR _r$[ebp]
  00186	0f c6 95 60 ff
	ff ff 00	 shufps	 xmm2, XMMWORD PTR _r$[ebp], 0
  0018e	0f 59 55 e0	 mulps	 xmm2, XMMWORD PTR _l0$[ebp]
  00192	0f 58 d1	 addps	 xmm2, xmm1
  00195	0f 58 d0	 addps	 xmm2, xmm0
  00198	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  0019d	d1 e0		 shl	 eax, 1
  0019f	03 43 10	 add	 eax, DWORD PTR _dest$[ebx]
  001a2	0f 11 10	 movups	 XMMWORD PTR [eax], xmm2

; 40   :              _mm_add_ps(_mm_add_ps(_mm_mul_ps(glmm_shuff1x(r, 0), l0),
; 41   :                                    _mm_mul_ps(glmm_shuff1x(r, 1), l1)),
; 42   :                         _mm_mul_ps(glmm_shuff1x(r, 2), l2)));
; 43   : 
; 44   :   r = glmm_load(m2[3]);

  001a5	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  001aa	6b c8 03	 imul	 ecx, eax, 3
  001ad	03 4b 0c	 add	 ecx, DWORD PTR _m2$[ebx]
  001b0	0f 10 01	 movups	 xmm0, XMMWORD PTR [ecx]
  001b3	0f 29 85 60 ff
	ff ff		 movaps	 XMMWORD PTR _r$[ebp], xmm0

; 45   :   glmm_store(dest[3],

  001ba	0f 28 85 60 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR _r$[ebp]
  001c1	0f c6 85 60 ff
	ff ff ff	 shufps	 xmm0, XMMWORD PTR _r$[ebp], 255 ; 000000ffH
  001c9	0f 59 45 80	 mulps	 xmm0, XMMWORD PTR _l3$[ebp]
  001cd	0f 28 8d 60 ff
	ff ff		 movaps	 xmm1, XMMWORD PTR _r$[ebp]
  001d4	0f c6 8d 60 ff
	ff ff aa	 shufps	 xmm1, XMMWORD PTR _r$[ebp], 170 ; 000000aaH
  001dc	0f 59 4d a0	 mulps	 xmm1, XMMWORD PTR _l2$[ebp]
  001e0	0f 58 c8	 addps	 xmm1, xmm0
  001e3	0f 28 85 60 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR _r$[ebp]
  001ea	0f c6 85 60 ff
	ff ff 55	 shufps	 xmm0, XMMWORD PTR _r$[ebp], 85 ; 00000055H
  001f2	0f 59 45 c0	 mulps	 xmm0, XMMWORD PTR _l1$[ebp]
  001f6	0f 28 95 60 ff
	ff ff		 movaps	 xmm2, XMMWORD PTR _r$[ebp]
  001fd	0f c6 95 60 ff
	ff ff 00	 shufps	 xmm2, XMMWORD PTR _r$[ebp], 0
  00205	0f 59 55 e0	 mulps	 xmm2, XMMWORD PTR _l0$[ebp]
  00209	0f 58 d0	 addps	 xmm2, xmm0
  0020c	0f 58 d1	 addps	 xmm2, xmm1
  0020f	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  00214	6b c8 03	 imul	 ecx, eax, 3
  00217	03 4b 10	 add	 ecx, DWORD PTR _dest$[ebx]
  0021a	0f 11 11	 movups	 XMMWORD PTR [ecx], xmm2

; 46   :              _mm_add_ps(_mm_add_ps(_mm_mul_ps(glmm_shuff1x(r, 0), l0),
; 47   :                                    _mm_mul_ps(glmm_shuff1x(r, 1), l1)),
; 48   :                         _mm_add_ps(_mm_mul_ps(glmm_shuff1x(r, 2), l2),
; 49   :                                    _mm_mul_ps(glmm_shuff1x(r, 3), l3))));
; 50   : }

  0021d	5f		 pop	 edi
  0021e	5e		 pop	 esi
  0021f	8b e5		 mov	 esp, ebp
  00221	5d		 pop	 ebp
  00222	8b e3		 mov	 esp, ebx
  00224	5b		 pop	 ebx
  00225	c3		 ret	 0
_glm_mul_sse2 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Light\source\repos\Spacemonster\Spacemonster-code\include\mat4.h
;	COMDAT _glm_mat4_identity
_TEXT	SEGMENT
_t$ = -80						; size = 64
__$ArrayPad$ = -4					; size = 4
_mat$ = 8						; size = 4
_glm_mat4_identity PROC					; COMDAT

; 158  : glm_mat4_identity(mat4 mat) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 f0	 and	 esp, -16		; fffffff0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec 18 01 00
	00		 sub	 esp, 280		; 00000118H
  0001c	56		 push	 esi
  0001d	57		 push	 edi
  0001e	8d bd e8 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-280]
  00024	b9 46 00 00 00	 mov	 ecx, 70			; 00000046H
  00029	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002e	f3 ab		 rep stosd
  00030	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00035	33 c5		 xor	 eax, ebp
  00037	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0003a	b9 00 00 00 00	 mov	 ecx, OFFSET __0C756A67_mat4@h
  0003f	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 159  :   CGLM_ALIGN_MAT mat4 t = GLM_MAT4_IDENTITY_INIT;

  00044	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  0004c	f3 0f 11 45 b0	 movss	 DWORD PTR _t$[ebp], xmm0
  00051	0f 57 c0	 xorps	 xmm0, xmm0
  00054	f3 0f 11 45 b4	 movss	 DWORD PTR _t$[ebp+4], xmm0
  00059	0f 57 c0	 xorps	 xmm0, xmm0
  0005c	f3 0f 11 45 b8	 movss	 DWORD PTR _t$[ebp+8], xmm0
  00061	0f 57 c0	 xorps	 xmm0, xmm0
  00064	f3 0f 11 45 bc	 movss	 DWORD PTR _t$[ebp+12], xmm0
  00069	0f 57 c0	 xorps	 xmm0, xmm0
  0006c	f3 0f 11 45 c0	 movss	 DWORD PTR _t$[ebp+16], xmm0
  00071	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00079	f3 0f 11 45 c4	 movss	 DWORD PTR _t$[ebp+20], xmm0
  0007e	0f 57 c0	 xorps	 xmm0, xmm0
  00081	f3 0f 11 45 c8	 movss	 DWORD PTR _t$[ebp+24], xmm0
  00086	0f 57 c0	 xorps	 xmm0, xmm0
  00089	f3 0f 11 45 cc	 movss	 DWORD PTR _t$[ebp+28], xmm0
  0008e	0f 57 c0	 xorps	 xmm0, xmm0
  00091	f3 0f 11 45 d0	 movss	 DWORD PTR _t$[ebp+32], xmm0
  00096	0f 57 c0	 xorps	 xmm0, xmm0
  00099	f3 0f 11 45 d4	 movss	 DWORD PTR _t$[ebp+36], xmm0
  0009e	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  000a6	f3 0f 11 45 d8	 movss	 DWORD PTR _t$[ebp+40], xmm0
  000ab	0f 57 c0	 xorps	 xmm0, xmm0
  000ae	f3 0f 11 45 dc	 movss	 DWORD PTR _t$[ebp+44], xmm0
  000b3	0f 57 c0	 xorps	 xmm0, xmm0
  000b6	f3 0f 11 45 e0	 movss	 DWORD PTR _t$[ebp+48], xmm0
  000bb	0f 57 c0	 xorps	 xmm0, xmm0
  000be	f3 0f 11 45 e4	 movss	 DWORD PTR _t$[ebp+52], xmm0
  000c3	0f 57 c0	 xorps	 xmm0, xmm0
  000c6	f3 0f 11 45 e8	 movss	 DWORD PTR _t$[ebp+56], xmm0
  000cb	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  000d3	f3 0f 11 45 ec	 movss	 DWORD PTR _t$[ebp+60], xmm0

; 160  :   glm_mat4_copy(t, mat);

  000d8	8b 43 08	 mov	 eax, DWORD PTR _mat$[ebx]
  000db	50		 push	 eax
  000dc	8d 4d b0	 lea	 ecx, DWORD PTR _t$[ebp]
  000df	51		 push	 ecx
  000e0	e8 00 00 00 00	 call	 _glm_mat4_copy
  000e5	83 c4 08	 add	 esp, 8

; 161  : }

  000e8	52		 push	 edx
  000e9	8b cd		 mov	 ecx, ebp
  000eb	50		 push	 eax
  000ec	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN5@glm_mat4_i
  000f2	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  000f7	58		 pop	 eax
  000f8	5a		 pop	 edx
  000f9	5f		 pop	 edi
  000fa	5e		 pop	 esi
  000fb	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000fe	33 cd		 xor	 ecx, ebp
  00100	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00105	8b e5		 mov	 esp, ebp
  00107	5d		 pop	 ebp
  00108	8b e3		 mov	 esp, ebx
  0010a	5b		 pop	 ebx
  0010b	c3		 ret	 0
$LN5@glm_mat4_i:
  0010c	01 00 00 00	 DD	 1
  00110	00 00 00 00	 DD	 $LN4@glm_mat4_i
$LN4@glm_mat4_i:
  00114	b0 ff ff ff	 DD	 -80			; ffffffb0H
  00118	40 00 00 00	 DD	 64			; 00000040H
  0011c	00 00 00 00	 DD	 $LN3@glm_mat4_i
$LN3@glm_mat4_i:
  00120	74		 DB	 116			; 00000074H
  00121	00		 DB	 0
_glm_mat4_identity ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Light\source\repos\Spacemonster\Spacemonster-code\include\mat4.h
;	COMDAT _glm_mat4_copy
_TEXT	SEGMENT
_mat$ = 8						; size = 4
_dest$ = 12						; size = 4
_glm_mat4_copy PROC					; COMDAT

; 123  : glm_mat4_copy(mat4 mat, mat4 dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __0C756A67_mat4@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 124  : #ifdef __AVX__
; 125  :   glmm_store256(dest[0], glmm_load256(mat[0]));
; 126  :   glmm_store256(dest[2], glmm_load256(mat[2]));
; 127  : #elif defined( __SSE__ ) || defined( __SSE2__ )
; 128  :   glmm_store(dest[0], glmm_load(mat[0]));

  00028	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  0002d	6b c8 00	 imul	 ecx, eax, 0
  00030	03 4d 08	 add	 ecx, DWORD PTR _mat$[ebp]
  00033	0f 10 01	 movups	 xmm0, XMMWORD PTR [ecx]
  00036	ba 10 00 00 00	 mov	 edx, 16			; 00000010H
  0003b	6b c2 00	 imul	 eax, edx, 0
  0003e	03 45 0c	 add	 eax, DWORD PTR _dest$[ebp]
  00041	0f 11 00	 movups	 XMMWORD PTR [eax], xmm0

; 129  :   glmm_store(dest[1], glmm_load(mat[1]));

  00044	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  00049	c1 e0 00	 shl	 eax, 0
  0004c	03 45 08	 add	 eax, DWORD PTR _mat$[ebp]
  0004f	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  00052	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  00057	c1 e1 00	 shl	 ecx, 0
  0005a	03 4d 0c	 add	 ecx, DWORD PTR _dest$[ebp]
  0005d	0f 11 01	 movups	 XMMWORD PTR [ecx], xmm0

; 130  :   glmm_store(dest[2], glmm_load(mat[2]));

  00060	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  00065	d1 e0		 shl	 eax, 1
  00067	03 45 08	 add	 eax, DWORD PTR _mat$[ebp]
  0006a	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  0006d	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  00072	d1 e1		 shl	 ecx, 1
  00074	03 4d 0c	 add	 ecx, DWORD PTR _dest$[ebp]
  00077	0f 11 01	 movups	 XMMWORD PTR [ecx], xmm0

; 131  :   glmm_store(dest[3], glmm_load(mat[3]));

  0007a	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  0007f	6b c8 03	 imul	 ecx, eax, 3
  00082	03 4d 08	 add	 ecx, DWORD PTR _mat$[ebp]
  00085	0f 10 01	 movups	 xmm0, XMMWORD PTR [ecx]
  00088	ba 10 00 00 00	 mov	 edx, 16			; 00000010H
  0008d	6b c2 03	 imul	 eax, edx, 3
  00090	03 45 0c	 add	 eax, DWORD PTR _dest$[ebp]
  00093	0f 11 00	 movups	 XMMWORD PTR [eax], xmm0

; 132  : #elif defined(CGLM_NEON_FP)
; 133  :   vst1q_f32(dest[0], vld1q_f32(mat[0]));
; 134  :   vst1q_f32(dest[1], vld1q_f32(mat[1]));
; 135  :   vst1q_f32(dest[2], vld1q_f32(mat[2]));
; 136  :   vst1q_f32(dest[3], vld1q_f32(mat[3]));
; 137  : #else
; 138  :   glm_mat4_ucopy(mat, dest);
; 139  : #endif
; 140  : }

  00096	5f		 pop	 edi
  00097	5e		 pop	 esi
  00098	5b		 pop	 ebx
  00099	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0009f	3b ec		 cmp	 ebp, esp
  000a1	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000a6	8b e5		 mov	 esp, ebp
  000a8	5d		 pop	 ebp
  000a9	c3		 ret	 0
_glm_mat4_copy ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Light\source\repos\Spacemonster\Spacemonster-code\include\vec3.h
;	COMDAT _glm_vec3_cross
_TEXT	SEGMENT
_a$ = 8							; size = 4
_b$ = 12						; size = 4
_dest$ = 16						; size = 4
_glm_vec3_cross PROC					; COMDAT

; 580  : glm_vec3_cross(vec3 a, vec3 b, vec3 dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __5865475C_vec3@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 581  :   /* (u2.v3 - u3.v2, u3.v1 - u1.v3, u1.v2 - u2.v1) */
; 582  :   dest[0] = a[1] * b[2] - a[2] * b[1];

  00028	b8 04 00 00 00	 mov	 eax, 4
  0002d	c1 e0 00	 shl	 eax, 0
  00030	b9 04 00 00 00	 mov	 ecx, 4
  00035	d1 e1		 shl	 ecx, 1
  00037	8b 55 08	 mov	 edx, DWORD PTR _a$[ebp]
  0003a	8b 75 0c	 mov	 esi, DWORD PTR _b$[ebp]
  0003d	f3 0f 10 04 02	 movss	 xmm0, DWORD PTR [edx+eax]
  00042	f3 0f 59 04 0e	 mulss	 xmm0, DWORD PTR [esi+ecx]
  00047	b8 04 00 00 00	 mov	 eax, 4
  0004c	d1 e0		 shl	 eax, 1
  0004e	b9 04 00 00 00	 mov	 ecx, 4
  00053	c1 e1 00	 shl	 ecx, 0
  00056	8b 55 08	 mov	 edx, DWORD PTR _a$[ebp]
  00059	8b 75 0c	 mov	 esi, DWORD PTR _b$[ebp]
  0005c	f3 0f 10 0c 02	 movss	 xmm1, DWORD PTR [edx+eax]
  00061	f3 0f 59 0c 0e	 mulss	 xmm1, DWORD PTR [esi+ecx]
  00066	f3 0f 5c c1	 subss	 xmm0, xmm1
  0006a	b8 04 00 00 00	 mov	 eax, 4
  0006f	6b c8 00	 imul	 ecx, eax, 0
  00072	8b 55 10	 mov	 edx, DWORD PTR _dest$[ebp]
  00075	f3 0f 11 04 0a	 movss	 DWORD PTR [edx+ecx], xmm0

; 583  :   dest[1] = a[2] * b[0] - a[0] * b[2];

  0007a	b8 04 00 00 00	 mov	 eax, 4
  0007f	d1 e0		 shl	 eax, 1
  00081	b9 04 00 00 00	 mov	 ecx, 4
  00086	6b d1 00	 imul	 edx, ecx, 0
  00089	8b 4d 08	 mov	 ecx, DWORD PTR _a$[ebp]
  0008c	8b 75 0c	 mov	 esi, DWORD PTR _b$[ebp]
  0008f	f3 0f 10 04 01	 movss	 xmm0, DWORD PTR [ecx+eax]
  00094	f3 0f 59 04 16	 mulss	 xmm0, DWORD PTR [esi+edx]
  00099	ba 04 00 00 00	 mov	 edx, 4
  0009e	6b c2 00	 imul	 eax, edx, 0
  000a1	b9 04 00 00 00	 mov	 ecx, 4
  000a6	d1 e1		 shl	 ecx, 1
  000a8	8b 55 08	 mov	 edx, DWORD PTR _a$[ebp]
  000ab	8b 75 0c	 mov	 esi, DWORD PTR _b$[ebp]
  000ae	f3 0f 10 0c 02	 movss	 xmm1, DWORD PTR [edx+eax]
  000b3	f3 0f 59 0c 0e	 mulss	 xmm1, DWORD PTR [esi+ecx]
  000b8	f3 0f 5c c1	 subss	 xmm0, xmm1
  000bc	b8 04 00 00 00	 mov	 eax, 4
  000c1	c1 e0 00	 shl	 eax, 0
  000c4	8b 4d 10	 mov	 ecx, DWORD PTR _dest$[ebp]
  000c7	f3 0f 11 04 01	 movss	 DWORD PTR [ecx+eax], xmm0

; 584  :   dest[2] = a[0] * b[1] - a[1] * b[0];

  000cc	b8 04 00 00 00	 mov	 eax, 4
  000d1	6b c8 00	 imul	 ecx, eax, 0
  000d4	ba 04 00 00 00	 mov	 edx, 4
  000d9	c1 e2 00	 shl	 edx, 0
  000dc	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  000df	8b 75 0c	 mov	 esi, DWORD PTR _b$[ebp]
  000e2	f3 0f 10 04 08	 movss	 xmm0, DWORD PTR [eax+ecx]
  000e7	f3 0f 59 04 16	 mulss	 xmm0, DWORD PTR [esi+edx]
  000ec	b9 04 00 00 00	 mov	 ecx, 4
  000f1	c1 e1 00	 shl	 ecx, 0
  000f4	ba 04 00 00 00	 mov	 edx, 4
  000f9	6b c2 00	 imul	 eax, edx, 0
  000fc	8b 55 08	 mov	 edx, DWORD PTR _a$[ebp]
  000ff	8b 75 0c	 mov	 esi, DWORD PTR _b$[ebp]
  00102	f3 0f 10 0c 0a	 movss	 xmm1, DWORD PTR [edx+ecx]
  00107	f3 0f 59 0c 06	 mulss	 xmm1, DWORD PTR [esi+eax]
  0010c	f3 0f 5c c1	 subss	 xmm0, xmm1
  00110	b8 04 00 00 00	 mov	 eax, 4
  00115	d1 e0		 shl	 eax, 1
  00117	8b 4d 10	 mov	 ecx, DWORD PTR _dest$[ebp]
  0011a	f3 0f 11 04 01	 movss	 DWORD PTR [ecx+eax], xmm0

; 585  : }

  0011f	5f		 pop	 edi
  00120	5e		 pop	 esi
  00121	5b		 pop	 ebx
  00122	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00128	3b ec		 cmp	 ebp, esp
  0012a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0012f	8b e5		 mov	 esp, ebp
  00131	5d		 pop	 ebp
  00132	c3		 ret	 0
_glm_vec3_cross ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Light\source\repos\Spacemonster\Spacemonster-code\include\vec3.h
;	COMDAT _glm_vec3_normalize_to
_TEXT	SEGMENT
_norm$ = -8						; size = 4
_v$ = 8							; size = 4
_dest$ = 12						; size = 4
_glm_vec3_normalize_to PROC				; COMDAT

; 558  : glm_vec3_normalize_to(vec3 v, vec3 dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __5865475C_vec3@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 559  :   float norm;
; 560  : 
; 561  :   norm = glm_vec3_norm(v);

  00028	8b 45 08	 mov	 eax, DWORD PTR _v$[ebp]
  0002b	50		 push	 eax
  0002c	e8 00 00 00 00	 call	 _glm_vec3_norm
  00031	83 c4 04	 add	 esp, 4
  00034	d9 5d f8	 fstp	 DWORD PTR _norm$[ebp]

; 562  : 
; 563  :   if (norm == 0.0f) {

  00037	f3 0f 10 45 f8	 movss	 xmm0, DWORD PTR _norm$[ebp]
  0003c	0f 2e 05 00 00
	00 00		 ucomiss xmm0, DWORD PTR __real@00000000
  00043	9f		 lahf
  00044	f6 c4 44	 test	 ah, 68			; 00000044H
  00047	7a 0e		 jp	 SHORT $LN2@glm_vec3_n

; 564  :     glm_vec3_zero(dest);

  00049	8b 45 0c	 mov	 eax, DWORD PTR _dest$[ebp]
  0004c	50		 push	 eax
  0004d	e8 00 00 00 00	 call	 _glm_vec3_zero
  00052	83 c4 04	 add	 esp, 4

; 565  :     return;

  00055	eb 23		 jmp	 SHORT $LN1@glm_vec3_n
$LN2@glm_vec3_n:

; 566  :   }
; 567  : 
; 568  :   glm_vec3_scale(v, 1.0f / norm, dest);

  00057	8b 45 0c	 mov	 eax, DWORD PTR _dest$[ebp]
  0005a	50		 push	 eax
  0005b	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00063	f3 0f 5e 45 f8	 divss	 xmm0, DWORD PTR _norm$[ebp]
  00068	51		 push	 ecx
  00069	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0006e	8b 4d 08	 mov	 ecx, DWORD PTR _v$[ebp]
  00071	51		 push	 ecx
  00072	e8 00 00 00 00	 call	 _glm_vec3_scale
  00077	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@glm_vec3_n:

; 569  : }

  0007a	5f		 pop	 edi
  0007b	5e		 pop	 esi
  0007c	5b		 pop	 ebx
  0007d	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00083	3b ec		 cmp	 ebp, esp
  00085	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0008a	8b e5		 mov	 esp, ebp
  0008c	5d		 pop	 ebp
  0008d	c3		 ret	 0
_glm_vec3_normalize_to ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Light\source\repos\Spacemonster\Spacemonster-code\include\vec3.h
;	COMDAT _glm_vec3_negate
_TEXT	SEGMENT
_v$ = 8							; size = 4
_glm_vec3_negate PROC					; COMDAT

; 526  : glm_vec3_negate(vec3 v) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __5865475C_vec3@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 527  :   glm_vec3_negate_to(v, v);

  00028	8b 45 08	 mov	 eax, DWORD PTR _v$[ebp]
  0002b	50		 push	 eax
  0002c	8b 4d 08	 mov	 ecx, DWORD PTR _v$[ebp]
  0002f	51		 push	 ecx
  00030	e8 00 00 00 00	 call	 _glm_vec3_negate_to
  00035	83 c4 08	 add	 esp, 8

; 528  : }

  00038	5f		 pop	 edi
  00039	5e		 pop	 esi
  0003a	5b		 pop	 ebx
  0003b	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00041	3b ec		 cmp	 ebp, esp
  00043	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00048	8b e5		 mov	 esp, ebp
  0004a	5d		 pop	 ebp
  0004b	c3		 ret	 0
_glm_vec3_negate ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Light\source\repos\Spacemonster\Spacemonster-code\include\vec3.h
;	COMDAT _glm_vec3_negate_to
_TEXT	SEGMENT
_v$ = 8							; size = 4
_dest$ = 12						; size = 4
_glm_vec3_negate_to PROC				; COMDAT

; 513  : glm_vec3_negate_to(vec3 v, vec3 dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __5865475C_vec3@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 514  :   dest[0] = -v[0];

  00028	b8 04 00 00 00	 mov	 eax, 4
  0002d	6b c8 00	 imul	 ecx, eax, 0
  00030	8b 55 08	 mov	 edx, DWORD PTR _v$[ebp]
  00033	f3 0f 10 04 0a	 movss	 xmm0, DWORD PTR [edx+ecx]
  00038	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
  0003f	b8 04 00 00 00	 mov	 eax, 4
  00044	6b c8 00	 imul	 ecx, eax, 0
  00047	8b 55 0c	 mov	 edx, DWORD PTR _dest$[ebp]
  0004a	f3 0f 11 04 0a	 movss	 DWORD PTR [edx+ecx], xmm0

; 515  :   dest[1] = -v[1];

  0004f	b8 04 00 00 00	 mov	 eax, 4
  00054	c1 e0 00	 shl	 eax, 0
  00057	8b 4d 08	 mov	 ecx, DWORD PTR _v$[ebp]
  0005a	f3 0f 10 04 01	 movss	 xmm0, DWORD PTR [ecx+eax]
  0005f	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
  00066	ba 04 00 00 00	 mov	 edx, 4
  0006b	c1 e2 00	 shl	 edx, 0
  0006e	8b 45 0c	 mov	 eax, DWORD PTR _dest$[ebp]
  00071	f3 0f 11 04 10	 movss	 DWORD PTR [eax+edx], xmm0

; 516  :   dest[2] = -v[2];

  00076	b8 04 00 00 00	 mov	 eax, 4
  0007b	d1 e0		 shl	 eax, 1
  0007d	8b 4d 08	 mov	 ecx, DWORD PTR _v$[ebp]
  00080	f3 0f 10 04 01	 movss	 xmm0, DWORD PTR [ecx+eax]
  00085	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
  0008c	ba 04 00 00 00	 mov	 edx, 4
  00091	d1 e2		 shl	 edx, 1
  00093	8b 45 0c	 mov	 eax, DWORD PTR _dest$[ebp]
  00096	f3 0f 11 04 10	 movss	 DWORD PTR [eax+edx], xmm0

; 517  : }

  0009b	5f		 pop	 edi
  0009c	5e		 pop	 esi
  0009d	5b		 pop	 ebx
  0009e	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  000a4	3b ec		 cmp	 ebp, esp
  000a6	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000ab	8b e5		 mov	 esp, ebp
  000ad	5d		 pop	 ebp
  000ae	c3		 ret	 0
_glm_vec3_negate_to ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Light\source\repos\Spacemonster\Spacemonster-code\include\vec3.h
;	COMDAT _glm_vec3_scale
_TEXT	SEGMENT
_v$ = 8							; size = 4
_s$ = 12						; size = 4
_dest$ = 16						; size = 4
_glm_vec3_scale PROC					; COMDAT

; 346  : glm_vec3_scale(vec3 v, float s, vec3 dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __5865475C_vec3@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 347  :   dest[0] = v[0] * s;

  00028	b8 04 00 00 00	 mov	 eax, 4
  0002d	6b c8 00	 imul	 ecx, eax, 0
  00030	8b 55 08	 mov	 edx, DWORD PTR _v$[ebp]
  00033	f3 0f 10 04 0a	 movss	 xmm0, DWORD PTR [edx+ecx]
  00038	f3 0f 59 45 0c	 mulss	 xmm0, DWORD PTR _s$[ebp]
  0003d	b8 04 00 00 00	 mov	 eax, 4
  00042	6b c8 00	 imul	 ecx, eax, 0
  00045	8b 55 10	 mov	 edx, DWORD PTR _dest$[ebp]
  00048	f3 0f 11 04 0a	 movss	 DWORD PTR [edx+ecx], xmm0

; 348  :   dest[1] = v[1] * s;

  0004d	b8 04 00 00 00	 mov	 eax, 4
  00052	c1 e0 00	 shl	 eax, 0
  00055	8b 4d 08	 mov	 ecx, DWORD PTR _v$[ebp]
  00058	f3 0f 10 04 01	 movss	 xmm0, DWORD PTR [ecx+eax]
  0005d	f3 0f 59 45 0c	 mulss	 xmm0, DWORD PTR _s$[ebp]
  00062	ba 04 00 00 00	 mov	 edx, 4
  00067	c1 e2 00	 shl	 edx, 0
  0006a	8b 45 10	 mov	 eax, DWORD PTR _dest$[ebp]
  0006d	f3 0f 11 04 10	 movss	 DWORD PTR [eax+edx], xmm0

; 349  :   dest[2] = v[2] * s;

  00072	b8 04 00 00 00	 mov	 eax, 4
  00077	d1 e0		 shl	 eax, 1
  00079	8b 4d 08	 mov	 ecx, DWORD PTR _v$[ebp]
  0007c	f3 0f 10 04 01	 movss	 xmm0, DWORD PTR [ecx+eax]
  00081	f3 0f 59 45 0c	 mulss	 xmm0, DWORD PTR _s$[ebp]
  00086	ba 04 00 00 00	 mov	 edx, 4
  0008b	d1 e2		 shl	 edx, 1
  0008d	8b 45 10	 mov	 eax, DWORD PTR _dest$[ebp]
  00090	f3 0f 11 04 10	 movss	 DWORD PTR [eax+edx], xmm0

; 350  : }

  00095	5f		 pop	 edi
  00096	5e		 pop	 esi
  00097	5b		 pop	 ebx
  00098	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0009e	3b ec		 cmp	 ebp, esp
  000a0	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000a5	8b e5		 mov	 esp, ebp
  000a7	5d		 pop	 ebp
  000a8	c3		 ret	 0
_glm_vec3_scale ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Light\source\repos\Spacemonster\Spacemonster-code\include\vec3.h
;	COMDAT _glm_vec3_norm
_TEXT	SEGMENT
_v$ = 8							; size = 4
_glm_vec3_norm PROC					; COMDAT

; 215  : glm_vec3_norm(vec3 v) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __5865475C_vec3@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 216  :   return sqrtf(glm_vec3_norm2(v));

  00028	8b 45 08	 mov	 eax, DWORD PTR _v$[ebp]
  0002b	50		 push	 eax
  0002c	e8 00 00 00 00	 call	 _glm_vec3_norm2
  00031	d9 1c 24	 fstp	 DWORD PTR [esp]
  00034	e8 00 00 00 00	 call	 _sqrtf
  00039	83 c4 04	 add	 esp, 4

; 217  : }

  0003c	5f		 pop	 edi
  0003d	5e		 pop	 esi
  0003e	5b		 pop	 ebx
  0003f	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00045	3b ec		 cmp	 ebp, esp
  00047	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004c	8b e5		 mov	 esp, ebp
  0004e	5d		 pop	 ebp
  0004f	c3		 ret	 0
_glm_vec3_norm ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Light\source\repos\Spacemonster\Spacemonster-code\include\vec3.h
;	COMDAT _glm_vec3_norm2
_TEXT	SEGMENT
_v$ = 8							; size = 4
_glm_vec3_norm2 PROC					; COMDAT

; 201  : glm_vec3_norm2(vec3 v) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __5865475C_vec3@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 202  :   return glm_vec3_dot(v, v);

  00028	8b 45 08	 mov	 eax, DWORD PTR _v$[ebp]
  0002b	50		 push	 eax
  0002c	8b 4d 08	 mov	 ecx, DWORD PTR _v$[ebp]
  0002f	51		 push	 ecx
  00030	e8 00 00 00 00	 call	 _glm_vec3_dot
  00035	83 c4 08	 add	 esp, 8

; 203  : }

  00038	5f		 pop	 edi
  00039	5e		 pop	 esi
  0003a	5b		 pop	 ebx
  0003b	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00041	3b ec		 cmp	 ebp, esp
  00043	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00048	8b e5		 mov	 esp, ebp
  0004a	5d		 pop	 ebp
  0004b	c3		 ret	 0
_glm_vec3_norm2 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Light\source\repos\Spacemonster\Spacemonster-code\include\vec3.h
;	COMDAT _glm_vec3_dot
_TEXT	SEGMENT
tv130 = -196						; size = 4
_a$ = 8							; size = 4
_b$ = 12						; size = 4
_glm_vec3_dot PROC					; COMDAT

; 184  : glm_vec3_dot(vec3 a, vec3 b) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c4 00 00
	00		 sub	 esp, 196		; 000000c4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 3c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-196]
  00012	b9 31 00 00 00	 mov	 ecx, 49			; 00000031H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __5865475C_vec3@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 185  :   return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];

  00028	b8 04 00 00 00	 mov	 eax, 4
  0002d	6b c8 00	 imul	 ecx, eax, 0
  00030	ba 04 00 00 00	 mov	 edx, 4
  00035	6b c2 00	 imul	 eax, edx, 0
  00038	8b 55 08	 mov	 edx, DWORD PTR _a$[ebp]
  0003b	8b 75 0c	 mov	 esi, DWORD PTR _b$[ebp]
  0003e	f3 0f 10 04 0a	 movss	 xmm0, DWORD PTR [edx+ecx]
  00043	f3 0f 59 04 06	 mulss	 xmm0, DWORD PTR [esi+eax]
  00048	b8 04 00 00 00	 mov	 eax, 4
  0004d	c1 e0 00	 shl	 eax, 0
  00050	b9 04 00 00 00	 mov	 ecx, 4
  00055	c1 e1 00	 shl	 ecx, 0
  00058	8b 55 08	 mov	 edx, DWORD PTR _a$[ebp]
  0005b	8b 75 0c	 mov	 esi, DWORD PTR _b$[ebp]
  0005e	f3 0f 10 0c 02	 movss	 xmm1, DWORD PTR [edx+eax]
  00063	f3 0f 59 0c 0e	 mulss	 xmm1, DWORD PTR [esi+ecx]
  00068	f3 0f 58 c1	 addss	 xmm0, xmm1
  0006c	b8 04 00 00 00	 mov	 eax, 4
  00071	d1 e0		 shl	 eax, 1
  00073	b9 04 00 00 00	 mov	 ecx, 4
  00078	d1 e1		 shl	 ecx, 1
  0007a	8b 55 08	 mov	 edx, DWORD PTR _a$[ebp]
  0007d	8b 75 0c	 mov	 esi, DWORD PTR _b$[ebp]
  00080	f3 0f 10 0c 02	 movss	 xmm1, DWORD PTR [edx+eax]
  00085	f3 0f 59 0c 0e	 mulss	 xmm1, DWORD PTR [esi+ecx]
  0008a	f3 0f 58 c1	 addss	 xmm0, xmm1
  0008e	f3 0f 11 85 3c
	ff ff ff	 movss	 DWORD PTR tv130[ebp], xmm0
  00096	d9 85 3c ff ff
	ff		 fld	 DWORD PTR tv130[ebp]

; 186  : }

  0009c	5f		 pop	 edi
  0009d	5e		 pop	 esi
  0009e	5b		 pop	 ebx
  0009f	81 c4 c4 00 00
	00		 add	 esp, 196		; 000000c4H
  000a5	3b ec		 cmp	 ebp, esp
  000a7	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000ac	8b e5		 mov	 esp, ebp
  000ae	5d		 pop	 ebp
  000af	c3		 ret	 0
_glm_vec3_dot ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Light\source\repos\Spacemonster\Spacemonster-code\include\vec3.h
;	COMDAT _glm_vec3_zero
_TEXT	SEGMENT
_v$ = 8							; size = 4
_glm_vec3_zero PROC					; COMDAT

; 159  : glm_vec3_zero(vec3 v) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __5865475C_vec3@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 160  :   v[0] = v[1] = v[2] = 0.0f;

  00028	b8 04 00 00 00	 mov	 eax, 4
  0002d	d1 e0		 shl	 eax, 1
  0002f	8b 4d 08	 mov	 ecx, DWORD PTR _v$[ebp]
  00032	0f 57 c0	 xorps	 xmm0, xmm0
  00035	f3 0f 11 04 01	 movss	 DWORD PTR [ecx+eax], xmm0
  0003a	ba 04 00 00 00	 mov	 edx, 4
  0003f	c1 e2 00	 shl	 edx, 0
  00042	8b 45 08	 mov	 eax, DWORD PTR _v$[ebp]
  00045	0f 57 c0	 xorps	 xmm0, xmm0
  00048	f3 0f 11 04 10	 movss	 DWORD PTR [eax+edx], xmm0
  0004d	b9 04 00 00 00	 mov	 ecx, 4
  00052	6b d1 00	 imul	 edx, ecx, 0
  00055	8b 45 08	 mov	 eax, DWORD PTR _v$[ebp]
  00058	0f 57 c0	 xorps	 xmm0, xmm0
  0005b	f3 0f 11 04 10	 movss	 DWORD PTR [eax+edx], xmm0

; 161  : }

  00060	5f		 pop	 edi
  00061	5e		 pop	 esi
  00062	5b		 pop	 ebx
  00063	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00069	3b ec		 cmp	 ebp, esp
  0006b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00070	8b e5		 mov	 esp, ebp
  00072	5d		 pop	 ebp
  00073	c3		 ret	 0
_glm_vec3_zero ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Light\source\repos\Spacemonster\Spacemonster-code\include\vec3.h
;	COMDAT _glm_vec3_copy
_TEXT	SEGMENT
_a$ = 8							; size = 4
_dest$ = 12						; size = 4
_glm_vec3_copy PROC					; COMDAT

; 146  : glm_vec3_copy(vec3 a, vec3 dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __5865475C_vec3@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 147  :   dest[0] = a[0];

  00028	b8 04 00 00 00	 mov	 eax, 4
  0002d	6b c8 00	 imul	 ecx, eax, 0
  00030	ba 04 00 00 00	 mov	 edx, 4
  00035	6b c2 00	 imul	 eax, edx, 0
  00038	8b 55 0c	 mov	 edx, DWORD PTR _dest$[ebp]
  0003b	8b 75 08	 mov	 esi, DWORD PTR _a$[ebp]
  0003e	8b 0c 0e	 mov	 ecx, DWORD PTR [esi+ecx]
  00041	89 0c 02	 mov	 DWORD PTR [edx+eax], ecx

; 148  :   dest[1] = a[1];

  00044	b8 04 00 00 00	 mov	 eax, 4
  00049	c1 e0 00	 shl	 eax, 0
  0004c	b9 04 00 00 00	 mov	 ecx, 4
  00051	c1 e1 00	 shl	 ecx, 0
  00054	8b 55 0c	 mov	 edx, DWORD PTR _dest$[ebp]
  00057	8b 75 08	 mov	 esi, DWORD PTR _a$[ebp]
  0005a	8b 04 06	 mov	 eax, DWORD PTR [esi+eax]
  0005d	89 04 0a	 mov	 DWORD PTR [edx+ecx], eax

; 149  :   dest[2] = a[2];

  00060	b8 04 00 00 00	 mov	 eax, 4
  00065	d1 e0		 shl	 eax, 1
  00067	b9 04 00 00 00	 mov	 ecx, 4
  0006c	d1 e1		 shl	 ecx, 1
  0006e	8b 55 0c	 mov	 edx, DWORD PTR _dest$[ebp]
  00071	8b 75 08	 mov	 esi, DWORD PTR _a$[ebp]
  00074	8b 04 06	 mov	 eax, DWORD PTR [esi+eax]
  00077	89 04 0a	 mov	 DWORD PTR [edx+ecx], eax

; 150  : }

  0007a	5f		 pop	 edi
  0007b	5e		 pop	 esi
  0007c	5b		 pop	 ebx
  0007d	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00083	3b ec		 cmp	 ebp, esp
  00085	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0008a	8b e5		 mov	 esp, ebp
  0008c	5d		 pop	 ebp
  0008d	c3		 ret	 0
_glm_vec3_copy ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Light\source\repos\Spacemonster\Spacemonster-code\include\vec4.h
;	COMDAT _glm_vec4_negate
_TEXT	SEGMENT
_v$ = 8							; size = 4
_glm_vec4_negate PROC					; COMDAT

; 699  : glm_vec4_negate(vec4 v) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __5D2A51D9_vec4@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 700  :   glm_vec4_negate_to(v, v);

  00028	8b 45 08	 mov	 eax, DWORD PTR _v$[ebp]
  0002b	50		 push	 eax
  0002c	8b 4d 08	 mov	 ecx, DWORD PTR _v$[ebp]
  0002f	51		 push	 ecx
  00030	e8 00 00 00 00	 call	 _glm_vec4_negate_to
  00035	83 c4 08	 add	 esp, 8

; 701  : }

  00038	5f		 pop	 edi
  00039	5e		 pop	 esi
  0003a	5b		 pop	 ebx
  0003b	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00041	3b ec		 cmp	 ebp, esp
  00043	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00048	8b e5		 mov	 esp, ebp
  0004a	5d		 pop	 ebp
  0004b	c3		 ret	 0
_glm_vec4_negate ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Light\source\repos\Spacemonster\Spacemonster-code\include\vec4.h
;	COMDAT _glm_vec4_negate_to
_TEXT	SEGMENT
_v$ = 8							; size = 4
_dest$ = 12						; size = 4
_glm_vec4_negate_to PROC				; COMDAT

; 679  : glm_vec4_negate_to(vec4 v, vec4 dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __5D2A51D9_vec4@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 680  : #if defined( __SSE__ ) || defined( __SSE2__ )
; 681  :   glmm_store(dest, _mm_xor_ps(glmm_load(v), _mm_set1_ps(-0.0f)));

  00028	8b 45 08	 mov	 eax, DWORD PTR _v$[ebp]
  0002b	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  0002e	0f 57 05 00 00
	00 00		 xorps	 xmm0, XMMWORD PTR __xmm@80000000800000008000000080000000
  00035	8b 4d 0c	 mov	 ecx, DWORD PTR _dest$[ebp]
  00038	0f 11 01	 movups	 XMMWORD PTR [ecx], xmm0

; 682  : #elif defined(CGLM_NEON_FP)
; 683  :   vst1q_f32(dest, vnegq_f32(vld1q_f32(v)));
; 684  : #else
; 685  :   dest[0] = -v[0];
; 686  :   dest[1] = -v[1];
; 687  :   dest[2] = -v[2];
; 688  :   dest[3] = -v[3];
; 689  : #endif
; 690  : }

  0003b	5f		 pop	 edi
  0003c	5e		 pop	 esi
  0003d	5b		 pop	 ebx
  0003e	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00044	3b ec		 cmp	 ebp, esp
  00046	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004b	8b e5		 mov	 esp, ebp
  0004d	5d		 pop	 ebp
  0004e	c3		 ret	 0
_glm_vec4_negate_to ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Light\source\repos\Spacemonster\Spacemonster-code\include\vec4.h
;	COMDAT _glm_vec4_scale
_TEXT	SEGMENT
_v$ = 8							; size = 4
_s$ = 12						; size = 4
_dest$ = 16						; size = 4
_glm_vec4_scale PROC					; COMDAT

; 432  : glm_vec4_scale(vec4 v, float s, vec4 dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __5D2A51D9_vec4@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 433  : #if defined( __SSE__ ) || defined( __SSE2__ )
; 434  :   glmm_store(dest, _mm_mul_ps(glmm_load(v), _mm_set1_ps(s)));

  00028	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _s$[ebp]
  0002d	0f c6 c0 00	 shufps	 xmm0, xmm0, 0
  00031	8b 45 08	 mov	 eax, DWORD PTR _v$[ebp]
  00034	0f 10 08	 movups	 xmm1, XMMWORD PTR [eax]
  00037	0f 59 c8	 mulps	 xmm1, xmm0
  0003a	8b 4d 10	 mov	 ecx, DWORD PTR _dest$[ebp]
  0003d	0f 11 09	 movups	 XMMWORD PTR [ecx], xmm1

; 435  : #elif defined(CGLM_NEON_FP)
; 436  :   vst1q_f32(dest, vmulq_f32(vld1q_f32(v), vdupq_n_f32(s)));
; 437  : #else
; 438  :   dest[0] = v[0] * s;
; 439  :   dest[1] = v[1] * s;
; 440  :   dest[2] = v[2] * s;
; 441  :   dest[3] = v[3] * s;
; 442  : #endif
; 443  : }

  00040	5f		 pop	 edi
  00041	5e		 pop	 esi
  00042	5b		 pop	 ebx
  00043	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00049	3b ec		 cmp	 ebp, esp
  0004b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00050	8b e5		 mov	 esp, ebp
  00052	5d		 pop	 ebp
  00053	c3		 ret	 0
_glm_vec4_scale ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Light\source\repos\Spacemonster\Spacemonster-code\include\vec4.h
;	COMDAT _glm_vec4_copy
_TEXT	SEGMENT
_v$ = 8							; size = 4
_dest$ = 12						; size = 4
_glm_vec4_copy PROC					; COMDAT

; 139  : glm_vec4_copy(vec4 v, vec4 dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __5D2A51D9_vec4@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 140  : #if defined( __SSE__ ) || defined( __SSE2__ )
; 141  :   glmm_store(dest, glmm_load(v));

  00028	8b 45 08	 mov	 eax, DWORD PTR _v$[ebp]
  0002b	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  0002e	8b 4d 0c	 mov	 ecx, DWORD PTR _dest$[ebp]
  00031	0f 11 01	 movups	 XMMWORD PTR [ecx], xmm0

; 142  : #elif defined(CGLM_NEON_FP)
; 143  :   vst1q_f32(dest, vld1q_f32(v));
; 144  : #else
; 145  :   dest[0] = v[0];
; 146  :   dest[1] = v[1];
; 147  :   dest[2] = v[2];
; 148  :   dest[3] = v[3];
; 149  : #endif
; 150  : }

  00034	5f		 pop	 edi
  00035	5e		 pop	 esi
  00036	5b		 pop	 ebx
  00037	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0003d	3b ec		 cmp	 ebp, esp
  0003f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00044	8b e5		 mov	 esp, ebp
  00046	5d		 pop	 ebp
  00047	c3		 ret	 0
_glm_vec4_copy ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Light\source\repos\Spacemonster\Spacemonster-code\include\vec3-ext.h
;	COMDAT _glm_vec3_eq_all
_TEXT	SEGMENT
_v$ = 8							; size = 4
_glm_vec3_eq_all PROC					; COMDAT

; 96   : glm_vec3_eq_all(vec3 v) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __422D73DD_vec3-ext@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 97   :   return glm_vec3_eq_eps(v, v[0]);

  00028	b8 04 00 00 00	 mov	 eax, 4
  0002d	6b c8 00	 imul	 ecx, eax, 0
  00030	8b 55 08	 mov	 edx, DWORD PTR _v$[ebp]
  00033	51		 push	 ecx
  00034	f3 0f 10 04 0a	 movss	 xmm0, DWORD PTR [edx+ecx]
  00039	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0003e	8b 45 08	 mov	 eax, DWORD PTR _v$[ebp]
  00041	50		 push	 eax
  00042	e8 00 00 00 00	 call	 _glm_vec3_eq_eps
  00047	83 c4 08	 add	 esp, 8

; 98   : }

  0004a	5f		 pop	 edi
  0004b	5e		 pop	 esi
  0004c	5b		 pop	 ebx
  0004d	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00053	3b ec		 cmp	 ebp, esp
  00055	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005a	8b e5		 mov	 esp, ebp
  0005c	5d		 pop	 ebp
  0005d	c3		 ret	 0
_glm_vec3_eq_all ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Light\source\repos\Spacemonster\Spacemonster-code\include\vec3-ext.h
;	COMDAT _glm_vec3_eq_eps
_TEXT	SEGMENT
tv87 = -224						; size = 4
tv85 = -220						; size = 4
tv152 = -216						; size = 8
tv142 = -208						; size = 8
tv132 = -200						; size = 8
_v$ = 8							; size = 4
_val$ = 12						; size = 4
_glm_vec3_eq_eps PROC					; COMDAT

; 83   : glm_vec3_eq_eps(vec3 v, float val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec e0 00 00
	00		 sub	 esp, 224		; 000000e0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 20 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-224]
  00012	b9 38 00 00 00	 mov	 ecx, 56			; 00000038H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __422D73DD_vec3-ext@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 84   :   return fabsf(v[0] - val) <= GLM_FLT_EPSILON

  00028	b8 04 00 00 00	 mov	 eax, 4
  0002d	6b c8 00	 imul	 ecx, eax, 0
  00030	8b 55 08	 mov	 edx, DWORD PTR _v$[ebp]
  00033	f3 0f 10 04 0a	 movss	 xmm0, DWORD PTR [edx+ecx]
  00038	f3 0f 5c 45 0c	 subss	 xmm0, DWORD PTR _val$[ebp]
  0003d	51		 push	 ecx
  0003e	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00043	e8 00 00 00 00	 call	 _fabsf
  00048	83 c4 04	 add	 esp, 4
  0004b	dd 9d 38 ff ff
	ff		 fstp	 QWORD PTR tv132[ebp]
  00051	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR __real@3eb0c6f7a0b5ed8d
  00059	66 0f 2f 85 38
	ff ff ff	 comisd	 xmm0, QWORD PTR tv132[ebp]
  00061	0f 82 81 00 00
	00		 jb	 $LN3@glm_vec3_e
  00067	b8 04 00 00 00	 mov	 eax, 4
  0006c	c1 e0 00	 shl	 eax, 0
  0006f	8b 4d 08	 mov	 ecx, DWORD PTR _v$[ebp]
  00072	f3 0f 10 04 01	 movss	 xmm0, DWORD PTR [ecx+eax]
  00077	f3 0f 5c 45 0c	 subss	 xmm0, DWORD PTR _val$[ebp]
  0007c	51		 push	 ecx
  0007d	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00082	e8 00 00 00 00	 call	 _fabsf
  00087	83 c4 04	 add	 esp, 4
  0008a	dd 9d 30 ff ff
	ff		 fstp	 QWORD PTR tv142[ebp]
  00090	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR __real@3eb0c6f7a0b5ed8d
  00098	66 0f 2f 85 30
	ff ff ff	 comisd	 xmm0, QWORD PTR tv142[ebp]
  000a0	72 46		 jb	 SHORT $LN3@glm_vec3_e
  000a2	ba 04 00 00 00	 mov	 edx, 4
  000a7	d1 e2		 shl	 edx, 1
  000a9	8b 45 08	 mov	 eax, DWORD PTR _v$[ebp]
  000ac	f3 0f 10 04 10	 movss	 xmm0, DWORD PTR [eax+edx]
  000b1	f3 0f 5c 45 0c	 subss	 xmm0, DWORD PTR _val$[ebp]
  000b6	51		 push	 ecx
  000b7	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000bc	e8 00 00 00 00	 call	 _fabsf
  000c1	83 c4 04	 add	 esp, 4
  000c4	dd 9d 28 ff ff
	ff		 fstp	 QWORD PTR tv152[ebp]
  000ca	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR __real@3eb0c6f7a0b5ed8d
  000d2	66 0f 2f 85 28
	ff ff ff	 comisd	 xmm0, QWORD PTR tv152[ebp]
  000da	72 0c		 jb	 SHORT $LN3@glm_vec3_e
  000dc	c7 85 24 ff ff
	ff 01 00 00 00	 mov	 DWORD PTR tv85[ebp], 1
  000e6	eb 0a		 jmp	 SHORT $LN4@glm_vec3_e
$LN3@glm_vec3_e:
  000e8	c7 85 24 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv85[ebp], 0
$LN4@glm_vec3_e:
  000f2	83 bd 24 ff ff
	ff 00		 cmp	 DWORD PTR tv85[ebp], 0
  000f9	75 0c		 jne	 SHORT $LN5@glm_vec3_e
  000fb	c7 85 20 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv87[ebp], 0
  00105	eb 0a		 jmp	 SHORT $LN6@glm_vec3_e
$LN5@glm_vec3_e:
  00107	c7 85 20 ff ff
	ff 01 00 00 00	 mov	 DWORD PTR tv87[ebp], 1
$LN6@glm_vec3_e:
  00111	8a 85 20 ff ff
	ff		 mov	 al, BYTE PTR tv87[ebp]

; 85   :          && fabsf(v[1] - val) <= GLM_FLT_EPSILON
; 86   :          && fabsf(v[2] - val) <= GLM_FLT_EPSILON;
; 87   : }

  00117	5f		 pop	 edi
  00118	5e		 pop	 esi
  00119	5b		 pop	 ebx
  0011a	81 c4 e0 00 00
	00		 add	 esp, 224		; 000000e0H
  00120	3b ec		 cmp	 ebp, esp
  00122	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00127	8b e5		 mov	 esp, ebp
  00129	5d		 pop	 ebp
  0012a	c3		 ret	 0
_glm_vec3_eq_eps ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_math.h
;	COMDAT _sqrtf
_TEXT	SEGMENT
tv72 = -196						; size = 4
__X$ = 8						; size = 4
_sqrtf	PROC						; COMDAT

; 759  :         {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c4 00 00
	00		 sub	 esp, 196		; 000000c4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 3c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-196]
  00012	b9 31 00 00 00	 mov	 ecx, 49			; 00000031H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __09340588_corecrt_math@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 760  :             return (float)sqrt(_X);

  00028	f3 0f 5a 45 08	 cvtss2sd xmm0, DWORD PTR __X$[ebp]
  0002d	83 ec 08	 sub	 esp, 8
  00030	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00035	e8 00 00 00 00	 call	 _sqrt
  0003a	83 c4 08	 add	 esp, 8
  0003d	d9 9d 3c ff ff
	ff		 fstp	 DWORD PTR tv72[ebp]
  00043	d9 85 3c ff ff
	ff		 fld	 DWORD PTR tv72[ebp]

; 761  :         }

  00049	5f		 pop	 edi
  0004a	5e		 pop	 esi
  0004b	5b		 pop	 ebx
  0004c	81 c4 c4 00 00
	00		 add	 esp, 196		; 000000c4H
  00052	3b ec		 cmp	 ebp, esp
  00054	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00059	8b e5		 mov	 esp, ebp
  0005b	5d		 pop	 ebp
  0005c	c3		 ret	 0
_sqrtf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_math.h
;	COMDAT _sinf
_TEXT	SEGMENT
tv72 = -196						; size = 4
__X$ = 8						; size = 4
_sinf	PROC						; COMDAT

; 749  :         {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c4 00 00
	00		 sub	 esp, 196		; 000000c4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 3c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-196]
  00012	b9 31 00 00 00	 mov	 ecx, 49			; 00000031H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __09340588_corecrt_math@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 750  :             return (float)sin(_X);

  00028	f3 0f 5a 45 08	 cvtss2sd xmm0, DWORD PTR __X$[ebp]
  0002d	83 ec 08	 sub	 esp, 8
  00030	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00035	e8 00 00 00 00	 call	 _sin
  0003a	83 c4 08	 add	 esp, 8
  0003d	d9 9d 3c ff ff
	ff		 fstp	 DWORD PTR tv72[ebp]
  00043	d9 85 3c ff ff
	ff		 fld	 DWORD PTR tv72[ebp]

; 751  :         }

  00049	5f		 pop	 edi
  0004a	5e		 pop	 esi
  0004b	5b		 pop	 ebx
  0004c	81 c4 c4 00 00
	00		 add	 esp, 196		; 000000c4H
  00052	3b ec		 cmp	 ebp, esp
  00054	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00059	8b e5		 mov	 esp, ebp
  0005b	5d		 pop	 ebp
  0005c	c3		 ret	 0
_sinf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_math.h
;	COMDAT _fabsf
_TEXT	SEGMENT
tv72 = -196						; size = 4
__X$ = 8						; size = 4
_fabsf	PROC						; COMDAT

; 671  :         {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c4 00 00
	00		 sub	 esp, 196		; 000000c4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 3c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-196]
  00012	b9 31 00 00 00	 mov	 ecx, 49			; 00000031H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __09340588_corecrt_math@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 672  :             return (float)fabs(_X);

  00028	f3 0f 5a 45 08	 cvtss2sd xmm0, DWORD PTR __X$[ebp]
  0002d	83 ec 08	 sub	 esp, 8
  00030	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00035	e8 00 00 00 00	 call	 _fabs
  0003a	83 c4 08	 add	 esp, 8
  0003d	d9 9d 3c ff ff
	ff		 fstp	 DWORD PTR tv72[ebp]
  00043	d9 85 3c ff ff
	ff		 fld	 DWORD PTR tv72[ebp]

; 673  :         }

  00049	5f		 pop	 edi
  0004a	5e		 pop	 esi
  0004b	5b		 pop	 ebx
  0004c	81 c4 c4 00 00
	00		 add	 esp, 196		; 000000c4H
  00052	3b ec		 cmp	 ebp, esp
  00054	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00059	8b e5		 mov	 esp, ebp
  0005b	5d		 pop	 ebp
  0005c	c3		 ret	 0
_fabsf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_math.h
;	COMDAT _cosf
_TEXT	SEGMENT
tv72 = -196						; size = 4
__X$ = 8						; size = 4
_cosf	PROC						; COMDAT

; 648  :         {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c4 00 00
	00		 sub	 esp, 196		; 000000c4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 3c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-196]
  00012	b9 31 00 00 00	 mov	 ecx, 49			; 00000031H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __09340588_corecrt_math@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 649  :             return (float)cos(_X);

  00028	f3 0f 5a 45 08	 cvtss2sd xmm0, DWORD PTR __X$[ebp]
  0002d	83 ec 08	 sub	 esp, 8
  00030	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00035	e8 00 00 00 00	 call	 _cos
  0003a	83 c4 08	 add	 esp, 8
  0003d	d9 9d 3c ff ff
	ff		 fstp	 DWORD PTR tv72[ebp]
  00043	d9 85 3c ff ff
	ff		 fld	 DWORD PTR tv72[ebp]

; 650  :         }

  00049	5f		 pop	 edi
  0004a	5e		 pop	 esi
  0004b	5b		 pop	 ebx
  0004c	81 c4 c4 00 00
	00		 add	 esp, 196		; 000000c4H
  00052	3b ec		 cmp	 ebp, esp
  00054	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00059	8b e5		 mov	 esp, ebp
  0005b	5d		 pop	 ebp
  0005c	c3		 ret	 0
_cosf	ENDP
_TEXT	ENDS
END
