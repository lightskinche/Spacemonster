; Listing generated by Microsoft (R) Optimizing Compiler Version 19.27.29111.0 

	TITLE	C:\Users\Light\source\repos\3DRendC\glmc\frustum.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

msvcjmc	SEGMENT
__09340588_corecrt_math@h DB 01H
__B0C4CEA9_malloc@h DB 01H
__AF08451A_xmmintrin@h DB 01H
__D164993B_x86@h DB 01H
__51BD2C42_util@h DB 01H
__34F2E310_vec2-ext@h DB 01H
__83360300_vec2@h DB 01H
__9285E8A4_vec3-ext@h DB 01H
__5722D62A_vec4-ext@h DB 01H
__87BB7FB2_vec4@h DB 01H
__82F46937_vec3@h DB 01H
__6C51F661_mat4@h DB 01H
__D6E4440C_mat4@h DB 01H
__691EE0E4_mat3@h DB 01H
__D3AB5289_mat3@h DB 01H
__68DC8AD3_mat2@h DB 01H
__D26938BE_mat2@h DB 01H
__EF0FC99D_affine@h DB 01H
__8C09B87C_affine-mat@h DB 01H
__1A33B462_affine@h DB 01H
__26C2D243_plane@h DB 01H
__B1B2DC28_cam@h DB 01H
__26922CBA_frustum@h DB 01H
__9A782FAE_quat@h DB 01H
__20CD9DC3_quat@h DB 01H
__0105C43C_euler@h DB 01H
__76E0E330_box@h DB 01H
__AF25309F_color@h DB 01H
__F66CEB67_corecrt_stdio_config@h DB 01H
__101834BA_corecrt_wstdio@h DB 01H
__AD6A91B7_stdio@h DB 01H
__98FD395E_io@h DB 01H
__253AA91C_project@h DB 01H
__C5964F96_sphere@h DB 01H
__CA1EBA5F_ease@h DB 01H
__E6C09561_curve@h DB 01H
__1F285908_bezier@h DB 01H
__F71D69B6_ray@h DB 01H
__C07C9586_affine2d@h DB 01H
__3F8BA224_vec3@h DB 01H
__3AC4B4A1_vec4@h DB 01H
__6BD01735_frustum@c DB 01H
msvcjmc	ENDS
PUBLIC	_sqrtf
PUBLIC	_glm_pow2
PUBLIC	_glm_min
PUBLIC	_glm_max
PUBLIC	_glm_vec3_broadcast
PUBLIC	_glm_vec4_copy
PUBLIC	_glm_vec4_zero
PUBLIC	_glm_vec4_norm
PUBLIC	_glm_vec4_add
PUBLIC	_glm_vec4_sub
PUBLIC	_glm_vec4_scale
PUBLIC	_glm_vec4_scale_as
PUBLIC	_glm_vec3_copy
PUBLIC	_glm_vec3_dot
PUBLIC	_glm_vec3_norm2
PUBLIC	_glm_vec3_norm
PUBLIC	_glm_vec3_distance2
PUBLIC	_glm_vec3_distance
PUBLIC	_glm_mat4_transp_sse2
PUBLIC	_glm_mat4_mulv_sse2
PUBLIC	_glm_mat4_mulv
PUBLIC	_glm_mat4_transpose_to
PUBLIC	_glm_plane_normalize
PUBLIC	_glm_frustum_planes
PUBLIC	_glm_frustum_corners
PUBLIC	_glm_frustum_center
PUBLIC	_glm_frustum_box
PUBLIC	_glm_frustum_corners_at
PUBLIC	_glmc_frustum_planes
PUBLIC	_glmc_frustum_corners
PUBLIC	_glmc_frustum_center
PUBLIC	_glmc_frustum_box
PUBLIC	_glmc_frustum_corners_at
PUBLIC	__JustMyCode_Default
PUBLIC	__real@00000000
PUBLIC	__real@3e000000
PUBLIC	__real@3f800000
PUBLIC	__real@7f7fffff
PUBLIC	__real@bf800000
PUBLIC	__real@ff7fffff
EXTRN	_sqrt:PROC
EXTRN	@_RTC_CheckStackVars@8:PROC
EXTRN	@__CheckForDebuggerJustMyCode@4:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
;	COMDAT __real@ff7fffff
CONST	SEGMENT
__real@ff7fffff DD 0ff7fffffr			; -3.40282e+38
CONST	ENDS
;	COMDAT __real@bf800000
CONST	SEGMENT
__real@bf800000 DD 0bf800000r			; -1
CONST	ENDS
;	COMDAT __real@7f7fffff
CONST	SEGMENT
__real@7f7fffff DD 07f7fffffr			; 3.40282e+38
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@3e000000
CONST	SEGMENT
__real@3e000000 DD 03e000000r			; 0.125
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
; Function compile flags: /Odt
;	COMDAT __JustMyCode_Default
_TEXT	SEGMENT
__JustMyCode_Default PROC				; COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
__JustMyCode_Default ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Light\source\repos\3DRendC\glmc\frustum.c
;	COMDAT _glmc_frustum_corners_at
_TEXT	SEGMENT
_corners$ = 8						; size = 4
_splitDist$ = 12					; size = 4
_farDist$ = 16						; size = 4
_planeCorners$ = 20					; size = 4
_glmc_frustum_corners_at PROC				; COMDAT

; 40   :                         vec4  planeCorners[4]) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __6BD01735_frustum@c
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 41   :   glm_frustum_corners_at(corners, splitDist, farDist, planeCorners);

  00028	8b 45 14	 mov	 eax, DWORD PTR _planeCorners$[ebp]
  0002b	50		 push	 eax
  0002c	51		 push	 ecx
  0002d	f3 0f 10 45 10	 movss	 xmm0, DWORD PTR _farDist$[ebp]
  00032	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00037	51		 push	 ecx
  00038	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _splitDist$[ebp]
  0003d	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00042	8b 4d 08	 mov	 ecx, DWORD PTR _corners$[ebp]
  00045	51		 push	 ecx
  00046	e8 00 00 00 00	 call	 _glm_frustum_corners_at
  0004b	83 c4 10	 add	 esp, 16			; 00000010H

; 42   : }

  0004e	5f		 pop	 edi
  0004f	5e		 pop	 esi
  00050	5b		 pop	 ebx
  00051	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00057	3b ec		 cmp	 ebp, esp
  00059	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005e	8b e5		 mov	 esp, ebp
  00060	5d		 pop	 ebp
  00061	c3		 ret	 0
_glmc_frustum_corners_at ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Light\source\repos\3DRendC\glmc\frustum.c
;	COMDAT _glmc_frustum_box
_TEXT	SEGMENT
_corners$ = 8						; size = 4
_m$ = 12						; size = 4
_box$ = 16						; size = 4
_glmc_frustum_box PROC					; COMDAT

; 31   : glmc_frustum_box(vec4 corners[8], mat4 m, vec3 box[2]) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __6BD01735_frustum@c
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 32   :   glm_frustum_box(corners, m, box);

  00028	8b 45 10	 mov	 eax, DWORD PTR _box$[ebp]
  0002b	50		 push	 eax
  0002c	8b 4d 0c	 mov	 ecx, DWORD PTR _m$[ebp]
  0002f	51		 push	 ecx
  00030	8b 55 08	 mov	 edx, DWORD PTR _corners$[ebp]
  00033	52		 push	 edx
  00034	e8 00 00 00 00	 call	 _glm_frustum_box
  00039	83 c4 0c	 add	 esp, 12			; 0000000cH

; 33   : }

  0003c	5f		 pop	 edi
  0003d	5e		 pop	 esi
  0003e	5b		 pop	 ebx
  0003f	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00045	3b ec		 cmp	 ebp, esp
  00047	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004c	8b e5		 mov	 esp, ebp
  0004e	5d		 pop	 ebp
  0004f	c3		 ret	 0
_glmc_frustum_box ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Light\source\repos\3DRendC\glmc\frustum.c
;	COMDAT _glmc_frustum_center
_TEXT	SEGMENT
_corners$ = 8						; size = 4
_dest$ = 12						; size = 4
_glmc_frustum_center PROC				; COMDAT

; 25   : glmc_frustum_center(vec4 corners[8], vec4 dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __6BD01735_frustum@c
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 26   :   glm_frustum_center(corners, dest);

  00028	8b 45 0c	 mov	 eax, DWORD PTR _dest$[ebp]
  0002b	50		 push	 eax
  0002c	8b 4d 08	 mov	 ecx, DWORD PTR _corners$[ebp]
  0002f	51		 push	 ecx
  00030	e8 00 00 00 00	 call	 _glm_frustum_center
  00035	83 c4 08	 add	 esp, 8

; 27   : }

  00038	5f		 pop	 edi
  00039	5e		 pop	 esi
  0003a	5b		 pop	 ebx
  0003b	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00041	3b ec		 cmp	 ebp, esp
  00043	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00048	8b e5		 mov	 esp, ebp
  0004a	5d		 pop	 ebp
  0004b	c3		 ret	 0
_glmc_frustum_center ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Light\source\repos\3DRendC\glmc\frustum.c
;	COMDAT _glmc_frustum_corners
_TEXT	SEGMENT
_invMat$ = 8						; size = 4
_dest$ = 12						; size = 4
_glmc_frustum_corners PROC				; COMDAT

; 19   : glmc_frustum_corners(mat4 invMat, vec4 dest[8]) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __6BD01735_frustum@c
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 20   :   glm_frustum_corners(invMat, dest);

  00028	8b 45 0c	 mov	 eax, DWORD PTR _dest$[ebp]
  0002b	50		 push	 eax
  0002c	8b 4d 08	 mov	 ecx, DWORD PTR _invMat$[ebp]
  0002f	51		 push	 ecx
  00030	e8 00 00 00 00	 call	 _glm_frustum_corners
  00035	83 c4 08	 add	 esp, 8

; 21   : }

  00038	5f		 pop	 edi
  00039	5e		 pop	 esi
  0003a	5b		 pop	 ebx
  0003b	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00041	3b ec		 cmp	 ebp, esp
  00043	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00048	8b e5		 mov	 esp, ebp
  0004a	5d		 pop	 ebp
  0004b	c3		 ret	 0
_glmc_frustum_corners ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Light\source\repos\3DRendC\glmc\frustum.c
;	COMDAT _glmc_frustum_planes
_TEXT	SEGMENT
_m$ = 8							; size = 4
_dest$ = 12						; size = 4
_glmc_frustum_planes PROC				; COMDAT

; 13   : glmc_frustum_planes(mat4 m, vec4 dest[6]) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __6BD01735_frustum@c
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 14   :   glm_frustum_planes(m, dest);

  00028	8b 45 0c	 mov	 eax, DWORD PTR _dest$[ebp]
  0002b	50		 push	 eax
  0002c	8b 4d 08	 mov	 ecx, DWORD PTR _m$[ebp]
  0002f	51		 push	 ecx
  00030	e8 00 00 00 00	 call	 _glm_frustum_planes
  00035	83 c4 08	 add	 esp, 8

; 15   : }

  00038	5f		 pop	 edi
  00039	5e		 pop	 esi
  0003a	5b		 pop	 ebx
  0003b	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00041	3b ec		 cmp	 ebp, esp
  00043	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00048	8b e5		 mov	 esp, ebp
  0004a	5d		 pop	 ebp
  0004b	c3		 ret	 0
_glmc_frustum_planes ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Light\source\repos\3DRendC\include\frustum.h
;	COMDAT _glm_frustum_corners_at
_TEXT	SEGMENT
_sc$ = -56						; size = 4
_dist$ = -44						; size = 4
_corner$ = -32						; size = 16
__$ArrayPad$ = -4					; size = 4
_corners$ = 8						; size = 4
_splitDist$ = 12					; size = 4
_farDist$ = 16						; size = 4
_planeCorners$ = 20					; size = 4
_glm_frustum_corners_at PROC				; COMDAT

; 226  :                        vec4  planeCorners[4]) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 f0	 and	 esp, -16		; fffffff0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec 08 01 00
	00		 sub	 esp, 264		; 00000108H
  0001c	56		 push	 esi
  0001d	57		 push	 edi
  0001e	8d bd f8 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-264]
  00024	b9 42 00 00 00	 mov	 ecx, 66			; 00000042H
  00029	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002e	f3 ab		 rep stosd
  00030	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00035	33 c5		 xor	 eax, ebp
  00037	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0003a	b9 00 00 00 00	 mov	 ecx, OFFSET __26922CBA_frustum@h
  0003f	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 227  :   vec4  corner;
; 228  :   float dist, sc;
; 229  : 
; 230  :   /* because distance and scale is same for all */
; 231  :   dist = glm_vec3_distance(corners[GLM_RTF], corners[GLM_RTN]);

  00044	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  00049	d1 e0		 shl	 eax, 1
  0004b	03 43 08	 add	 eax, DWORD PTR _corners$[ebx]
  0004e	50		 push	 eax
  0004f	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  00054	6b d1 06	 imul	 edx, ecx, 6
  00057	03 53 08	 add	 edx, DWORD PTR _corners$[ebx]
  0005a	52		 push	 edx
  0005b	e8 00 00 00 00	 call	 _glm_vec3_distance
  00060	83 c4 08	 add	 esp, 8
  00063	d9 5d d4	 fstp	 DWORD PTR _dist$[ebp]

; 232  :   sc   = dist * (splitDist / farDist);

  00066	f3 0f 10 43 0c	 movss	 xmm0, DWORD PTR _splitDist$[ebx]
  0006b	f3 0f 5e 43 10	 divss	 xmm0, DWORD PTR _farDist$[ebx]
  00070	f3 0f 59 45 d4	 mulss	 xmm0, DWORD PTR _dist$[ebp]
  00075	f3 0f 11 45 c8	 movss	 DWORD PTR _sc$[ebp], xmm0

; 233  : 
; 234  :   /* left bottom */
; 235  :   glm_vec4_sub(corners[GLM_LBF], corners[GLM_LBN], corner);

  0007a	8d 45 e0	 lea	 eax, DWORD PTR _corner$[ebp]
  0007d	50		 push	 eax
  0007e	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  00083	6b d1 00	 imul	 edx, ecx, 0
  00086	03 53 08	 add	 edx, DWORD PTR _corners$[ebx]
  00089	52		 push	 edx
  0008a	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  0008f	c1 e0 02	 shl	 eax, 2
  00092	03 43 08	 add	 eax, DWORD PTR _corners$[ebx]
  00095	50		 push	 eax
  00096	e8 00 00 00 00	 call	 _glm_vec4_sub
  0009b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 236  :   glm_vec4_scale_as(corner, sc, corner);

  0009e	8d 45 e0	 lea	 eax, DWORD PTR _corner$[ebp]
  000a1	50		 push	 eax
  000a2	51		 push	 ecx
  000a3	f3 0f 10 45 c8	 movss	 xmm0, DWORD PTR _sc$[ebp]
  000a8	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000ad	8d 4d e0	 lea	 ecx, DWORD PTR _corner$[ebp]
  000b0	51		 push	 ecx
  000b1	e8 00 00 00 00	 call	 _glm_vec4_scale_as
  000b6	83 c4 0c	 add	 esp, 12			; 0000000cH

; 237  :   glm_vec4_add(corners[GLM_LBN], corner, planeCorners[0]);

  000b9	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  000be	6b c8 00	 imul	 ecx, eax, 0
  000c1	03 4b 14	 add	 ecx, DWORD PTR _planeCorners$[ebx]
  000c4	51		 push	 ecx
  000c5	8d 55 e0	 lea	 edx, DWORD PTR _corner$[ebp]
  000c8	52		 push	 edx
  000c9	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  000ce	6b c8 00	 imul	 ecx, eax, 0
  000d1	03 4b 08	 add	 ecx, DWORD PTR _corners$[ebx]
  000d4	51		 push	 ecx
  000d5	e8 00 00 00 00	 call	 _glm_vec4_add
  000da	83 c4 0c	 add	 esp, 12			; 0000000cH

; 238  : 
; 239  :   /* left top */
; 240  :   glm_vec4_sub(corners[GLM_LTF], corners[GLM_LTN], corner);

  000dd	8d 45 e0	 lea	 eax, DWORD PTR _corner$[ebp]
  000e0	50		 push	 eax
  000e1	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  000e6	c1 e1 00	 shl	 ecx, 0
  000e9	03 4b 08	 add	 ecx, DWORD PTR _corners$[ebx]
  000ec	51		 push	 ecx
  000ed	ba 10 00 00 00	 mov	 edx, 16			; 00000010H
  000f2	6b c2 05	 imul	 eax, edx, 5
  000f5	03 43 08	 add	 eax, DWORD PTR _corners$[ebx]
  000f8	50		 push	 eax
  000f9	e8 00 00 00 00	 call	 _glm_vec4_sub
  000fe	83 c4 0c	 add	 esp, 12			; 0000000cH

; 241  :   glm_vec4_scale_as(corner, sc, corner);

  00101	8d 45 e0	 lea	 eax, DWORD PTR _corner$[ebp]
  00104	50		 push	 eax
  00105	51		 push	 ecx
  00106	f3 0f 10 45 c8	 movss	 xmm0, DWORD PTR _sc$[ebp]
  0010b	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00110	8d 4d e0	 lea	 ecx, DWORD PTR _corner$[ebp]
  00113	51		 push	 ecx
  00114	e8 00 00 00 00	 call	 _glm_vec4_scale_as
  00119	83 c4 0c	 add	 esp, 12			; 0000000cH

; 242  :   glm_vec4_add(corners[GLM_LTN], corner, planeCorners[1]);

  0011c	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  00121	c1 e0 00	 shl	 eax, 0
  00124	03 43 14	 add	 eax, DWORD PTR _planeCorners$[ebx]
  00127	50		 push	 eax
  00128	8d 4d e0	 lea	 ecx, DWORD PTR _corner$[ebp]
  0012b	51		 push	 ecx
  0012c	ba 10 00 00 00	 mov	 edx, 16			; 00000010H
  00131	c1 e2 00	 shl	 edx, 0
  00134	03 53 08	 add	 edx, DWORD PTR _corners$[ebx]
  00137	52		 push	 edx
  00138	e8 00 00 00 00	 call	 _glm_vec4_add
  0013d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 243  : 
; 244  :   /* right top */
; 245  :   glm_vec4_sub(corners[GLM_RTF], corners[GLM_RTN], corner);

  00140	8d 45 e0	 lea	 eax, DWORD PTR _corner$[ebp]
  00143	50		 push	 eax
  00144	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  00149	d1 e1		 shl	 ecx, 1
  0014b	03 4b 08	 add	 ecx, DWORD PTR _corners$[ebx]
  0014e	51		 push	 ecx
  0014f	ba 10 00 00 00	 mov	 edx, 16			; 00000010H
  00154	6b c2 06	 imul	 eax, edx, 6
  00157	03 43 08	 add	 eax, DWORD PTR _corners$[ebx]
  0015a	50		 push	 eax
  0015b	e8 00 00 00 00	 call	 _glm_vec4_sub
  00160	83 c4 0c	 add	 esp, 12			; 0000000cH

; 246  :   glm_vec4_scale_as(corner, sc, corner);

  00163	8d 45 e0	 lea	 eax, DWORD PTR _corner$[ebp]
  00166	50		 push	 eax
  00167	51		 push	 ecx
  00168	f3 0f 10 45 c8	 movss	 xmm0, DWORD PTR _sc$[ebp]
  0016d	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00172	8d 4d e0	 lea	 ecx, DWORD PTR _corner$[ebp]
  00175	51		 push	 ecx
  00176	e8 00 00 00 00	 call	 _glm_vec4_scale_as
  0017b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 247  :   glm_vec4_add(corners[GLM_RTN], corner, planeCorners[2]);

  0017e	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  00183	d1 e0		 shl	 eax, 1
  00185	03 43 14	 add	 eax, DWORD PTR _planeCorners$[ebx]
  00188	50		 push	 eax
  00189	8d 4d e0	 lea	 ecx, DWORD PTR _corner$[ebp]
  0018c	51		 push	 ecx
  0018d	ba 10 00 00 00	 mov	 edx, 16			; 00000010H
  00192	d1 e2		 shl	 edx, 1
  00194	03 53 08	 add	 edx, DWORD PTR _corners$[ebx]
  00197	52		 push	 edx
  00198	e8 00 00 00 00	 call	 _glm_vec4_add
  0019d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 248  : 
; 249  :   /* right bottom */
; 250  :   glm_vec4_sub(corners[GLM_RBF], corners[GLM_RBN], corner);

  001a0	8d 45 e0	 lea	 eax, DWORD PTR _corner$[ebp]
  001a3	50		 push	 eax
  001a4	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  001a9	6b d1 03	 imul	 edx, ecx, 3
  001ac	03 53 08	 add	 edx, DWORD PTR _corners$[ebx]
  001af	52		 push	 edx
  001b0	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  001b5	6b c8 07	 imul	 ecx, eax, 7
  001b8	03 4b 08	 add	 ecx, DWORD PTR _corners$[ebx]
  001bb	51		 push	 ecx
  001bc	e8 00 00 00 00	 call	 _glm_vec4_sub
  001c1	83 c4 0c	 add	 esp, 12			; 0000000cH

; 251  :   glm_vec4_scale_as(corner, sc, corner);

  001c4	8d 45 e0	 lea	 eax, DWORD PTR _corner$[ebp]
  001c7	50		 push	 eax
  001c8	51		 push	 ecx
  001c9	f3 0f 10 45 c8	 movss	 xmm0, DWORD PTR _sc$[ebp]
  001ce	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001d3	8d 4d e0	 lea	 ecx, DWORD PTR _corner$[ebp]
  001d6	51		 push	 ecx
  001d7	e8 00 00 00 00	 call	 _glm_vec4_scale_as
  001dc	83 c4 0c	 add	 esp, 12			; 0000000cH

; 252  :   glm_vec4_add(corners[GLM_RBN], corner, planeCorners[3]);

  001df	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  001e4	6b c8 03	 imul	 ecx, eax, 3
  001e7	03 4b 14	 add	 ecx, DWORD PTR _planeCorners$[ebx]
  001ea	51		 push	 ecx
  001eb	8d 55 e0	 lea	 edx, DWORD PTR _corner$[ebp]
  001ee	52		 push	 edx
  001ef	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  001f4	6b c8 03	 imul	 ecx, eax, 3
  001f7	03 4b 08	 add	 ecx, DWORD PTR _corners$[ebx]
  001fa	51		 push	 ecx
  001fb	e8 00 00 00 00	 call	 _glm_vec4_add
  00200	83 c4 0c	 add	 esp, 12			; 0000000cH

; 253  : }

  00203	52		 push	 edx
  00204	8b cd		 mov	 ecx, ebp
  00206	50		 push	 eax
  00207	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN5@glm_frustu
  0020d	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00212	58		 pop	 eax
  00213	5a		 pop	 edx
  00214	5f		 pop	 edi
  00215	5e		 pop	 esi
  00216	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00219	33 cd		 xor	 ecx, ebp
  0021b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00220	8b e5		 mov	 esp, ebp
  00222	5d		 pop	 ebp
  00223	8b e3		 mov	 esp, ebx
  00225	5b		 pop	 ebx
  00226	c3		 ret	 0
  00227	90		 npad	 1
$LN5@glm_frustu:
  00228	01 00 00 00	 DD	 1
  0022c	00 00 00 00	 DD	 $LN4@glm_frustu
$LN4@glm_frustu:
  00230	e0 ff ff ff	 DD	 -32			; ffffffe0H
  00234	10 00 00 00	 DD	 16			; 00000010H
  00238	00 00 00 00	 DD	 $LN3@glm_frustu
$LN3@glm_frustu:
  0023c	63		 DB	 99			; 00000063H
  0023d	6f		 DB	 111			; 0000006fH
  0023e	72		 DB	 114			; 00000072H
  0023f	6e		 DB	 110			; 0000006eH
  00240	65		 DB	 101			; 00000065H
  00241	72		 DB	 114			; 00000072H
  00242	00		 DB	 0
_glm_frustum_corners_at ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Light\source\repos\3DRendC\include\frustum.h
;	COMDAT _glm_frustum_box
_TEXT	SEGMENT
_i$ = -84						; size = 4
_max$ = -72						; size = 12
_min$ = -52						; size = 12
_v$ = -32						; size = 16
__$ArrayPad$ = -4					; size = 4
_corners$ = 8						; size = 4
_m$ = 12						; size = 4
_box$ = 16						; size = 4
_glm_frustum_box PROC					; COMDAT

; 185  : glm_frustum_box(vec4 corners[8], mat4 m, vec3 box[2]) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 f0	 and	 esp, -16		; fffffff0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec 18 01 00
	00		 sub	 esp, 280		; 00000118H
  0001c	56		 push	 esi
  0001d	57		 push	 edi
  0001e	8d bd e8 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-280]
  00024	b9 46 00 00 00	 mov	 ecx, 70			; 00000046H
  00029	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002e	f3 ab		 rep stosd
  00030	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00035	33 c5		 xor	 eax, ebp
  00037	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0003a	b9 00 00 00 00	 mov	 ecx, OFFSET __26922CBA_frustum@h
  0003f	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 186  :   vec4 v;
; 187  :   vec3 min, max;
; 188  :   int  i;
; 189  : 
; 190  :   glm_vec3_broadcast(FLT_MAX, min);

  00044	8d 45 cc	 lea	 eax, DWORD PTR _min$[ebp]
  00047	50		 push	 eax
  00048	51		 push	 ecx
  00049	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@7f7fffff
  00051	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00056	e8 00 00 00 00	 call	 _glm_vec3_broadcast
  0005b	83 c4 08	 add	 esp, 8

; 191  :   glm_vec3_broadcast(-FLT_MAX, max);

  0005e	8d 45 b8	 lea	 eax, DWORD PTR _max$[ebp]
  00061	50		 push	 eax
  00062	51		 push	 ecx
  00063	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@ff7fffff
  0006b	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00070	e8 00 00 00 00	 call	 _glm_vec3_broadcast
  00075	83 c4 08	 add	 esp, 8

; 192  : 
; 193  :   for (i = 0; i < 8; i++) {

  00078	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0007f	eb 09		 jmp	 SHORT $LN4@glm_frustu
$LN2@glm_frustu:
  00081	8b 45 ac	 mov	 eax, DWORD PTR _i$[ebp]
  00084	83 c0 01	 add	 eax, 1
  00087	89 45 ac	 mov	 DWORD PTR _i$[ebp], eax
$LN4@glm_frustu:
  0008a	83 7d ac 08	 cmp	 DWORD PTR _i$[ebp], 8
  0008e	0f 8d 81 01 00
	00		 jge	 $LN3@glm_frustu

; 194  :     glm_mat4_mulv(m, corners[i], v);

  00094	8d 45 e0	 lea	 eax, DWORD PTR _v$[ebp]
  00097	50		 push	 eax
  00098	8b 4d ac	 mov	 ecx, DWORD PTR _i$[ebp]
  0009b	c1 e1 04	 shl	 ecx, 4
  0009e	03 4b 08	 add	 ecx, DWORD PTR _corners$[ebx]
  000a1	51		 push	 ecx
  000a2	8b 53 0c	 mov	 edx, DWORD PTR _m$[ebx]
  000a5	52		 push	 edx
  000a6	e8 00 00 00 00	 call	 _glm_mat4_mulv
  000ab	83 c4 0c	 add	 esp, 12			; 0000000cH

; 195  : 
; 196  :     min[0] = glm_min(min[0], v[0]);

  000ae	b8 04 00 00 00	 mov	 eax, 4
  000b3	6b c8 00	 imul	 ecx, eax, 0
  000b6	51		 push	 ecx
  000b7	f3 0f 10 44 0d
	e0		 movss	 xmm0, DWORD PTR _v$[ebp+ecx]
  000bd	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000c2	ba 04 00 00 00	 mov	 edx, 4
  000c7	6b c2 00	 imul	 eax, edx, 0
  000ca	51		 push	 ecx
  000cb	f3 0f 10 44 05
	cc		 movss	 xmm0, DWORD PTR _min$[ebp+eax]
  000d1	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000d6	e8 00 00 00 00	 call	 _glm_min
  000db	83 c4 08	 add	 esp, 8
  000de	b9 04 00 00 00	 mov	 ecx, 4
  000e3	6b d1 00	 imul	 edx, ecx, 0
  000e6	d9 5c 15 cc	 fstp	 DWORD PTR _min$[ebp+edx]

; 197  :     min[1] = glm_min(min[1], v[1]);

  000ea	b8 04 00 00 00	 mov	 eax, 4
  000ef	c1 e0 00	 shl	 eax, 0
  000f2	51		 push	 ecx
  000f3	f3 0f 10 44 05
	e0		 movss	 xmm0, DWORD PTR _v$[ebp+eax]
  000f9	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000fe	b9 04 00 00 00	 mov	 ecx, 4
  00103	c1 e1 00	 shl	 ecx, 0
  00106	51		 push	 ecx
  00107	f3 0f 10 44 0d
	cc		 movss	 xmm0, DWORD PTR _min$[ebp+ecx]
  0010d	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00112	e8 00 00 00 00	 call	 _glm_min
  00117	83 c4 08	 add	 esp, 8
  0011a	ba 04 00 00 00	 mov	 edx, 4
  0011f	c1 e2 00	 shl	 edx, 0
  00122	d9 5c 15 cc	 fstp	 DWORD PTR _min$[ebp+edx]

; 198  :     min[2] = glm_min(min[2], v[2]);

  00126	b8 04 00 00 00	 mov	 eax, 4
  0012b	d1 e0		 shl	 eax, 1
  0012d	51		 push	 ecx
  0012e	f3 0f 10 44 05
	e0		 movss	 xmm0, DWORD PTR _v$[ebp+eax]
  00134	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00139	b9 04 00 00 00	 mov	 ecx, 4
  0013e	d1 e1		 shl	 ecx, 1
  00140	51		 push	 ecx
  00141	f3 0f 10 44 0d
	cc		 movss	 xmm0, DWORD PTR _min$[ebp+ecx]
  00147	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0014c	e8 00 00 00 00	 call	 _glm_min
  00151	83 c4 08	 add	 esp, 8
  00154	ba 04 00 00 00	 mov	 edx, 4
  00159	d1 e2		 shl	 edx, 1
  0015b	d9 5c 15 cc	 fstp	 DWORD PTR _min$[ebp+edx]

; 199  : 
; 200  :     max[0] = glm_max(max[0], v[0]);

  0015f	b8 04 00 00 00	 mov	 eax, 4
  00164	6b c8 00	 imul	 ecx, eax, 0
  00167	51		 push	 ecx
  00168	f3 0f 10 44 0d
	e0		 movss	 xmm0, DWORD PTR _v$[ebp+ecx]
  0016e	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00173	ba 04 00 00 00	 mov	 edx, 4
  00178	6b c2 00	 imul	 eax, edx, 0
  0017b	51		 push	 ecx
  0017c	f3 0f 10 44 05
	b8		 movss	 xmm0, DWORD PTR _max$[ebp+eax]
  00182	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00187	e8 00 00 00 00	 call	 _glm_max
  0018c	83 c4 08	 add	 esp, 8
  0018f	b9 04 00 00 00	 mov	 ecx, 4
  00194	6b d1 00	 imul	 edx, ecx, 0
  00197	d9 5c 15 b8	 fstp	 DWORD PTR _max$[ebp+edx]

; 201  :     max[1] = glm_max(max[1], v[1]);

  0019b	b8 04 00 00 00	 mov	 eax, 4
  001a0	c1 e0 00	 shl	 eax, 0
  001a3	51		 push	 ecx
  001a4	f3 0f 10 44 05
	e0		 movss	 xmm0, DWORD PTR _v$[ebp+eax]
  001aa	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001af	b9 04 00 00 00	 mov	 ecx, 4
  001b4	c1 e1 00	 shl	 ecx, 0
  001b7	51		 push	 ecx
  001b8	f3 0f 10 44 0d
	b8		 movss	 xmm0, DWORD PTR _max$[ebp+ecx]
  001be	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001c3	e8 00 00 00 00	 call	 _glm_max
  001c8	83 c4 08	 add	 esp, 8
  001cb	ba 04 00 00 00	 mov	 edx, 4
  001d0	c1 e2 00	 shl	 edx, 0
  001d3	d9 5c 15 b8	 fstp	 DWORD PTR _max$[ebp+edx]

; 202  :     max[2] = glm_max(max[2], v[2]);

  001d7	b8 04 00 00 00	 mov	 eax, 4
  001dc	d1 e0		 shl	 eax, 1
  001de	51		 push	 ecx
  001df	f3 0f 10 44 05
	e0		 movss	 xmm0, DWORD PTR _v$[ebp+eax]
  001e5	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001ea	b9 04 00 00 00	 mov	 ecx, 4
  001ef	d1 e1		 shl	 ecx, 1
  001f1	51		 push	 ecx
  001f2	f3 0f 10 44 0d
	b8		 movss	 xmm0, DWORD PTR _max$[ebp+ecx]
  001f8	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001fd	e8 00 00 00 00	 call	 _glm_max
  00202	83 c4 08	 add	 esp, 8
  00205	ba 04 00 00 00	 mov	 edx, 4
  0020a	d1 e2		 shl	 edx, 1
  0020c	d9 5c 15 b8	 fstp	 DWORD PTR _max$[ebp+edx]

; 203  :   }

  00210	e9 6c fe ff ff	 jmp	 $LN2@glm_frustu
$LN3@glm_frustu:

; 204  : 
; 205  :   glm_vec3_copy(min, box[0]);

  00215	b8 0c 00 00 00	 mov	 eax, 12			; 0000000cH
  0021a	6b c8 00	 imul	 ecx, eax, 0
  0021d	03 4b 10	 add	 ecx, DWORD PTR _box$[ebx]
  00220	51		 push	 ecx
  00221	8d 55 cc	 lea	 edx, DWORD PTR _min$[ebp]
  00224	52		 push	 edx
  00225	e8 00 00 00 00	 call	 _glm_vec3_copy
  0022a	83 c4 08	 add	 esp, 8

; 206  :   glm_vec3_copy(max, box[1]);

  0022d	b8 0c 00 00 00	 mov	 eax, 12			; 0000000cH
  00232	c1 e0 00	 shl	 eax, 0
  00235	03 43 10	 add	 eax, DWORD PTR _box$[ebx]
  00238	50		 push	 eax
  00239	8d 4d b8	 lea	 ecx, DWORD PTR _max$[ebp]
  0023c	51		 push	 ecx
  0023d	e8 00 00 00 00	 call	 _glm_vec3_copy
  00242	83 c4 08	 add	 esp, 8

; 207  : }

  00245	52		 push	 edx
  00246	8b cd		 mov	 ecx, ebp
  00248	50		 push	 eax
  00249	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN10@glm_frustu
  0024f	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00254	58		 pop	 eax
  00255	5a		 pop	 edx
  00256	5f		 pop	 edi
  00257	5e		 pop	 esi
  00258	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0025b	33 cd		 xor	 ecx, ebp
  0025d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00262	8b e5		 mov	 esp, ebp
  00264	5d		 pop	 ebp
  00265	8b e3		 mov	 esp, ebx
  00267	5b		 pop	 ebx
  00268	c3		 ret	 0
  00269	0f 1f 00	 npad	 3
$LN10@glm_frustu:
  0026c	03 00 00 00	 DD	 3
  00270	00 00 00 00	 DD	 $LN9@glm_frustu
$LN9@glm_frustu:
  00274	e0 ff ff ff	 DD	 -32			; ffffffe0H
  00278	10 00 00 00	 DD	 16			; 00000010H
  0027c	00 00 00 00	 DD	 $LN6@glm_frustu
  00280	cc ff ff ff	 DD	 -52			; ffffffccH
  00284	0c 00 00 00	 DD	 12			; 0000000cH
  00288	00 00 00 00	 DD	 $LN7@glm_frustu
  0028c	b8 ff ff ff	 DD	 -72			; ffffffb8H
  00290	0c 00 00 00	 DD	 12			; 0000000cH
  00294	00 00 00 00	 DD	 $LN8@glm_frustu
$LN8@glm_frustu:
  00298	6d		 DB	 109			; 0000006dH
  00299	61		 DB	 97			; 00000061H
  0029a	78		 DB	 120			; 00000078H
  0029b	00		 DB	 0
$LN7@glm_frustu:
  0029c	6d		 DB	 109			; 0000006dH
  0029d	69		 DB	 105			; 00000069H
  0029e	6e		 DB	 110			; 0000006eH
  0029f	00		 DB	 0
$LN6@glm_frustu:
  002a0	76		 DB	 118			; 00000076H
  002a1	00		 DB	 0
_glm_frustum_box ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Light\source\repos\3DRendC\include\frustum.h
;	COMDAT _glm_frustum_center
_TEXT	SEGMENT
_center$ = -32						; size = 16
__$ArrayPad$ = -4					; size = 4
_corners$ = 8						; size = 4
_dest$ = 12						; size = 4
_glm_frustum_center PROC				; COMDAT

; 160  : glm_frustum_center(vec4 corners[8], vec4 dest) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 f0	 and	 esp, -16		; fffffff0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec e8 00 00
	00		 sub	 esp, 232		; 000000e8H
  0001c	56		 push	 esi
  0001d	57		 push	 edi
  0001e	8d bd 18 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-232]
  00024	b9 3a 00 00 00	 mov	 ecx, 58			; 0000003aH
  00029	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002e	f3 ab		 rep stosd
  00030	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00035	33 c5		 xor	 eax, ebp
  00037	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0003a	b9 00 00 00 00	 mov	 ecx, OFFSET __26922CBA_frustum@h
  0003f	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 161  :   vec4 center;
; 162  : 
; 163  :   glm_vec4_copy(corners[0], center);

  00044	8d 45 e0	 lea	 eax, DWORD PTR _center$[ebp]
  00047	50		 push	 eax
  00048	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  0004d	6b d1 00	 imul	 edx, ecx, 0
  00050	03 53 08	 add	 edx, DWORD PTR _corners$[ebx]
  00053	52		 push	 edx
  00054	e8 00 00 00 00	 call	 _glm_vec4_copy
  00059	83 c4 08	 add	 esp, 8

; 164  : 
; 165  :   glm_vec4_add(corners[1], center, center);

  0005c	8d 45 e0	 lea	 eax, DWORD PTR _center$[ebp]
  0005f	50		 push	 eax
  00060	8d 4d e0	 lea	 ecx, DWORD PTR _center$[ebp]
  00063	51		 push	 ecx
  00064	ba 10 00 00 00	 mov	 edx, 16			; 00000010H
  00069	c1 e2 00	 shl	 edx, 0
  0006c	03 53 08	 add	 edx, DWORD PTR _corners$[ebx]
  0006f	52		 push	 edx
  00070	e8 00 00 00 00	 call	 _glm_vec4_add
  00075	83 c4 0c	 add	 esp, 12			; 0000000cH

; 166  :   glm_vec4_add(corners[2], center, center);

  00078	8d 45 e0	 lea	 eax, DWORD PTR _center$[ebp]
  0007b	50		 push	 eax
  0007c	8d 4d e0	 lea	 ecx, DWORD PTR _center$[ebp]
  0007f	51		 push	 ecx
  00080	ba 10 00 00 00	 mov	 edx, 16			; 00000010H
  00085	d1 e2		 shl	 edx, 1
  00087	03 53 08	 add	 edx, DWORD PTR _corners$[ebx]
  0008a	52		 push	 edx
  0008b	e8 00 00 00 00	 call	 _glm_vec4_add
  00090	83 c4 0c	 add	 esp, 12			; 0000000cH

; 167  :   glm_vec4_add(corners[3], center, center);

  00093	8d 45 e0	 lea	 eax, DWORD PTR _center$[ebp]
  00096	50		 push	 eax
  00097	8d 4d e0	 lea	 ecx, DWORD PTR _center$[ebp]
  0009a	51		 push	 ecx
  0009b	ba 10 00 00 00	 mov	 edx, 16			; 00000010H
  000a0	6b c2 03	 imul	 eax, edx, 3
  000a3	03 43 08	 add	 eax, DWORD PTR _corners$[ebx]
  000a6	50		 push	 eax
  000a7	e8 00 00 00 00	 call	 _glm_vec4_add
  000ac	83 c4 0c	 add	 esp, 12			; 0000000cH

; 168  :   glm_vec4_add(corners[4], center, center);

  000af	8d 45 e0	 lea	 eax, DWORD PTR _center$[ebp]
  000b2	50		 push	 eax
  000b3	8d 4d e0	 lea	 ecx, DWORD PTR _center$[ebp]
  000b6	51		 push	 ecx
  000b7	ba 10 00 00 00	 mov	 edx, 16			; 00000010H
  000bc	c1 e2 02	 shl	 edx, 2
  000bf	03 53 08	 add	 edx, DWORD PTR _corners$[ebx]
  000c2	52		 push	 edx
  000c3	e8 00 00 00 00	 call	 _glm_vec4_add
  000c8	83 c4 0c	 add	 esp, 12			; 0000000cH

; 169  :   glm_vec4_add(corners[5], center, center);

  000cb	8d 45 e0	 lea	 eax, DWORD PTR _center$[ebp]
  000ce	50		 push	 eax
  000cf	8d 4d e0	 lea	 ecx, DWORD PTR _center$[ebp]
  000d2	51		 push	 ecx
  000d3	ba 10 00 00 00	 mov	 edx, 16			; 00000010H
  000d8	6b c2 05	 imul	 eax, edx, 5
  000db	03 43 08	 add	 eax, DWORD PTR _corners$[ebx]
  000de	50		 push	 eax
  000df	e8 00 00 00 00	 call	 _glm_vec4_add
  000e4	83 c4 0c	 add	 esp, 12			; 0000000cH

; 170  :   glm_vec4_add(corners[6], center, center);

  000e7	8d 45 e0	 lea	 eax, DWORD PTR _center$[ebp]
  000ea	50		 push	 eax
  000eb	8d 4d e0	 lea	 ecx, DWORD PTR _center$[ebp]
  000ee	51		 push	 ecx
  000ef	ba 10 00 00 00	 mov	 edx, 16			; 00000010H
  000f4	6b c2 06	 imul	 eax, edx, 6
  000f7	03 43 08	 add	 eax, DWORD PTR _corners$[ebx]
  000fa	50		 push	 eax
  000fb	e8 00 00 00 00	 call	 _glm_vec4_add
  00100	83 c4 0c	 add	 esp, 12			; 0000000cH

; 171  :   glm_vec4_add(corners[7], center, center);

  00103	8d 45 e0	 lea	 eax, DWORD PTR _center$[ebp]
  00106	50		 push	 eax
  00107	8d 4d e0	 lea	 ecx, DWORD PTR _center$[ebp]
  0010a	51		 push	 ecx
  0010b	ba 10 00 00 00	 mov	 edx, 16			; 00000010H
  00110	6b c2 07	 imul	 eax, edx, 7
  00113	03 43 08	 add	 eax, DWORD PTR _corners$[ebx]
  00116	50		 push	 eax
  00117	e8 00 00 00 00	 call	 _glm_vec4_add
  0011c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 172  : 
; 173  :   glm_vec4_scale(center, 0.125f, dest);

  0011f	8b 43 0c	 mov	 eax, DWORD PTR _dest$[ebx]
  00122	50		 push	 eax
  00123	51		 push	 ecx
  00124	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3e000000
  0012c	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00131	8d 4d e0	 lea	 ecx, DWORD PTR _center$[ebp]
  00134	51		 push	 ecx
  00135	e8 00 00 00 00	 call	 _glm_vec4_scale
  0013a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 174  : }

  0013d	52		 push	 edx
  0013e	8b cd		 mov	 ecx, ebp
  00140	50		 push	 eax
  00141	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN5@glm_frustu
  00147	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  0014c	58		 pop	 eax
  0014d	5a		 pop	 edx
  0014e	5f		 pop	 edi
  0014f	5e		 pop	 esi
  00150	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00153	33 cd		 xor	 ecx, ebp
  00155	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0015a	8b e5		 mov	 esp, ebp
  0015c	5d		 pop	 ebp
  0015d	8b e3		 mov	 esp, ebx
  0015f	5b		 pop	 ebx
  00160	c3		 ret	 0
  00161	0f 1f 00	 npad	 3
$LN5@glm_frustu:
  00164	01 00 00 00	 DD	 1
  00168	00 00 00 00	 DD	 $LN4@glm_frustu
$LN4@glm_frustu:
  0016c	e0 ff ff ff	 DD	 -32			; ffffffe0H
  00170	10 00 00 00	 DD	 16			; 00000010H
  00174	00 00 00 00	 DD	 $LN3@glm_frustu
$LN3@glm_frustu:
  00178	63		 DB	 99			; 00000063H
  00179	65		 DB	 101			; 00000065H
  0017a	6e		 DB	 110			; 0000006eH
  0017b	74		 DB	 116			; 00000074H
  0017c	65		 DB	 101			; 00000065H
  0017d	72		 DB	 114			; 00000072H
  0017e	00		 DB	 0
_glm_frustum_center ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Light\source\repos\3DRendC\include\frustum.h
;	COMDAT _glm_frustum_corners
_TEXT	SEGMENT
_csCoords$ = -288					; size = 128
_c$ = -144						; size = 128
__$ArrayPad$ = -4					; size = 4
_invMat$ = 8						; size = 4
_dest$ = 12						; size = 4
_glm_frustum_corners PROC				; COMDAT

; 117  : glm_frustum_corners(mat4 invMat, vec4 dest[8]) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 f0	 and	 esp, -16		; fffffff0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec e8 01 00
	00		 sub	 esp, 488		; 000001e8H
  0001c	56		 push	 esi
  0001d	57		 push	 edi
  0001e	8d bd 18 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-488]
  00024	b9 7a 00 00 00	 mov	 ecx, 122		; 0000007aH
  00029	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002e	f3 ab		 rep stosd
  00030	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00035	33 c5		 xor	 eax, ebp
  00037	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0003a	b9 00 00 00 00	 mov	 ecx, OFFSET __26922CBA_frustum@h
  0003f	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 118  :   vec4 c[8];
; 119  : 
; 120  :   /* indexOf(nearCoord) = indexOf(farCoord) + 4 */
; 121  :   vec4 csCoords[8] = {

  00044	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@bf800000
  0004c	f3 0f 11 85 e0
	fe ff ff	 movss	 DWORD PTR _csCoords$[ebp], xmm0
  00054	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@bf800000
  0005c	f3 0f 11 85 e4
	fe ff ff	 movss	 DWORD PTR _csCoords$[ebp+4], xmm0
  00064	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@bf800000
  0006c	f3 0f 11 85 e8
	fe ff ff	 movss	 DWORD PTR _csCoords$[ebp+8], xmm0
  00074	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  0007c	f3 0f 11 85 ec
	fe ff ff	 movss	 DWORD PTR _csCoords$[ebp+12], xmm0
  00084	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@bf800000
  0008c	f3 0f 11 85 f0
	fe ff ff	 movss	 DWORD PTR _csCoords$[ebp+16], xmm0
  00094	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  0009c	f3 0f 11 85 f4
	fe ff ff	 movss	 DWORD PTR _csCoords$[ebp+20], xmm0
  000a4	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@bf800000
  000ac	f3 0f 11 85 f8
	fe ff ff	 movss	 DWORD PTR _csCoords$[ebp+24], xmm0
  000b4	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  000bc	f3 0f 11 85 fc
	fe ff ff	 movss	 DWORD PTR _csCoords$[ebp+28], xmm0
  000c4	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  000cc	f3 0f 11 85 00
	ff ff ff	 movss	 DWORD PTR _csCoords$[ebp+32], xmm0
  000d4	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  000dc	f3 0f 11 85 04
	ff ff ff	 movss	 DWORD PTR _csCoords$[ebp+36], xmm0
  000e4	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@bf800000
  000ec	f3 0f 11 85 08
	ff ff ff	 movss	 DWORD PTR _csCoords$[ebp+40], xmm0
  000f4	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  000fc	f3 0f 11 85 0c
	ff ff ff	 movss	 DWORD PTR _csCoords$[ebp+44], xmm0
  00104	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  0010c	f3 0f 11 85 10
	ff ff ff	 movss	 DWORD PTR _csCoords$[ebp+48], xmm0
  00114	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@bf800000
  0011c	f3 0f 11 85 14
	ff ff ff	 movss	 DWORD PTR _csCoords$[ebp+52], xmm0
  00124	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@bf800000
  0012c	f3 0f 11 85 18
	ff ff ff	 movss	 DWORD PTR _csCoords$[ebp+56], xmm0
  00134	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  0013c	f3 0f 11 85 1c
	ff ff ff	 movss	 DWORD PTR _csCoords$[ebp+60], xmm0
  00144	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@bf800000
  0014c	f3 0f 11 85 20
	ff ff ff	 movss	 DWORD PTR _csCoords$[ebp+64], xmm0
  00154	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@bf800000
  0015c	f3 0f 11 85 24
	ff ff ff	 movss	 DWORD PTR _csCoords$[ebp+68], xmm0
  00164	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  0016c	f3 0f 11 85 28
	ff ff ff	 movss	 DWORD PTR _csCoords$[ebp+72], xmm0
  00174	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  0017c	f3 0f 11 85 2c
	ff ff ff	 movss	 DWORD PTR _csCoords$[ebp+76], xmm0
  00184	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@bf800000
  0018c	f3 0f 11 85 30
	ff ff ff	 movss	 DWORD PTR _csCoords$[ebp+80], xmm0
  00194	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  0019c	f3 0f 11 85 34
	ff ff ff	 movss	 DWORD PTR _csCoords$[ebp+84], xmm0
  001a4	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  001ac	f3 0f 11 85 38
	ff ff ff	 movss	 DWORD PTR _csCoords$[ebp+88], xmm0
  001b4	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  001bc	f3 0f 11 85 3c
	ff ff ff	 movss	 DWORD PTR _csCoords$[ebp+92], xmm0
  001c4	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  001cc	f3 0f 11 85 40
	ff ff ff	 movss	 DWORD PTR _csCoords$[ebp+96], xmm0
  001d4	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  001dc	f3 0f 11 85 44
	ff ff ff	 movss	 DWORD PTR _csCoords$[ebp+100], xmm0
  001e4	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  001ec	f3 0f 11 85 48
	ff ff ff	 movss	 DWORD PTR _csCoords$[ebp+104], xmm0
  001f4	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  001fc	f3 0f 11 85 4c
	ff ff ff	 movss	 DWORD PTR _csCoords$[ebp+108], xmm0
  00204	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  0020c	f3 0f 11 85 50
	ff ff ff	 movss	 DWORD PTR _csCoords$[ebp+112], xmm0
  00214	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@bf800000
  0021c	f3 0f 11 85 54
	ff ff ff	 movss	 DWORD PTR _csCoords$[ebp+116], xmm0
  00224	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  0022c	f3 0f 11 85 58
	ff ff ff	 movss	 DWORD PTR _csCoords$[ebp+120], xmm0
  00234	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  0023c	f3 0f 11 85 5c
	ff ff ff	 movss	 DWORD PTR _csCoords$[ebp+124], xmm0

; 122  :     GLM_CSCOORD_LBN,
; 123  :     GLM_CSCOORD_LTN,
; 124  :     GLM_CSCOORD_RTN,
; 125  :     GLM_CSCOORD_RBN,
; 126  : 
; 127  :     GLM_CSCOORD_LBF,
; 128  :     GLM_CSCOORD_LTF,
; 129  :     GLM_CSCOORD_RTF,
; 130  :     GLM_CSCOORD_RBF
; 131  :   };
; 132  : 
; 133  :   glm_mat4_mulv(invMat, csCoords[0], c[0]);

  00244	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  00249	6b c8 00	 imul	 ecx, eax, 0
  0024c	8d 94 0d 70 ff
	ff ff		 lea	 edx, DWORD PTR _c$[ebp+ecx]
  00253	52		 push	 edx
  00254	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  00259	6b c8 00	 imul	 ecx, eax, 0
  0025c	8d 94 0d e0 fe
	ff ff		 lea	 edx, DWORD PTR _csCoords$[ebp+ecx]
  00263	52		 push	 edx
  00264	8b 43 08	 mov	 eax, DWORD PTR _invMat$[ebx]
  00267	50		 push	 eax
  00268	e8 00 00 00 00	 call	 _glm_mat4_mulv
  0026d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 134  :   glm_mat4_mulv(invMat, csCoords[1], c[1]);

  00270	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  00275	c1 e0 00	 shl	 eax, 0
  00278	8d 8c 05 70 ff
	ff ff		 lea	 ecx, DWORD PTR _c$[ebp+eax]
  0027f	51		 push	 ecx
  00280	ba 10 00 00 00	 mov	 edx, 16			; 00000010H
  00285	c1 e2 00	 shl	 edx, 0
  00288	8d 84 15 e0 fe
	ff ff		 lea	 eax, DWORD PTR _csCoords$[ebp+edx]
  0028f	50		 push	 eax
  00290	8b 4b 08	 mov	 ecx, DWORD PTR _invMat$[ebx]
  00293	51		 push	 ecx
  00294	e8 00 00 00 00	 call	 _glm_mat4_mulv
  00299	83 c4 0c	 add	 esp, 12			; 0000000cH

; 135  :   glm_mat4_mulv(invMat, csCoords[2], c[2]);

  0029c	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  002a1	d1 e0		 shl	 eax, 1
  002a3	8d 8c 05 70 ff
	ff ff		 lea	 ecx, DWORD PTR _c$[ebp+eax]
  002aa	51		 push	 ecx
  002ab	ba 10 00 00 00	 mov	 edx, 16			; 00000010H
  002b0	d1 e2		 shl	 edx, 1
  002b2	8d 84 15 e0 fe
	ff ff		 lea	 eax, DWORD PTR _csCoords$[ebp+edx]
  002b9	50		 push	 eax
  002ba	8b 4b 08	 mov	 ecx, DWORD PTR _invMat$[ebx]
  002bd	51		 push	 ecx
  002be	e8 00 00 00 00	 call	 _glm_mat4_mulv
  002c3	83 c4 0c	 add	 esp, 12			; 0000000cH

; 136  :   glm_mat4_mulv(invMat, csCoords[3], c[3]);

  002c6	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  002cb	6b c8 03	 imul	 ecx, eax, 3
  002ce	8d 94 0d 70 ff
	ff ff		 lea	 edx, DWORD PTR _c$[ebp+ecx]
  002d5	52		 push	 edx
  002d6	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  002db	6b c8 03	 imul	 ecx, eax, 3
  002de	8d 94 0d e0 fe
	ff ff		 lea	 edx, DWORD PTR _csCoords$[ebp+ecx]
  002e5	52		 push	 edx
  002e6	8b 43 08	 mov	 eax, DWORD PTR _invMat$[ebx]
  002e9	50		 push	 eax
  002ea	e8 00 00 00 00	 call	 _glm_mat4_mulv
  002ef	83 c4 0c	 add	 esp, 12			; 0000000cH

; 137  :   glm_mat4_mulv(invMat, csCoords[4], c[4]);

  002f2	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  002f7	c1 e0 02	 shl	 eax, 2
  002fa	8d 8c 05 70 ff
	ff ff		 lea	 ecx, DWORD PTR _c$[ebp+eax]
  00301	51		 push	 ecx
  00302	ba 10 00 00 00	 mov	 edx, 16			; 00000010H
  00307	c1 e2 02	 shl	 edx, 2
  0030a	8d 84 15 e0 fe
	ff ff		 lea	 eax, DWORD PTR _csCoords$[ebp+edx]
  00311	50		 push	 eax
  00312	8b 4b 08	 mov	 ecx, DWORD PTR _invMat$[ebx]
  00315	51		 push	 ecx
  00316	e8 00 00 00 00	 call	 _glm_mat4_mulv
  0031b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 138  :   glm_mat4_mulv(invMat, csCoords[5], c[5]);

  0031e	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  00323	6b c8 05	 imul	 ecx, eax, 5
  00326	8d 94 0d 70 ff
	ff ff		 lea	 edx, DWORD PTR _c$[ebp+ecx]
  0032d	52		 push	 edx
  0032e	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  00333	6b c8 05	 imul	 ecx, eax, 5
  00336	8d 94 0d e0 fe
	ff ff		 lea	 edx, DWORD PTR _csCoords$[ebp+ecx]
  0033d	52		 push	 edx
  0033e	8b 43 08	 mov	 eax, DWORD PTR _invMat$[ebx]
  00341	50		 push	 eax
  00342	e8 00 00 00 00	 call	 _glm_mat4_mulv
  00347	83 c4 0c	 add	 esp, 12			; 0000000cH

; 139  :   glm_mat4_mulv(invMat, csCoords[6], c[6]);

  0034a	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  0034f	6b c8 06	 imul	 ecx, eax, 6
  00352	8d 94 0d 70 ff
	ff ff		 lea	 edx, DWORD PTR _c$[ebp+ecx]
  00359	52		 push	 edx
  0035a	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  0035f	6b c8 06	 imul	 ecx, eax, 6
  00362	8d 94 0d e0 fe
	ff ff		 lea	 edx, DWORD PTR _csCoords$[ebp+ecx]
  00369	52		 push	 edx
  0036a	8b 43 08	 mov	 eax, DWORD PTR _invMat$[ebx]
  0036d	50		 push	 eax
  0036e	e8 00 00 00 00	 call	 _glm_mat4_mulv
  00373	83 c4 0c	 add	 esp, 12			; 0000000cH

; 140  :   glm_mat4_mulv(invMat, csCoords[7], c[7]);

  00376	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  0037b	6b c8 07	 imul	 ecx, eax, 7
  0037e	8d 94 0d 70 ff
	ff ff		 lea	 edx, DWORD PTR _c$[ebp+ecx]
  00385	52		 push	 edx
  00386	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  0038b	6b c8 07	 imul	 ecx, eax, 7
  0038e	8d 94 0d e0 fe
	ff ff		 lea	 edx, DWORD PTR _csCoords$[ebp+ecx]
  00395	52		 push	 edx
  00396	8b 43 08	 mov	 eax, DWORD PTR _invMat$[ebx]
  00399	50		 push	 eax
  0039a	e8 00 00 00 00	 call	 _glm_mat4_mulv
  0039f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 141  : 
; 142  :   glm_vec4_scale(c[0], 1.0f / c[0][3], dest[0]);

  003a2	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  003a7	6b c8 00	 imul	 ecx, eax, 0
  003aa	03 4b 0c	 add	 ecx, DWORD PTR _dest$[ebx]
  003ad	51		 push	 ecx
  003ae	ba 10 00 00 00	 mov	 edx, 16			; 00000010H
  003b3	6b c2 00	 imul	 eax, edx, 0
  003b6	8d 8c 05 70 ff
	ff ff		 lea	 ecx, DWORD PTR _c$[ebp+eax]
  003bd	ba 04 00 00 00	 mov	 edx, 4
  003c2	6b c2 03	 imul	 eax, edx, 3
  003c5	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  003cd	f3 0f 5e 04 01	 divss	 xmm0, DWORD PTR [ecx+eax]
  003d2	51		 push	 ecx
  003d3	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  003d8	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  003dd	6b d1 00	 imul	 edx, ecx, 0
  003e0	8d 84 15 70 ff
	ff ff		 lea	 eax, DWORD PTR _c$[ebp+edx]
  003e7	50		 push	 eax
  003e8	e8 00 00 00 00	 call	 _glm_vec4_scale
  003ed	83 c4 0c	 add	 esp, 12			; 0000000cH

; 143  :   glm_vec4_scale(c[1], 1.0f / c[1][3], dest[1]);

  003f0	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  003f5	c1 e0 00	 shl	 eax, 0
  003f8	03 43 0c	 add	 eax, DWORD PTR _dest$[ebx]
  003fb	50		 push	 eax
  003fc	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  00401	c1 e1 00	 shl	 ecx, 0
  00404	8d 94 0d 70 ff
	ff ff		 lea	 edx, DWORD PTR _c$[ebp+ecx]
  0040b	b8 04 00 00 00	 mov	 eax, 4
  00410	6b c8 03	 imul	 ecx, eax, 3
  00413	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  0041b	f3 0f 5e 04 0a	 divss	 xmm0, DWORD PTR [edx+ecx]
  00420	51		 push	 ecx
  00421	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00426	ba 10 00 00 00	 mov	 edx, 16			; 00000010H
  0042b	c1 e2 00	 shl	 edx, 0
  0042e	8d 84 15 70 ff
	ff ff		 lea	 eax, DWORD PTR _c$[ebp+edx]
  00435	50		 push	 eax
  00436	e8 00 00 00 00	 call	 _glm_vec4_scale
  0043b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 144  :   glm_vec4_scale(c[2], 1.0f / c[2][3], dest[2]);

  0043e	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  00443	d1 e0		 shl	 eax, 1
  00445	03 43 0c	 add	 eax, DWORD PTR _dest$[ebx]
  00448	50		 push	 eax
  00449	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  0044e	d1 e1		 shl	 ecx, 1
  00450	8d 94 0d 70 ff
	ff ff		 lea	 edx, DWORD PTR _c$[ebp+ecx]
  00457	b8 04 00 00 00	 mov	 eax, 4
  0045c	6b c8 03	 imul	 ecx, eax, 3
  0045f	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00467	f3 0f 5e 04 0a	 divss	 xmm0, DWORD PTR [edx+ecx]
  0046c	51		 push	 ecx
  0046d	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00472	ba 10 00 00 00	 mov	 edx, 16			; 00000010H
  00477	d1 e2		 shl	 edx, 1
  00479	8d 84 15 70 ff
	ff ff		 lea	 eax, DWORD PTR _c$[ebp+edx]
  00480	50		 push	 eax
  00481	e8 00 00 00 00	 call	 _glm_vec4_scale
  00486	83 c4 0c	 add	 esp, 12			; 0000000cH

; 145  :   glm_vec4_scale(c[3], 1.0f / c[3][3], dest[3]);

  00489	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  0048e	6b c8 03	 imul	 ecx, eax, 3
  00491	03 4b 0c	 add	 ecx, DWORD PTR _dest$[ebx]
  00494	51		 push	 ecx
  00495	ba 10 00 00 00	 mov	 edx, 16			; 00000010H
  0049a	6b c2 03	 imul	 eax, edx, 3
  0049d	8d 8c 05 70 ff
	ff ff		 lea	 ecx, DWORD PTR _c$[ebp+eax]
  004a4	ba 04 00 00 00	 mov	 edx, 4
  004a9	6b c2 03	 imul	 eax, edx, 3
  004ac	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  004b4	f3 0f 5e 04 01	 divss	 xmm0, DWORD PTR [ecx+eax]
  004b9	51		 push	 ecx
  004ba	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  004bf	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  004c4	6b d1 03	 imul	 edx, ecx, 3
  004c7	8d 84 15 70 ff
	ff ff		 lea	 eax, DWORD PTR _c$[ebp+edx]
  004ce	50		 push	 eax
  004cf	e8 00 00 00 00	 call	 _glm_vec4_scale
  004d4	83 c4 0c	 add	 esp, 12			; 0000000cH

; 146  :   glm_vec4_scale(c[4], 1.0f / c[4][3], dest[4]);

  004d7	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  004dc	c1 e0 02	 shl	 eax, 2
  004df	03 43 0c	 add	 eax, DWORD PTR _dest$[ebx]
  004e2	50		 push	 eax
  004e3	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  004e8	c1 e1 02	 shl	 ecx, 2
  004eb	8d 94 0d 70 ff
	ff ff		 lea	 edx, DWORD PTR _c$[ebp+ecx]
  004f2	b8 04 00 00 00	 mov	 eax, 4
  004f7	6b c8 03	 imul	 ecx, eax, 3
  004fa	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00502	f3 0f 5e 04 0a	 divss	 xmm0, DWORD PTR [edx+ecx]
  00507	51		 push	 ecx
  00508	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0050d	ba 10 00 00 00	 mov	 edx, 16			; 00000010H
  00512	c1 e2 02	 shl	 edx, 2
  00515	8d 84 15 70 ff
	ff ff		 lea	 eax, DWORD PTR _c$[ebp+edx]
  0051c	50		 push	 eax
  0051d	e8 00 00 00 00	 call	 _glm_vec4_scale
  00522	83 c4 0c	 add	 esp, 12			; 0000000cH

; 147  :   glm_vec4_scale(c[5], 1.0f / c[5][3], dest[5]);

  00525	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  0052a	6b c8 05	 imul	 ecx, eax, 5
  0052d	03 4b 0c	 add	 ecx, DWORD PTR _dest$[ebx]
  00530	51		 push	 ecx
  00531	ba 10 00 00 00	 mov	 edx, 16			; 00000010H
  00536	6b c2 05	 imul	 eax, edx, 5
  00539	8d 8c 05 70 ff
	ff ff		 lea	 ecx, DWORD PTR _c$[ebp+eax]
  00540	ba 04 00 00 00	 mov	 edx, 4
  00545	6b c2 03	 imul	 eax, edx, 3
  00548	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00550	f3 0f 5e 04 01	 divss	 xmm0, DWORD PTR [ecx+eax]
  00555	51		 push	 ecx
  00556	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0055b	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  00560	6b d1 05	 imul	 edx, ecx, 5
  00563	8d 84 15 70 ff
	ff ff		 lea	 eax, DWORD PTR _c$[ebp+edx]
  0056a	50		 push	 eax
  0056b	e8 00 00 00 00	 call	 _glm_vec4_scale
  00570	83 c4 0c	 add	 esp, 12			; 0000000cH

; 148  :   glm_vec4_scale(c[6], 1.0f / c[6][3], dest[6]);

  00573	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  00578	6b c8 06	 imul	 ecx, eax, 6
  0057b	03 4b 0c	 add	 ecx, DWORD PTR _dest$[ebx]
  0057e	51		 push	 ecx
  0057f	ba 10 00 00 00	 mov	 edx, 16			; 00000010H
  00584	6b c2 06	 imul	 eax, edx, 6
  00587	8d 8c 05 70 ff
	ff ff		 lea	 ecx, DWORD PTR _c$[ebp+eax]
  0058e	ba 04 00 00 00	 mov	 edx, 4
  00593	6b c2 03	 imul	 eax, edx, 3
  00596	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  0059e	f3 0f 5e 04 01	 divss	 xmm0, DWORD PTR [ecx+eax]
  005a3	51		 push	 ecx
  005a4	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  005a9	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  005ae	6b d1 06	 imul	 edx, ecx, 6
  005b1	8d 84 15 70 ff
	ff ff		 lea	 eax, DWORD PTR _c$[ebp+edx]
  005b8	50		 push	 eax
  005b9	e8 00 00 00 00	 call	 _glm_vec4_scale
  005be	83 c4 0c	 add	 esp, 12			; 0000000cH

; 149  :   glm_vec4_scale(c[7], 1.0f / c[7][3], dest[7]);

  005c1	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  005c6	6b c8 07	 imul	 ecx, eax, 7
  005c9	03 4b 0c	 add	 ecx, DWORD PTR _dest$[ebx]
  005cc	51		 push	 ecx
  005cd	ba 10 00 00 00	 mov	 edx, 16			; 00000010H
  005d2	6b c2 07	 imul	 eax, edx, 7
  005d5	8d 8c 05 70 ff
	ff ff		 lea	 ecx, DWORD PTR _c$[ebp+eax]
  005dc	ba 04 00 00 00	 mov	 edx, 4
  005e1	6b c2 03	 imul	 eax, edx, 3
  005e4	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  005ec	f3 0f 5e 04 01	 divss	 xmm0, DWORD PTR [ecx+eax]
  005f1	51		 push	 ecx
  005f2	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  005f7	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  005fc	6b d1 07	 imul	 edx, ecx, 7
  005ff	8d 84 15 70 ff
	ff ff		 lea	 eax, DWORD PTR _c$[ebp+edx]
  00606	50		 push	 eax
  00607	e8 00 00 00 00	 call	 _glm_vec4_scale
  0060c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 150  : }

  0060f	52		 push	 edx
  00610	8b cd		 mov	 ecx, ebp
  00612	50		 push	 eax
  00613	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN6@glm_frustu
  00619	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  0061e	58		 pop	 eax
  0061f	5a		 pop	 edx
  00620	5f		 pop	 edi
  00621	5e		 pop	 esi
  00622	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00625	33 cd		 xor	 ecx, ebp
  00627	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0062c	8b e5		 mov	 esp, ebp
  0062e	5d		 pop	 ebp
  0062f	8b e3		 mov	 esp, ebx
  00631	5b		 pop	 ebx
  00632	c3		 ret	 0
  00633	90		 npad	 1
$LN6@glm_frustu:
  00634	02 00 00 00	 DD	 2
  00638	00 00 00 00	 DD	 $LN5@glm_frustu
$LN5@glm_frustu:
  0063c	70 ff ff ff	 DD	 -144			; ffffff70H
  00640	80 00 00 00	 DD	 128			; 00000080H
  00644	00 00 00 00	 DD	 $LN3@glm_frustu
  00648	e0 fe ff ff	 DD	 -288			; fffffee0H
  0064c	80 00 00 00	 DD	 128			; 00000080H
  00650	00 00 00 00	 DD	 $LN4@glm_frustu
$LN4@glm_frustu:
  00654	63		 DB	 99			; 00000063H
  00655	73		 DB	 115			; 00000073H
  00656	43		 DB	 67			; 00000043H
  00657	6f		 DB	 111			; 0000006fH
  00658	6f		 DB	 111			; 0000006fH
  00659	72		 DB	 114			; 00000072H
  0065a	64		 DB	 100			; 00000064H
  0065b	73		 DB	 115			; 00000073H
  0065c	00		 DB	 0
$LN3@glm_frustu:
  0065d	63		 DB	 99			; 00000063H
  0065e	00		 DB	 0
_glm_frustum_corners ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Light\source\repos\3DRendC\include\frustum.h
;	COMDAT _glm_frustum_planes
_TEXT	SEGMENT
_t$ = -80						; size = 64
__$ArrayPad$ = -4					; size = 4
_m$ = 8							; size = 4
_dest$ = 12						; size = 4
_glm_frustum_planes PROC				; COMDAT

; 72   : glm_frustum_planes(mat4 m, vec4 dest[6]) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 f0	 and	 esp, -16		; fffffff0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec 18 01 00
	00		 sub	 esp, 280		; 00000118H
  0001c	56		 push	 esi
  0001d	57		 push	 edi
  0001e	8d bd e8 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-280]
  00024	b9 46 00 00 00	 mov	 ecx, 70			; 00000046H
  00029	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002e	f3 ab		 rep stosd
  00030	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00035	33 c5		 xor	 eax, ebp
  00037	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0003a	b9 00 00 00 00	 mov	 ecx, OFFSET __26922CBA_frustum@h
  0003f	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 73   :   mat4 t;
; 74   : 
; 75   :   glm_mat4_transpose_to(m, t);

  00044	8d 45 b0	 lea	 eax, DWORD PTR _t$[ebp]
  00047	50		 push	 eax
  00048	8b 4b 08	 mov	 ecx, DWORD PTR _m$[ebx]
  0004b	51		 push	 ecx
  0004c	e8 00 00 00 00	 call	 _glm_mat4_transpose_to
  00051	83 c4 08	 add	 esp, 8

; 76   : 
; 77   :   glm_vec4_add(t[3], t[0], dest[0]); /* left   */

  00054	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  00059	6b c8 00	 imul	 ecx, eax, 0
  0005c	03 4b 0c	 add	 ecx, DWORD PTR _dest$[ebx]
  0005f	51		 push	 ecx
  00060	ba 10 00 00 00	 mov	 edx, 16			; 00000010H
  00065	6b c2 00	 imul	 eax, edx, 0
  00068	8d 4c 05 b0	 lea	 ecx, DWORD PTR _t$[ebp+eax]
  0006c	51		 push	 ecx
  0006d	ba 10 00 00 00	 mov	 edx, 16			; 00000010H
  00072	6b c2 03	 imul	 eax, edx, 3
  00075	8d 4c 05 b0	 lea	 ecx, DWORD PTR _t$[ebp+eax]
  00079	51		 push	 ecx
  0007a	e8 00 00 00 00	 call	 _glm_vec4_add
  0007f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 78   :   glm_vec4_sub(t[3], t[0], dest[1]); /* right  */

  00082	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  00087	c1 e0 00	 shl	 eax, 0
  0008a	03 43 0c	 add	 eax, DWORD PTR _dest$[ebx]
  0008d	50		 push	 eax
  0008e	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  00093	6b d1 00	 imul	 edx, ecx, 0
  00096	8d 44 15 b0	 lea	 eax, DWORD PTR _t$[ebp+edx]
  0009a	50		 push	 eax
  0009b	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  000a0	6b d1 03	 imul	 edx, ecx, 3
  000a3	8d 44 15 b0	 lea	 eax, DWORD PTR _t$[ebp+edx]
  000a7	50		 push	 eax
  000a8	e8 00 00 00 00	 call	 _glm_vec4_sub
  000ad	83 c4 0c	 add	 esp, 12			; 0000000cH

; 79   :   glm_vec4_add(t[3], t[1], dest[2]); /* bottom */

  000b0	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  000b5	d1 e0		 shl	 eax, 1
  000b7	03 43 0c	 add	 eax, DWORD PTR _dest$[ebx]
  000ba	50		 push	 eax
  000bb	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  000c0	c1 e1 00	 shl	 ecx, 0
  000c3	8d 54 0d b0	 lea	 edx, DWORD PTR _t$[ebp+ecx]
  000c7	52		 push	 edx
  000c8	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  000cd	6b c8 03	 imul	 ecx, eax, 3
  000d0	8d 54 0d b0	 lea	 edx, DWORD PTR _t$[ebp+ecx]
  000d4	52		 push	 edx
  000d5	e8 00 00 00 00	 call	 _glm_vec4_add
  000da	83 c4 0c	 add	 esp, 12			; 0000000cH

; 80   :   glm_vec4_sub(t[3], t[1], dest[3]); /* top    */

  000dd	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  000e2	6b c8 03	 imul	 ecx, eax, 3
  000e5	03 4b 0c	 add	 ecx, DWORD PTR _dest$[ebx]
  000e8	51		 push	 ecx
  000e9	ba 10 00 00 00	 mov	 edx, 16			; 00000010H
  000ee	c1 e2 00	 shl	 edx, 0
  000f1	8d 44 15 b0	 lea	 eax, DWORD PTR _t$[ebp+edx]
  000f5	50		 push	 eax
  000f6	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  000fb	6b d1 03	 imul	 edx, ecx, 3
  000fe	8d 44 15 b0	 lea	 eax, DWORD PTR _t$[ebp+edx]
  00102	50		 push	 eax
  00103	e8 00 00 00 00	 call	 _glm_vec4_sub
  00108	83 c4 0c	 add	 esp, 12			; 0000000cH

; 81   :   glm_vec4_add(t[3], t[2], dest[4]); /* near   */

  0010b	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  00110	c1 e0 02	 shl	 eax, 2
  00113	03 43 0c	 add	 eax, DWORD PTR _dest$[ebx]
  00116	50		 push	 eax
  00117	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  0011c	d1 e1		 shl	 ecx, 1
  0011e	8d 54 0d b0	 lea	 edx, DWORD PTR _t$[ebp+ecx]
  00122	52		 push	 edx
  00123	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  00128	6b c8 03	 imul	 ecx, eax, 3
  0012b	8d 54 0d b0	 lea	 edx, DWORD PTR _t$[ebp+ecx]
  0012f	52		 push	 edx
  00130	e8 00 00 00 00	 call	 _glm_vec4_add
  00135	83 c4 0c	 add	 esp, 12			; 0000000cH

; 82   :   glm_vec4_sub(t[3], t[2], dest[5]); /* far    */

  00138	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  0013d	6b c8 05	 imul	 ecx, eax, 5
  00140	03 4b 0c	 add	 ecx, DWORD PTR _dest$[ebx]
  00143	51		 push	 ecx
  00144	ba 10 00 00 00	 mov	 edx, 16			; 00000010H
  00149	d1 e2		 shl	 edx, 1
  0014b	8d 44 15 b0	 lea	 eax, DWORD PTR _t$[ebp+edx]
  0014f	50		 push	 eax
  00150	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  00155	6b d1 03	 imul	 edx, ecx, 3
  00158	8d 44 15 b0	 lea	 eax, DWORD PTR _t$[ebp+edx]
  0015c	50		 push	 eax
  0015d	e8 00 00 00 00	 call	 _glm_vec4_sub
  00162	83 c4 0c	 add	 esp, 12			; 0000000cH

; 83   : 
; 84   :   glm_plane_normalize(dest[0]);

  00165	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  0016a	6b c8 00	 imul	 ecx, eax, 0
  0016d	03 4b 0c	 add	 ecx, DWORD PTR _dest$[ebx]
  00170	51		 push	 ecx
  00171	e8 00 00 00 00	 call	 _glm_plane_normalize
  00176	83 c4 04	 add	 esp, 4

; 85   :   glm_plane_normalize(dest[1]);

  00179	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  0017e	c1 e0 00	 shl	 eax, 0
  00181	03 43 0c	 add	 eax, DWORD PTR _dest$[ebx]
  00184	50		 push	 eax
  00185	e8 00 00 00 00	 call	 _glm_plane_normalize
  0018a	83 c4 04	 add	 esp, 4

; 86   :   glm_plane_normalize(dest[2]);

  0018d	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  00192	d1 e0		 shl	 eax, 1
  00194	03 43 0c	 add	 eax, DWORD PTR _dest$[ebx]
  00197	50		 push	 eax
  00198	e8 00 00 00 00	 call	 _glm_plane_normalize
  0019d	83 c4 04	 add	 esp, 4

; 87   :   glm_plane_normalize(dest[3]);

  001a0	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  001a5	6b c8 03	 imul	 ecx, eax, 3
  001a8	03 4b 0c	 add	 ecx, DWORD PTR _dest$[ebx]
  001ab	51		 push	 ecx
  001ac	e8 00 00 00 00	 call	 _glm_plane_normalize
  001b1	83 c4 04	 add	 esp, 4

; 88   :   glm_plane_normalize(dest[4]);

  001b4	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  001b9	c1 e0 02	 shl	 eax, 2
  001bc	03 43 0c	 add	 eax, DWORD PTR _dest$[ebx]
  001bf	50		 push	 eax
  001c0	e8 00 00 00 00	 call	 _glm_plane_normalize
  001c5	83 c4 04	 add	 esp, 4

; 89   :   glm_plane_normalize(dest[5]);

  001c8	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  001cd	6b c8 05	 imul	 ecx, eax, 5
  001d0	03 4b 0c	 add	 ecx, DWORD PTR _dest$[ebx]
  001d3	51		 push	 ecx
  001d4	e8 00 00 00 00	 call	 _glm_plane_normalize
  001d9	83 c4 04	 add	 esp, 4

; 90   : }

  001dc	52		 push	 edx
  001dd	8b cd		 mov	 ecx, ebp
  001df	50		 push	 eax
  001e0	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN5@glm_frustu
  001e6	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  001eb	58		 pop	 eax
  001ec	5a		 pop	 edx
  001ed	5f		 pop	 edi
  001ee	5e		 pop	 esi
  001ef	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001f2	33 cd		 xor	 ecx, ebp
  001f4	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001f9	8b e5		 mov	 esp, ebp
  001fb	5d		 pop	 ebp
  001fc	8b e3		 mov	 esp, ebx
  001fe	5b		 pop	 ebx
  001ff	c3		 ret	 0
$LN5@glm_frustu:
  00200	01 00 00 00	 DD	 1
  00204	00 00 00 00	 DD	 $LN4@glm_frustu
$LN4@glm_frustu:
  00208	b0 ff ff ff	 DD	 -80			; ffffffb0H
  0020c	40 00 00 00	 DD	 64			; 00000040H
  00210	00 00 00 00	 DD	 $LN3@glm_frustu
$LN3@glm_frustu:
  00214	74		 DB	 116			; 00000074H
  00215	00		 DB	 0
_glm_frustum_planes ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Light\source\repos\3DRendC\include\plane.h
;	COMDAT _glm_plane_normalize
_TEXT	SEGMENT
_norm$ = -8						; size = 4
_plane$ = 8						; size = 4
_glm_plane_normalize PROC				; COMDAT

; 32   : glm_plane_normalize(vec4 plane) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __26C2D243_plane@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 33   :   float norm;
; 34   :   
; 35   :   if ((norm = glm_vec3_norm(plane)) == 0.0f) {

  00028	8b 45 08	 mov	 eax, DWORD PTR _plane$[ebp]
  0002b	50		 push	 eax
  0002c	e8 00 00 00 00	 call	 _glm_vec3_norm
  00031	83 c4 04	 add	 esp, 4
  00034	d9 5d f8	 fstp	 DWORD PTR _norm$[ebp]
  00037	f3 0f 10 45 f8	 movss	 xmm0, DWORD PTR _norm$[ebp]
  0003c	0f 2e 05 00 00
	00 00		 ucomiss xmm0, DWORD PTR __real@00000000
  00043	9f		 lahf
  00044	f6 c4 44	 test	 ah, 68			; 00000044H
  00047	7a 0e		 jp	 SHORT $LN2@glm_plane_

; 36   :     glm_vec4_zero(plane);

  00049	8b 45 08	 mov	 eax, DWORD PTR _plane$[ebp]
  0004c	50		 push	 eax
  0004d	e8 00 00 00 00	 call	 _glm_vec4_zero
  00052	83 c4 04	 add	 esp, 4

; 37   :     return;

  00055	eb 23		 jmp	 SHORT $LN1@glm_plane_
$LN2@glm_plane_:

; 38   :   }
; 39   :   
; 40   :   glm_vec4_scale(plane, 1.0f / norm, plane);

  00057	8b 45 08	 mov	 eax, DWORD PTR _plane$[ebp]
  0005a	50		 push	 eax
  0005b	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00063	f3 0f 5e 45 f8	 divss	 xmm0, DWORD PTR _norm$[ebp]
  00068	51		 push	 ecx
  00069	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0006e	8b 4d 08	 mov	 ecx, DWORD PTR _plane$[ebp]
  00071	51		 push	 ecx
  00072	e8 00 00 00 00	 call	 _glm_vec4_scale
  00077	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@glm_plane_:

; 41   : }

  0007a	5f		 pop	 edi
  0007b	5e		 pop	 esi
  0007c	5b		 pop	 ebx
  0007d	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00083	3b ec		 cmp	 ebp, esp
  00085	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0008a	8b e5		 mov	 esp, ebp
  0008c	5d		 pop	 ebp
  0008d	c3		 ret	 0
_glm_plane_normalize ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Light\source\repos\3DRendC\include\mat4.h
;	COMDAT _glm_mat4_transpose_to
_TEXT	SEGMENT
_m$ = 8							; size = 4
_dest$ = 12						; size = 4
_glm_mat4_transpose_to PROC				; COMDAT

; 478  : glm_mat4_transpose_to(mat4 m, mat4 dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __D6E4440C_mat4@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 479  : #if defined( __SSE__ ) || defined( __SSE2__ )
; 480  :   glm_mat4_transp_sse2(m, dest);

  00028	8b 45 0c	 mov	 eax, DWORD PTR _dest$[ebp]
  0002b	50		 push	 eax
  0002c	8b 4d 08	 mov	 ecx, DWORD PTR _m$[ebp]
  0002f	51		 push	 ecx
  00030	e8 00 00 00 00	 call	 _glm_mat4_transp_sse2
  00035	83 c4 08	 add	 esp, 8

; 481  : #elif defined(CGLM_NEON_FP)
; 482  :   glm_mat4_transp_neon(m, dest);
; 483  : #else
; 484  :   dest[0][0] = m[0][0]; dest[1][0] = m[0][1];
; 485  :   dest[0][1] = m[1][0]; dest[1][1] = m[1][1];
; 486  :   dest[0][2] = m[2][0]; dest[1][2] = m[2][1];
; 487  :   dest[0][3] = m[3][0]; dest[1][3] = m[3][1];
; 488  :   dest[2][0] = m[0][2]; dest[3][0] = m[0][3];
; 489  :   dest[2][1] = m[1][2]; dest[3][1] = m[1][3];
; 490  :   dest[2][2] = m[2][2]; dest[3][2] = m[2][3];
; 491  :   dest[2][3] = m[3][2]; dest[3][3] = m[3][3];
; 492  : #endif
; 493  : }

  00038	5f		 pop	 edi
  00039	5e		 pop	 esi
  0003a	5b		 pop	 ebx
  0003b	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00041	3b ec		 cmp	 ebp, esp
  00043	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00048	8b e5		 mov	 esp, ebp
  0004a	5d		 pop	 ebp
  0004b	c3		 ret	 0
_glm_mat4_transpose_to ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Light\source\repos\3DRendC\include\mat4.h
;	COMDAT _glm_mat4_mulv
_TEXT	SEGMENT
_m$ = 8							; size = 4
_v$ = 12						; size = 4
_dest$ = 16						; size = 4
_glm_mat4_mulv PROC					; COMDAT

; 358  : glm_mat4_mulv(mat4 m, vec4 v, vec4 dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __D6E4440C_mat4@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 359  : #if defined( __SSE__ ) || defined( __SSE2__ )
; 360  :   glm_mat4_mulv_sse2(m, v, dest);

  00028	8b 45 10	 mov	 eax, DWORD PTR _dest$[ebp]
  0002b	50		 push	 eax
  0002c	8b 4d 0c	 mov	 ecx, DWORD PTR _v$[ebp]
  0002f	51		 push	 ecx
  00030	8b 55 08	 mov	 edx, DWORD PTR _m$[ebp]
  00033	52		 push	 edx
  00034	e8 00 00 00 00	 call	 _glm_mat4_mulv_sse2
  00039	83 c4 0c	 add	 esp, 12			; 0000000cH

; 361  : #elif defined(CGLM_NEON_FP)
; 362  :   glm_mat4_mulv_neon(m, v, dest);
; 363  : #else
; 364  :   vec4 res;
; 365  :   res[0] = m[0][0] * v[0] + m[1][0] * v[1] + m[2][0] * v[2] + m[3][0] * v[3];
; 366  :   res[1] = m[0][1] * v[0] + m[1][1] * v[1] + m[2][1] * v[2] + m[3][1] * v[3];
; 367  :   res[2] = m[0][2] * v[0] + m[1][2] * v[1] + m[2][2] * v[2] + m[3][2] * v[3];
; 368  :   res[3] = m[0][3] * v[0] + m[1][3] * v[1] + m[2][3] * v[2] + m[3][3] * v[3];
; 369  :   glm_vec4_copy(res, dest);
; 370  : #endif
; 371  : }

  0003c	5f		 pop	 edi
  0003d	5e		 pop	 esi
  0003e	5b		 pop	 ebx
  0003f	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00045	3b ec		 cmp	 ebp, esp
  00047	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004c	8b e5		 mov	 esp, ebp
  0004e	5d		 pop	 ebp
  0004f	c3		 ret	 0
_glm_mat4_mulv ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Light\source\repos\3DRendC\include\simd\sse2\mat4.h
;	COMDAT _glm_mat4_mulv_sse2
_TEXT	SEGMENT
_x2$ = -96						; size = 16
_x1$ = -64						; size = 16
_x0$ = -32						; size = 16
_m$ = 8							; size = 4
_v$ = 12						; size = 4
_dest$ = 16						; size = 4
_glm_mat4_mulv_sse2 PROC				; COMDAT

; 88   : glm_mat4_mulv_sse2(mat4 m, vec4 v, vec4 dest) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 f0	 and	 esp, -16		; fffffff0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec 28 01 00
	00		 sub	 esp, 296		; 00000128H
  0001c	56		 push	 esi
  0001d	57		 push	 edi
  0001e	8d bd d8 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-296]
  00024	b9 4a 00 00 00	 mov	 ecx, 74			; 0000004aH
  00029	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002e	f3 ab		 rep stosd
  00030	b9 00 00 00 00	 mov	 ecx, OFFSET __6C51F661_mat4@h
  00035	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 89   :   __m128 x0, x1, x2;
; 90   : 
; 91   :   x0 = glmm_load(v);

  0003a	8b 43 0c	 mov	 eax, DWORD PTR _v$[ebx]
  0003d	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  00040	0f 29 45 e0	 movaps	 XMMWORD PTR _x0$[ebp], xmm0

; 92   :   x1 = _mm_add_ps(_mm_mul_ps(glmm_load(m[0]), glmm_shuff1x(x0, 0)),

  00044	0f 28 45 e0	 movaps	 xmm0, XMMWORD PTR _x0$[ebp]
  00048	0f c6 45 e0 55	 shufps	 xmm0, XMMWORD PTR _x0$[ebp], 85 ; 00000055H
  0004d	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  00052	c1 e0 00	 shl	 eax, 0
  00055	03 43 08	 add	 eax, DWORD PTR _m$[ebx]
  00058	0f 10 08	 movups	 xmm1, XMMWORD PTR [eax]
  0005b	0f 59 c8	 mulps	 xmm1, xmm0
  0005e	0f 28 45 e0	 movaps	 xmm0, XMMWORD PTR _x0$[ebp]
  00062	0f c6 45 e0 00	 shufps	 xmm0, XMMWORD PTR _x0$[ebp], 0
  00067	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  0006c	6b d1 00	 imul	 edx, ecx, 0
  0006f	03 53 08	 add	 edx, DWORD PTR _m$[ebx]
  00072	0f 10 12	 movups	 xmm2, XMMWORD PTR [edx]
  00075	0f 59 d0	 mulps	 xmm2, xmm0
  00078	0f 58 d1	 addps	 xmm2, xmm1
  0007b	0f 29 55 c0	 movaps	 XMMWORD PTR _x1$[ebp], xmm2

; 93   :                   _mm_mul_ps(glmm_load(m[1]), glmm_shuff1x(x0, 1)));
; 94   : 
; 95   :   x2 = _mm_add_ps(_mm_mul_ps(glmm_load(m[2]), glmm_shuff1x(x0, 2)),

  0007f	0f 28 45 e0	 movaps	 xmm0, XMMWORD PTR _x0$[ebp]
  00083	0f c6 45 e0 ff	 shufps	 xmm0, XMMWORD PTR _x0$[ebp], 255 ; 000000ffH
  00088	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  0008d	6b c8 03	 imul	 ecx, eax, 3
  00090	03 4b 08	 add	 ecx, DWORD PTR _m$[ebx]
  00093	0f 10 09	 movups	 xmm1, XMMWORD PTR [ecx]
  00096	0f 59 c8	 mulps	 xmm1, xmm0
  00099	0f 28 45 e0	 movaps	 xmm0, XMMWORD PTR _x0$[ebp]
  0009d	0f c6 45 e0 aa	 shufps	 xmm0, XMMWORD PTR _x0$[ebp], 170 ; 000000aaH
  000a2	ba 10 00 00 00	 mov	 edx, 16			; 00000010H
  000a7	d1 e2		 shl	 edx, 1
  000a9	03 53 08	 add	 edx, DWORD PTR _m$[ebx]
  000ac	0f 10 12	 movups	 xmm2, XMMWORD PTR [edx]
  000af	0f 59 d0	 mulps	 xmm2, xmm0
  000b2	0f 58 d1	 addps	 xmm2, xmm1
  000b5	0f 29 55 a0	 movaps	 XMMWORD PTR _x2$[ebp], xmm2

; 96   :                   _mm_mul_ps(glmm_load(m[3]), glmm_shuff1x(x0, 3)));
; 97   : 
; 98   :   glmm_store(dest, _mm_add_ps(x1, x2));

  000b9	0f 28 45 c0	 movaps	 xmm0, XMMWORD PTR _x1$[ebp]
  000bd	0f 58 45 a0	 addps	 xmm0, XMMWORD PTR _x2$[ebp]
  000c1	8b 43 10	 mov	 eax, DWORD PTR _dest$[ebx]
  000c4	0f 11 00	 movups	 XMMWORD PTR [eax], xmm0

; 99   : }

  000c7	5f		 pop	 edi
  000c8	5e		 pop	 esi
  000c9	8b e5		 mov	 esp, ebp
  000cb	5d		 pop	 ebp
  000cc	8b e3		 mov	 esp, ebx
  000ce	5b		 pop	 ebx
  000cf	c3		 ret	 0
_glm_mat4_mulv_sse2 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Light\source\repos\3DRendC\include\simd\sse2\mat4.h
;	COMDAT _glm_mat4_transp_sse2
_TEXT	SEGMENT
__Tmp0$1 = -256						; size = 16
__Tmp1$2 = -224						; size = 16
__Tmp2$3 = -192						; size = 16
__Tmp3$4 = -160						; size = 16
_r3$ = -128						; size = 16
_r2$ = -96						; size = 16
_r1$ = -64						; size = 16
_r0$ = -32						; size = 16
_m$ = 8							; size = 4
_dest$ = 12						; size = 4
_glm_mat4_transp_sse2 PROC				; COMDAT

; 31   : glm_mat4_transp_sse2(mat4 m, mat4 dest) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 f0	 and	 esp, -16		; fffffff0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec c8 01 00
	00		 sub	 esp, 456		; 000001c8H
  0001c	56		 push	 esi
  0001d	57		 push	 edi
  0001e	8d bd 38 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-456]
  00024	b9 72 00 00 00	 mov	 ecx, 114		; 00000072H
  00029	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002e	f3 ab		 rep stosd
  00030	b9 00 00 00 00	 mov	 ecx, OFFSET __6C51F661_mat4@h
  00035	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 32   :   __m128 r0, r1, r2, r3;
; 33   : 
; 34   :   r0 = glmm_load(m[0]);

  0003a	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  0003f	6b c8 00	 imul	 ecx, eax, 0
  00042	03 4b 08	 add	 ecx, DWORD PTR _m$[ebx]
  00045	0f 10 01	 movups	 xmm0, XMMWORD PTR [ecx]
  00048	0f 29 45 e0	 movaps	 XMMWORD PTR _r0$[ebp], xmm0

; 35   :   r1 = glmm_load(m[1]);

  0004c	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  00051	c1 e0 00	 shl	 eax, 0
  00054	03 43 08	 add	 eax, DWORD PTR _m$[ebx]
  00057	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  0005a	0f 29 45 c0	 movaps	 XMMWORD PTR _r1$[ebp], xmm0

; 36   :   r2 = glmm_load(m[2]);

  0005e	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  00063	d1 e0		 shl	 eax, 1
  00065	03 43 08	 add	 eax, DWORD PTR _m$[ebx]
  00068	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  0006b	0f 29 45 a0	 movaps	 XMMWORD PTR _r2$[ebp], xmm0

; 37   :   r3 = glmm_load(m[3]);

  0006f	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  00074	6b c8 03	 imul	 ecx, eax, 3
  00077	03 4b 08	 add	 ecx, DWORD PTR _m$[ebx]
  0007a	0f 10 01	 movups	 xmm0, XMMWORD PTR [ecx]
  0007d	0f 29 45 80	 movaps	 XMMWORD PTR _r3$[ebp], xmm0

; 38   : 
; 39   :   _MM_TRANSPOSE4_PS(r0, r1, r2, r3);

  00081	0f 28 45 e0	 movaps	 xmm0, XMMWORD PTR _r0$[ebp]
  00085	0f c6 45 c0 44	 shufps	 xmm0, XMMWORD PTR _r1$[ebp], 68 ; 00000044H
  0008a	0f 29 85 00 ff
	ff ff		 movaps	 XMMWORD PTR __Tmp0$1[ebp], xmm0
  00091	0f 28 45 e0	 movaps	 xmm0, XMMWORD PTR _r0$[ebp]
  00095	0f c6 45 c0 ee	 shufps	 xmm0, XMMWORD PTR _r1$[ebp], 238 ; 000000eeH
  0009a	0f 29 85 40 ff
	ff ff		 movaps	 XMMWORD PTR __Tmp2$3[ebp], xmm0
  000a1	0f 28 45 a0	 movaps	 xmm0, XMMWORD PTR _r2$[ebp]
  000a5	0f c6 45 80 44	 shufps	 xmm0, XMMWORD PTR _r3$[ebp], 68 ; 00000044H
  000aa	0f 29 85 20 ff
	ff ff		 movaps	 XMMWORD PTR __Tmp1$2[ebp], xmm0
  000b1	0f 28 45 a0	 movaps	 xmm0, XMMWORD PTR _r2$[ebp]
  000b5	0f c6 45 80 ee	 shufps	 xmm0, XMMWORD PTR _r3$[ebp], 238 ; 000000eeH
  000ba	0f 29 85 60 ff
	ff ff		 movaps	 XMMWORD PTR __Tmp3$4[ebp], xmm0
  000c1	0f 28 85 00 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR __Tmp0$1[ebp]
  000c8	0f c6 85 20 ff
	ff ff 88	 shufps	 xmm0, XMMWORD PTR __Tmp1$2[ebp], 136 ; 00000088H
  000d0	0f 29 45 e0	 movaps	 XMMWORD PTR _r0$[ebp], xmm0
  000d4	0f 28 85 00 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR __Tmp0$1[ebp]
  000db	0f c6 85 20 ff
	ff ff dd	 shufps	 xmm0, XMMWORD PTR __Tmp1$2[ebp], 221 ; 000000ddH
  000e3	0f 29 45 c0	 movaps	 XMMWORD PTR _r1$[ebp], xmm0
  000e7	0f 28 85 40 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR __Tmp2$3[ebp]
  000ee	0f c6 85 60 ff
	ff ff 88	 shufps	 xmm0, XMMWORD PTR __Tmp3$4[ebp], 136 ; 00000088H
  000f6	0f 29 45 a0	 movaps	 XMMWORD PTR _r2$[ebp], xmm0
  000fa	0f 28 85 40 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR __Tmp2$3[ebp]
  00101	0f c6 85 60 ff
	ff ff dd	 shufps	 xmm0, XMMWORD PTR __Tmp3$4[ebp], 221 ; 000000ddH
  00109	0f 29 45 80	 movaps	 XMMWORD PTR _r3$[ebp], xmm0

; 40   : 
; 41   :   glmm_store(dest[0], r0);

  0010d	0f 28 45 e0	 movaps	 xmm0, XMMWORD PTR _r0$[ebp]
  00111	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  00116	6b c8 00	 imul	 ecx, eax, 0
  00119	03 4b 0c	 add	 ecx, DWORD PTR _dest$[ebx]
  0011c	0f 11 01	 movups	 XMMWORD PTR [ecx], xmm0

; 42   :   glmm_store(dest[1], r1);

  0011f	0f 28 45 c0	 movaps	 xmm0, XMMWORD PTR _r1$[ebp]
  00123	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  00128	c1 e0 00	 shl	 eax, 0
  0012b	03 43 0c	 add	 eax, DWORD PTR _dest$[ebx]
  0012e	0f 11 00	 movups	 XMMWORD PTR [eax], xmm0

; 43   :   glmm_store(dest[2], r2);

  00131	0f 28 45 a0	 movaps	 xmm0, XMMWORD PTR _r2$[ebp]
  00135	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  0013a	d1 e0		 shl	 eax, 1
  0013c	03 43 0c	 add	 eax, DWORD PTR _dest$[ebx]
  0013f	0f 11 00	 movups	 XMMWORD PTR [eax], xmm0

; 44   :   glmm_store(dest[3], r3);

  00142	0f 28 45 80	 movaps	 xmm0, XMMWORD PTR _r3$[ebp]
  00146	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  0014b	6b c8 03	 imul	 ecx, eax, 3
  0014e	03 4b 0c	 add	 ecx, DWORD PTR _dest$[ebx]
  00151	0f 11 01	 movups	 XMMWORD PTR [ecx], xmm0

; 45   : }

  00154	5f		 pop	 edi
  00155	5e		 pop	 esi
  00156	8b e5		 mov	 esp, ebp
  00158	5d		 pop	 ebp
  00159	8b e3		 mov	 esp, ebx
  0015b	5b		 pop	 ebx
  0015c	c3		 ret	 0
_glm_mat4_transp_sse2 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Light\source\repos\3DRendC\include\vec3.h
;	COMDAT _glm_vec3_distance
_TEXT	SEGMENT
_a$ = 8							; size = 4
_b$ = 12						; size = 4
_glm_vec3_distance PROC					; COMDAT

; 767  : glm_vec3_distance(vec3 a, vec3 b) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __82F46937_vec3@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 768  :   return sqrtf(glm_vec3_distance2(a, b));

  00028	8b 45 0c	 mov	 eax, DWORD PTR _b$[ebp]
  0002b	50		 push	 eax
  0002c	8b 4d 08	 mov	 ecx, DWORD PTR _a$[ebp]
  0002f	51		 push	 ecx
  00030	e8 00 00 00 00	 call	 _glm_vec3_distance2
  00035	83 c4 04	 add	 esp, 4
  00038	d9 1c 24	 fstp	 DWORD PTR [esp]
  0003b	e8 00 00 00 00	 call	 _sqrtf
  00040	83 c4 04	 add	 esp, 4

; 769  : }

  00043	5f		 pop	 edi
  00044	5e		 pop	 esi
  00045	5b		 pop	 ebx
  00046	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0004c	3b ec		 cmp	 ebp, esp
  0004e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00053	8b e5		 mov	 esp, ebp
  00055	5d		 pop	 ebp
  00056	c3		 ret	 0
_glm_vec3_distance ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Light\source\repos\3DRendC\include\vec3.h
;	COMDAT _glm_vec3_distance2
_TEXT	SEGMENT
tv154 = -216						; size = 4
tv152 = -212						; size = 4
tv159 = -208						; size = 4
tv142 = -204						; size = 4
tv157 = -200						; size = 4
tv132 = -196						; size = 4
_a$ = 8							; size = 4
_b$ = 12						; size = 4
_glm_vec3_distance2 PROC				; COMDAT

; 752  : glm_vec3_distance2(vec3 a, vec3 b) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00012	b9 36 00 00 00	 mov	 ecx, 54			; 00000036H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __82F46937_vec3@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 753  :   return glm_pow2(a[0] - b[0])

  00028	b8 04 00 00 00	 mov	 eax, 4
  0002d	6b c8 00	 imul	 ecx, eax, 0
  00030	ba 04 00 00 00	 mov	 edx, 4
  00035	6b c2 00	 imul	 eax, edx, 0
  00038	8b 55 08	 mov	 edx, DWORD PTR _a$[ebp]
  0003b	8b 75 0c	 mov	 esi, DWORD PTR _b$[ebp]
  0003e	f3 0f 10 04 0a	 movss	 xmm0, DWORD PTR [edx+ecx]
  00043	f3 0f 5c 04 06	 subss	 xmm0, DWORD PTR [esi+eax]
  00048	51		 push	 ecx
  00049	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0004e	e8 00 00 00 00	 call	 _glm_pow2
  00053	83 c4 04	 add	 esp, 4
  00056	d9 9d 3c ff ff
	ff		 fstp	 DWORD PTR tv132[ebp]
  0005c	f3 0f 10 85 3c
	ff ff ff	 movss	 xmm0, DWORD PTR tv132[ebp]
  00064	b8 04 00 00 00	 mov	 eax, 4
  00069	c1 e0 00	 shl	 eax, 0
  0006c	b9 04 00 00 00	 mov	 ecx, 4
  00071	c1 e1 00	 shl	 ecx, 0
  00074	8b 55 08	 mov	 edx, DWORD PTR _a$[ebp]
  00077	8b 75 0c	 mov	 esi, DWORD PTR _b$[ebp]
  0007a	f3 0f 10 0c 02	 movss	 xmm1, DWORD PTR [edx+eax]
  0007f	f3 0f 5c 0c 0e	 subss	 xmm1, DWORD PTR [esi+ecx]
  00084	51		 push	 ecx
  00085	f3 0f 11 0c 24	 movss	 DWORD PTR [esp], xmm1
  0008a	f3 0f 11 85 38
	ff ff ff	 movss	 DWORD PTR tv157[ebp], xmm0
  00092	e8 00 00 00 00	 call	 _glm_pow2
  00097	83 c4 04	 add	 esp, 4
  0009a	d9 9d 34 ff ff
	ff		 fstp	 DWORD PTR tv142[ebp]
  000a0	f3 0f 10 85 38
	ff ff ff	 movss	 xmm0, DWORD PTR tv157[ebp]
  000a8	f3 0f 58 85 34
	ff ff ff	 addss	 xmm0, DWORD PTR tv142[ebp]
  000b0	b8 04 00 00 00	 mov	 eax, 4
  000b5	d1 e0		 shl	 eax, 1
  000b7	b9 04 00 00 00	 mov	 ecx, 4
  000bc	d1 e1		 shl	 ecx, 1
  000be	8b 55 08	 mov	 edx, DWORD PTR _a$[ebp]
  000c1	8b 75 0c	 mov	 esi, DWORD PTR _b$[ebp]
  000c4	f3 0f 10 0c 02	 movss	 xmm1, DWORD PTR [edx+eax]
  000c9	f3 0f 5c 0c 0e	 subss	 xmm1, DWORD PTR [esi+ecx]
  000ce	51		 push	 ecx
  000cf	f3 0f 11 0c 24	 movss	 DWORD PTR [esp], xmm1
  000d4	f3 0f 11 85 30
	ff ff ff	 movss	 DWORD PTR tv159[ebp], xmm0
  000dc	e8 00 00 00 00	 call	 _glm_pow2
  000e1	83 c4 04	 add	 esp, 4
  000e4	d9 9d 2c ff ff
	ff		 fstp	 DWORD PTR tv152[ebp]
  000ea	f3 0f 10 85 30
	ff ff ff	 movss	 xmm0, DWORD PTR tv159[ebp]
  000f2	f3 0f 58 85 2c
	ff ff ff	 addss	 xmm0, DWORD PTR tv152[ebp]
  000fa	f3 0f 11 85 28
	ff ff ff	 movss	 DWORD PTR tv154[ebp], xmm0
  00102	d9 85 28 ff ff
	ff		 fld	 DWORD PTR tv154[ebp]

; 754  :        + glm_pow2(a[1] - b[1])
; 755  :        + glm_pow2(a[2] - b[2]);
; 756  : }

  00108	5f		 pop	 edi
  00109	5e		 pop	 esi
  0010a	5b		 pop	 ebx
  0010b	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  00111	3b ec		 cmp	 ebp, esp
  00113	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00118	8b e5		 mov	 esp, ebp
  0011a	5d		 pop	 ebp
  0011b	c3		 ret	 0
_glm_vec3_distance2 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Light\source\repos\3DRendC\include\vec3.h
;	COMDAT _glm_vec3_norm
_TEXT	SEGMENT
_v$ = 8							; size = 4
_glm_vec3_norm PROC					; COMDAT

; 215  : glm_vec3_norm(vec3 v) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __82F46937_vec3@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 216  :   return sqrtf(glm_vec3_norm2(v));

  00028	8b 45 08	 mov	 eax, DWORD PTR _v$[ebp]
  0002b	50		 push	 eax
  0002c	e8 00 00 00 00	 call	 _glm_vec3_norm2
  00031	d9 1c 24	 fstp	 DWORD PTR [esp]
  00034	e8 00 00 00 00	 call	 _sqrtf
  00039	83 c4 04	 add	 esp, 4

; 217  : }

  0003c	5f		 pop	 edi
  0003d	5e		 pop	 esi
  0003e	5b		 pop	 ebx
  0003f	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00045	3b ec		 cmp	 ebp, esp
  00047	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004c	8b e5		 mov	 esp, ebp
  0004e	5d		 pop	 ebp
  0004f	c3		 ret	 0
_glm_vec3_norm ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Light\source\repos\3DRendC\include\vec3.h
;	COMDAT _glm_vec3_norm2
_TEXT	SEGMENT
_v$ = 8							; size = 4
_glm_vec3_norm2 PROC					; COMDAT

; 201  : glm_vec3_norm2(vec3 v) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __82F46937_vec3@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 202  :   return glm_vec3_dot(v, v);

  00028	8b 45 08	 mov	 eax, DWORD PTR _v$[ebp]
  0002b	50		 push	 eax
  0002c	8b 4d 08	 mov	 ecx, DWORD PTR _v$[ebp]
  0002f	51		 push	 ecx
  00030	e8 00 00 00 00	 call	 _glm_vec3_dot
  00035	83 c4 08	 add	 esp, 8

; 203  : }

  00038	5f		 pop	 edi
  00039	5e		 pop	 esi
  0003a	5b		 pop	 ebx
  0003b	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00041	3b ec		 cmp	 ebp, esp
  00043	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00048	8b e5		 mov	 esp, ebp
  0004a	5d		 pop	 ebp
  0004b	c3		 ret	 0
_glm_vec3_norm2 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Light\source\repos\3DRendC\include\vec3.h
;	COMDAT _glm_vec3_dot
_TEXT	SEGMENT
tv130 = -196						; size = 4
_a$ = 8							; size = 4
_b$ = 12						; size = 4
_glm_vec3_dot PROC					; COMDAT

; 184  : glm_vec3_dot(vec3 a, vec3 b) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c4 00 00
	00		 sub	 esp, 196		; 000000c4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 3c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-196]
  00012	b9 31 00 00 00	 mov	 ecx, 49			; 00000031H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __82F46937_vec3@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 185  :   return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];

  00028	b8 04 00 00 00	 mov	 eax, 4
  0002d	6b c8 00	 imul	 ecx, eax, 0
  00030	ba 04 00 00 00	 mov	 edx, 4
  00035	6b c2 00	 imul	 eax, edx, 0
  00038	8b 55 08	 mov	 edx, DWORD PTR _a$[ebp]
  0003b	8b 75 0c	 mov	 esi, DWORD PTR _b$[ebp]
  0003e	f3 0f 10 04 0a	 movss	 xmm0, DWORD PTR [edx+ecx]
  00043	f3 0f 59 04 06	 mulss	 xmm0, DWORD PTR [esi+eax]
  00048	b8 04 00 00 00	 mov	 eax, 4
  0004d	c1 e0 00	 shl	 eax, 0
  00050	b9 04 00 00 00	 mov	 ecx, 4
  00055	c1 e1 00	 shl	 ecx, 0
  00058	8b 55 08	 mov	 edx, DWORD PTR _a$[ebp]
  0005b	8b 75 0c	 mov	 esi, DWORD PTR _b$[ebp]
  0005e	f3 0f 10 0c 02	 movss	 xmm1, DWORD PTR [edx+eax]
  00063	f3 0f 59 0c 0e	 mulss	 xmm1, DWORD PTR [esi+ecx]
  00068	f3 0f 58 c1	 addss	 xmm0, xmm1
  0006c	b8 04 00 00 00	 mov	 eax, 4
  00071	d1 e0		 shl	 eax, 1
  00073	b9 04 00 00 00	 mov	 ecx, 4
  00078	d1 e1		 shl	 ecx, 1
  0007a	8b 55 08	 mov	 edx, DWORD PTR _a$[ebp]
  0007d	8b 75 0c	 mov	 esi, DWORD PTR _b$[ebp]
  00080	f3 0f 10 0c 02	 movss	 xmm1, DWORD PTR [edx+eax]
  00085	f3 0f 59 0c 0e	 mulss	 xmm1, DWORD PTR [esi+ecx]
  0008a	f3 0f 58 c1	 addss	 xmm0, xmm1
  0008e	f3 0f 11 85 3c
	ff ff ff	 movss	 DWORD PTR tv130[ebp], xmm0
  00096	d9 85 3c ff ff
	ff		 fld	 DWORD PTR tv130[ebp]

; 186  : }

  0009c	5f		 pop	 edi
  0009d	5e		 pop	 esi
  0009e	5b		 pop	 ebx
  0009f	81 c4 c4 00 00
	00		 add	 esp, 196		; 000000c4H
  000a5	3b ec		 cmp	 ebp, esp
  000a7	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000ac	8b e5		 mov	 esp, ebp
  000ae	5d		 pop	 ebp
  000af	c3		 ret	 0
_glm_vec3_dot ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Light\source\repos\3DRendC\include\vec3.h
;	COMDAT _glm_vec3_copy
_TEXT	SEGMENT
_a$ = 8							; size = 4
_dest$ = 12						; size = 4
_glm_vec3_copy PROC					; COMDAT

; 146  : glm_vec3_copy(vec3 a, vec3 dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __82F46937_vec3@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 147  :   dest[0] = a[0];

  00028	b8 04 00 00 00	 mov	 eax, 4
  0002d	6b c8 00	 imul	 ecx, eax, 0
  00030	ba 04 00 00 00	 mov	 edx, 4
  00035	6b c2 00	 imul	 eax, edx, 0
  00038	8b 55 0c	 mov	 edx, DWORD PTR _dest$[ebp]
  0003b	8b 75 08	 mov	 esi, DWORD PTR _a$[ebp]
  0003e	8b 0c 0e	 mov	 ecx, DWORD PTR [esi+ecx]
  00041	89 0c 02	 mov	 DWORD PTR [edx+eax], ecx

; 148  :   dest[1] = a[1];

  00044	b8 04 00 00 00	 mov	 eax, 4
  00049	c1 e0 00	 shl	 eax, 0
  0004c	b9 04 00 00 00	 mov	 ecx, 4
  00051	c1 e1 00	 shl	 ecx, 0
  00054	8b 55 0c	 mov	 edx, DWORD PTR _dest$[ebp]
  00057	8b 75 08	 mov	 esi, DWORD PTR _a$[ebp]
  0005a	8b 04 06	 mov	 eax, DWORD PTR [esi+eax]
  0005d	89 04 0a	 mov	 DWORD PTR [edx+ecx], eax

; 149  :   dest[2] = a[2];

  00060	b8 04 00 00 00	 mov	 eax, 4
  00065	d1 e0		 shl	 eax, 1
  00067	b9 04 00 00 00	 mov	 ecx, 4
  0006c	d1 e1		 shl	 ecx, 1
  0006e	8b 55 0c	 mov	 edx, DWORD PTR _dest$[ebp]
  00071	8b 75 08	 mov	 esi, DWORD PTR _a$[ebp]
  00074	8b 04 06	 mov	 eax, DWORD PTR [esi+eax]
  00077	89 04 0a	 mov	 DWORD PTR [edx+ecx], eax

; 150  : }

  0007a	5f		 pop	 edi
  0007b	5e		 pop	 esi
  0007c	5b		 pop	 ebx
  0007d	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00083	3b ec		 cmp	 ebp, esp
  00085	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0008a	8b e5		 mov	 esp, ebp
  0008c	5d		 pop	 ebp
  0008d	c3		 ret	 0
_glm_vec3_copy ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Light\source\repos\3DRendC\include\vec4.h
;	COMDAT _glm_vec4_scale_as
_TEXT	SEGMENT
_norm$ = -8						; size = 4
_v$ = 8							; size = 4
_s$ = 12						; size = 4
_dest$ = 16						; size = 4
_glm_vec4_scale_as PROC					; COMDAT

; 454  : glm_vec4_scale_as(vec4 v, float s, vec4 dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __87BB7FB2_vec4@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 455  :   float norm;
; 456  :   norm = glm_vec4_norm(v);

  00028	8b 45 08	 mov	 eax, DWORD PTR _v$[ebp]
  0002b	50		 push	 eax
  0002c	e8 00 00 00 00	 call	 _glm_vec4_norm
  00031	83 c4 04	 add	 esp, 4
  00034	d9 5d f8	 fstp	 DWORD PTR _norm$[ebp]

; 457  : 
; 458  :   if (norm == 0.0f) {

  00037	f3 0f 10 45 f8	 movss	 xmm0, DWORD PTR _norm$[ebp]
  0003c	0f 2e 05 00 00
	00 00		 ucomiss xmm0, DWORD PTR __real@00000000
  00043	9f		 lahf
  00044	f6 c4 44	 test	 ah, 68			; 00000044H
  00047	7a 0e		 jp	 SHORT $LN2@glm_vec4_s

; 459  :     glm_vec4_zero(dest);

  00049	8b 45 10	 mov	 eax, DWORD PTR _dest$[ebp]
  0004c	50		 push	 eax
  0004d	e8 00 00 00 00	 call	 _glm_vec4_zero
  00052	83 c4 04	 add	 esp, 4

; 460  :     return;

  00055	eb 20		 jmp	 SHORT $LN1@glm_vec4_s
$LN2@glm_vec4_s:

; 461  :   }
; 462  : 
; 463  :   glm_vec4_scale(v, s / norm, dest);

  00057	8b 45 10	 mov	 eax, DWORD PTR _dest$[ebp]
  0005a	50		 push	 eax
  0005b	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _s$[ebp]
  00060	f3 0f 5e 45 f8	 divss	 xmm0, DWORD PTR _norm$[ebp]
  00065	51		 push	 ecx
  00066	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0006b	8b 4d 08	 mov	 ecx, DWORD PTR _v$[ebp]
  0006e	51		 push	 ecx
  0006f	e8 00 00 00 00	 call	 _glm_vec4_scale
  00074	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@glm_vec4_s:

; 464  : }

  00077	5f		 pop	 edi
  00078	5e		 pop	 esi
  00079	5b		 pop	 ebx
  0007a	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00080	3b ec		 cmp	 ebp, esp
  00082	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00087	8b e5		 mov	 esp, ebp
  00089	5d		 pop	 ebp
  0008a	c3		 ret	 0
_glm_vec4_scale_as ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Light\source\repos\3DRendC\include\vec4.h
;	COMDAT _glm_vec4_scale
_TEXT	SEGMENT
_v$ = 8							; size = 4
_s$ = 12						; size = 4
_dest$ = 16						; size = 4
_glm_vec4_scale PROC					; COMDAT

; 432  : glm_vec4_scale(vec4 v, float s, vec4 dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __87BB7FB2_vec4@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 433  : #if defined( __SSE__ ) || defined( __SSE2__ )
; 434  :   glmm_store(dest, _mm_mul_ps(glmm_load(v), _mm_set1_ps(s)));

  00028	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _s$[ebp]
  0002d	0f c6 c0 00	 shufps	 xmm0, xmm0, 0
  00031	8b 45 08	 mov	 eax, DWORD PTR _v$[ebp]
  00034	0f 10 08	 movups	 xmm1, XMMWORD PTR [eax]
  00037	0f 59 c8	 mulps	 xmm1, xmm0
  0003a	8b 4d 10	 mov	 ecx, DWORD PTR _dest$[ebp]
  0003d	0f 11 09	 movups	 XMMWORD PTR [ecx], xmm1

; 435  : #elif defined(CGLM_NEON_FP)
; 436  :   vst1q_f32(dest, vmulq_f32(vld1q_f32(v), vdupq_n_f32(s)));
; 437  : #else
; 438  :   dest[0] = v[0] * s;
; 439  :   dest[1] = v[1] * s;
; 440  :   dest[2] = v[2] * s;
; 441  :   dest[3] = v[3] * s;
; 442  : #endif
; 443  : }

  00040	5f		 pop	 edi
  00041	5e		 pop	 esi
  00042	5b		 pop	 ebx
  00043	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00049	3b ec		 cmp	 ebp, esp
  0004b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00050	8b e5		 mov	 esp, ebp
  00052	5d		 pop	 ebp
  00053	c3		 ret	 0
_glm_vec4_scale ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Light\source\repos\3DRendC\include\vec4.h
;	COMDAT _glm_vec4_sub
_TEXT	SEGMENT
_a$ = 8							; size = 4
_b$ = 12						; size = 4
_dest$ = 16						; size = 4
_glm_vec4_sub PROC					; COMDAT

; 366  : glm_vec4_sub(vec4 a, vec4 b, vec4 dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __87BB7FB2_vec4@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 367  : #if defined( __SSE__ ) || defined( __SSE2__ )
; 368  :   glmm_store(dest, _mm_sub_ps(glmm_load(a), glmm_load(b)));

  00028	8b 45 0c	 mov	 eax, DWORD PTR _b$[ebp]
  0002b	8b 4d 08	 mov	 ecx, DWORD PTR _a$[ebp]
  0002e	0f 10 01	 movups	 xmm0, XMMWORD PTR [ecx]
  00031	0f 5c 00	 subps	 xmm0, XMMWORD PTR [eax]
  00034	8b 55 10	 mov	 edx, DWORD PTR _dest$[ebp]
  00037	0f 11 02	 movups	 XMMWORD PTR [edx], xmm0

; 369  : #elif defined(CGLM_NEON_FP)
; 370  :   vst1q_f32(dest, vsubq_f32(vld1q_f32(a), vld1q_f32(b)));
; 371  : #else
; 372  :   dest[0] = a[0] - b[0];
; 373  :   dest[1] = a[1] - b[1];
; 374  :   dest[2] = a[2] - b[2];
; 375  :   dest[3] = a[3] - b[3];
; 376  : #endif
; 377  : }

  0003a	5f		 pop	 edi
  0003b	5e		 pop	 esi
  0003c	5b		 pop	 ebx
  0003d	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00043	3b ec		 cmp	 ebp, esp
  00045	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004a	8b e5		 mov	 esp, ebp
  0004c	5d		 pop	 ebp
  0004d	c3		 ret	 0
_glm_vec4_sub ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Light\source\repos\3DRendC\include\vec4.h
;	COMDAT _glm_vec4_add
_TEXT	SEGMENT
_a$ = 8							; size = 4
_b$ = 12						; size = 4
_dest$ = 16						; size = 4
_glm_vec4_add PROC					; COMDAT

; 322  : glm_vec4_add(vec4 a, vec4 b, vec4 dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __87BB7FB2_vec4@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 323  : #if defined( __SSE__ ) || defined( __SSE2__ )
; 324  :   glmm_store(dest, _mm_add_ps(glmm_load(a), glmm_load(b)));

  00028	8b 45 0c	 mov	 eax, DWORD PTR _b$[ebp]
  0002b	8b 4d 08	 mov	 ecx, DWORD PTR _a$[ebp]
  0002e	0f 10 01	 movups	 xmm0, XMMWORD PTR [ecx]
  00031	0f 58 00	 addps	 xmm0, XMMWORD PTR [eax]
  00034	8b 55 10	 mov	 edx, DWORD PTR _dest$[ebp]
  00037	0f 11 02	 movups	 XMMWORD PTR [edx], xmm0

; 325  : #elif defined(CGLM_NEON_FP)
; 326  :   vst1q_f32(dest, vaddq_f32(vld1q_f32(a), vld1q_f32(b)));
; 327  : #else
; 328  :   dest[0] = a[0] + b[0];
; 329  :   dest[1] = a[1] + b[1];
; 330  :   dest[2] = a[2] + b[2];
; 331  :   dest[3] = a[3] + b[3];
; 332  : #endif
; 333  : }

  0003a	5f		 pop	 edi
  0003b	5e		 pop	 esi
  0003c	5b		 pop	 ebx
  0003d	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00043	3b ec		 cmp	 ebp, esp
  00045	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004a	8b e5		 mov	 esp, ebp
  0004c	5d		 pop	 ebp
  0004d	c3		 ret	 0
_glm_vec4_add ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Light\source\repos\3DRendC\include\vec4.h
;	COMDAT _glm_vec4_norm
_TEXT	SEGMENT
_v$ = 8							; size = 4
_glm_vec4_norm PROC					; COMDAT

; 254  : glm_vec4_norm(vec4 v) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __87BB7FB2_vec4@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 255  : #if defined(CGLM_SIMD)
; 256  :   return glmm_norm(glmm_load(v));

  00028	8b 45 08	 mov	 eax, DWORD PTR _v$[ebp]
  0002b	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  0002e	e8 00 00 00 00	 call	 _glmm_norm

; 257  : #else
; 258  :   return sqrtf(glm_vec4_dot(v, v));
; 259  : #endif
; 260  : }

  00033	5f		 pop	 edi
  00034	5e		 pop	 esi
  00035	5b		 pop	 ebx
  00036	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0003c	3b ec		 cmp	 ebp, esp
  0003e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00043	8b e5		 mov	 esp, ebp
  00045	5d		 pop	 ebp
  00046	c3		 ret	 0
_glm_vec4_norm ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Light\source\repos\3DRendC\include\vec4.h
;	COMDAT _glm_vec4_zero
_TEXT	SEGMENT
_v$ = 8							; size = 4
_glm_vec4_zero PROC					; COMDAT

; 176  : glm_vec4_zero(vec4 v) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __87BB7FB2_vec4@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 177  : #if defined( __SSE__ ) || defined( __SSE2__ )
; 178  :   glmm_store(v, _mm_setzero_ps());

  00028	0f 57 c0	 xorps	 xmm0, xmm0
  0002b	8b 45 08	 mov	 eax, DWORD PTR _v$[ebp]
  0002e	0f 11 00	 movups	 XMMWORD PTR [eax], xmm0

; 179  : #elif defined(CGLM_NEON_FP)
; 180  :   vst1q_f32(v, vdupq_n_f32(0.0f));
; 181  : #else
; 182  :   v[0] = 0.0f;
; 183  :   v[1] = 0.0f;
; 184  :   v[2] = 0.0f;
; 185  :   v[3] = 0.0f;
; 186  : #endif
; 187  : }

  00031	5f		 pop	 edi
  00032	5e		 pop	 esi
  00033	5b		 pop	 ebx
  00034	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0003a	3b ec		 cmp	 ebp, esp
  0003c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00041	8b e5		 mov	 esp, ebp
  00043	5d		 pop	 ebp
  00044	c3		 ret	 0
_glm_vec4_zero ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Light\source\repos\3DRendC\include\vec4.h
;	COMDAT _glm_vec4_copy
_TEXT	SEGMENT
_v$ = 8							; size = 4
_dest$ = 12						; size = 4
_glm_vec4_copy PROC					; COMDAT

; 139  : glm_vec4_copy(vec4 v, vec4 dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __87BB7FB2_vec4@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 140  : #if defined( __SSE__ ) || defined( __SSE2__ )
; 141  :   glmm_store(dest, glmm_load(v));

  00028	8b 45 08	 mov	 eax, DWORD PTR _v$[ebp]
  0002b	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  0002e	8b 4d 0c	 mov	 ecx, DWORD PTR _dest$[ebp]
  00031	0f 11 01	 movups	 XMMWORD PTR [ecx], xmm0

; 142  : #elif defined(CGLM_NEON_FP)
; 143  :   vst1q_f32(dest, vld1q_f32(v));
; 144  : #else
; 145  :   dest[0] = v[0];
; 146  :   dest[1] = v[1];
; 147  :   dest[2] = v[2];
; 148  :   dest[3] = v[3];
; 149  : #endif
; 150  : }

  00034	5f		 pop	 edi
  00035	5e		 pop	 esi
  00036	5b		 pop	 ebx
  00037	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0003d	3b ec		 cmp	 ebp, esp
  0003f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00044	8b e5		 mov	 esp, ebp
  00046	5d		 pop	 ebp
  00047	c3		 ret	 0
_glm_vec4_copy ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Light\source\repos\3DRendC\include\vec3-ext.h
;	COMDAT _glm_vec3_broadcast
_TEXT	SEGMENT
_val$ = 8						; size = 4
_d$ = 12						; size = 4
_glm_vec3_broadcast PROC				; COMDAT

; 47   : glm_vec3_broadcast(float val, vec3 d) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __9285E8A4_vec3-ext@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 48   :   d[0] = d[1] = d[2] = val;

  00028	b8 04 00 00 00	 mov	 eax, 4
  0002d	d1 e0		 shl	 eax, 1
  0002f	8b 4d 0c	 mov	 ecx, DWORD PTR _d$[ebp]
  00032	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR _val$[ebp]
  00037	f3 0f 11 04 01	 movss	 DWORD PTR [ecx+eax], xmm0
  0003c	ba 04 00 00 00	 mov	 edx, 4
  00041	c1 e2 00	 shl	 edx, 0
  00044	8b 45 0c	 mov	 eax, DWORD PTR _d$[ebp]
  00047	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR _val$[ebp]
  0004c	f3 0f 11 04 10	 movss	 DWORD PTR [eax+edx], xmm0
  00051	b9 04 00 00 00	 mov	 ecx, 4
  00056	6b d1 00	 imul	 edx, ecx, 0
  00059	8b 45 0c	 mov	 eax, DWORD PTR _d$[ebp]
  0005c	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR _val$[ebp]
  00061	f3 0f 11 04 10	 movss	 DWORD PTR [eax+edx], xmm0

; 49   : }

  00066	5f		 pop	 edi
  00067	5e		 pop	 esi
  00068	5b		 pop	 ebx
  00069	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0006f	3b ec		 cmp	 ebp, esp
  00071	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00076	8b e5		 mov	 esp, ebp
  00078	5d		 pop	 ebp
  00079	c3		 ret	 0
_glm_vec3_broadcast ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Light\source\repos\3DRendC\include\util.h
;	COMDAT _glm_max
_TEXT	SEGMENT
_a$ = 8							; size = 4
_b$ = 12						; size = 4
_glm_max PROC						; COMDAT

; 144  : glm_max(float a, float b) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __51BD2C42_util@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 145  :   if (a > b)

  00028	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR _a$[ebp]
  0002d	0f 2f 45 0c	 comiss	 xmm0, DWORD PTR _b$[ebp]
  00031	76 05		 jbe	 SHORT $LN2@glm_max

; 146  :     return a;

  00033	d9 45 08	 fld	 DWORD PTR _a$[ebp]
  00036	eb 03		 jmp	 SHORT $LN1@glm_max
$LN2@glm_max:

; 147  :   return b;

  00038	d9 45 0c	 fld	 DWORD PTR _b$[ebp]
$LN1@glm_max:

; 148  : }

  0003b	5f		 pop	 edi
  0003c	5e		 pop	 esi
  0003d	5b		 pop	 ebx
  0003e	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00044	3b ec		 cmp	 ebp, esp
  00046	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004b	8b e5		 mov	 esp, ebp
  0004d	5d		 pop	 ebp
  0004e	c3		 ret	 0
_glm_max ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Light\source\repos\3DRendC\include\util.h
;	COMDAT _glm_min
_TEXT	SEGMENT
_a$ = 8							; size = 4
_b$ = 12						; size = 4
_glm_min PROC						; COMDAT

; 130  : glm_min(float a, float b) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __51BD2C42_util@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 131  :   if (a < b)

  00028	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _b$[ebp]
  0002d	0f 2f 45 08	 comiss	 xmm0, DWORD PTR _a$[ebp]
  00031	76 05		 jbe	 SHORT $LN2@glm_min

; 132  :     return a;

  00033	d9 45 08	 fld	 DWORD PTR _a$[ebp]
  00036	eb 03		 jmp	 SHORT $LN1@glm_min
$LN2@glm_min:

; 133  :   return b;

  00038	d9 45 0c	 fld	 DWORD PTR _b$[ebp]
$LN1@glm_min:

; 134  : }

  0003b	5f		 pop	 edi
  0003c	5e		 pop	 esi
  0003d	5b		 pop	 ebx
  0003e	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00044	3b ec		 cmp	 ebp, esp
  00046	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004b	8b e5		 mov	 esp, ebp
  0004d	5d		 pop	 ebp
  0004e	c3		 ret	 0
_glm_min ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Light\source\repos\3DRendC\include\util.h
;	COMDAT _glm_pow2
_TEXT	SEGMENT
tv68 = -196						; size = 4
_x$ = 8							; size = 4
_glm_pow2 PROC						; COMDAT

; 118  : glm_pow2(float x) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c4 00 00
	00		 sub	 esp, 196		; 000000c4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 3c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-196]
  00012	b9 31 00 00 00	 mov	 ecx, 49			; 00000031H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __51BD2C42_util@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 119  :   return x * x;

  00028	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR _x$[ebp]
  0002d	f3 0f 59 45 08	 mulss	 xmm0, DWORD PTR _x$[ebp]
  00032	f3 0f 11 85 3c
	ff ff ff	 movss	 DWORD PTR tv68[ebp], xmm0
  0003a	d9 85 3c ff ff
	ff		 fld	 DWORD PTR tv68[ebp]

; 120  : }

  00040	5f		 pop	 edi
  00041	5e		 pop	 esi
  00042	5b		 pop	 ebx
  00043	81 c4 c4 00 00
	00		 add	 esp, 196		; 000000c4H
  00049	3b ec		 cmp	 ebp, esp
  0004b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00050	8b e5		 mov	 esp, ebp
  00052	5d		 pop	 ebp
  00053	c3		 ret	 0
_glm_pow2 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Light\source\repos\3DRendC\include\simd\x86.h
;	COMDAT _glmm_norm
_TEXT	SEGMENT
tv73 = -232						; size = 4
_a$ = -32						; size = 16
_glmm_norm PROC						; COMDAT
; _a$ = xmm0

; 150  : glmm_norm(__m128 a) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 f0	 and	 esp, -16		; fffffff0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec e8 00 00
	00		 sub	 esp, 232		; 000000e8H
  0001c	56		 push	 esi
  0001d	57		 push	 edi
  0001e	8d bd 18 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-232]
  00024	b9 3a 00 00 00	 mov	 ecx, 58			; 0000003aH
  00029	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002e	f3 ab		 rep stosd
  00030	0f 29 45 e0	 movaps	 XMMWORD PTR _a$[ebp], xmm0
  00034	b9 00 00 00 00	 mov	 ecx, OFFSET __D164993B_x86@h
  00039	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 151  :   return _mm_cvtss_f32(_mm_sqrt_ss(glmm_vhadds(_mm_mul_ps(a, a))));

  0003e	0f 28 45 e0	 movaps	 xmm0, XMMWORD PTR _a$[ebp]
  00042	0f 59 45 e0	 mulps	 xmm0, XMMWORD PTR _a$[ebp]
  00046	e8 00 00 00 00	 call	 _glmm_vhadds
  0004b	f3 0f 51 c0	 sqrtss	 xmm0, xmm0
  0004f	f3 0f 11 85 18
	ff ff ff	 movss	 DWORD PTR tv73[ebp], xmm0
  00057	d9 85 18 ff ff
	ff		 fld	 DWORD PTR tv73[ebp]

; 152  : }

  0005d	5f		 pop	 edi
  0005e	5e		 pop	 esi
  0005f	8b e5		 mov	 esp, ebp
  00061	5d		 pop	 ebp
  00062	8b e3		 mov	 esp, ebx
  00064	5b		 pop	 ebx
  00065	c3		 ret	 0
_glmm_norm ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Light\source\repos\3DRendC\include\simd\x86.h
;	COMDAT _glmm_vhadds
_TEXT	SEGMENT
_sums$ = -96						; size = 16
_shuf$ = -64						; size = 16
_v$ = -32						; size = 16
_glmm_vhadds PROC					; COMDAT
; _v$ = xmm0

; 53   : glmm_vhadds(__m128 v) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 f0	 and	 esp, -16		; fffffff0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec 28 01 00
	00		 sub	 esp, 296		; 00000128H
  0001c	56		 push	 esi
  0001d	57		 push	 edi
  0001e	8d bd d8 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-296]
  00024	b9 4a 00 00 00	 mov	 ecx, 74			; 0000004aH
  00029	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002e	f3 ab		 rep stosd
  00030	0f 29 45 e0	 movaps	 XMMWORD PTR _v$[ebp], xmm0
  00034	b9 00 00 00 00	 mov	 ecx, OFFSET __D164993B_x86@h
  00039	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 54   : #if defined(__SSE3__)
; 55   :   __m128 shuf, sums;
; 56   :   shuf = _mm_movehdup_ps(v);
; 57   :   sums = _mm_add_ps(v, shuf);
; 58   :   shuf = _mm_movehl_ps(shuf, sums);
; 59   :   sums = _mm_add_ss(sums, shuf);
; 60   :   return sums;
; 61   : #else
; 62   :   __m128 shuf, sums;
; 63   :   shuf = glmm_shuff1(v, 2, 3, 0, 1);

  0003e	0f 28 45 e0	 movaps	 xmm0, XMMWORD PTR _v$[ebp]
  00042	0f c6 45 e0 b1	 shufps	 xmm0, XMMWORD PTR _v$[ebp], 177 ; 000000b1H
  00047	0f 29 45 c0	 movaps	 XMMWORD PTR _shuf$[ebp], xmm0

; 64   :   sums = _mm_add_ps(v, shuf);

  0004b	0f 28 45 e0	 movaps	 xmm0, XMMWORD PTR _v$[ebp]
  0004f	0f 58 45 c0	 addps	 xmm0, XMMWORD PTR _shuf$[ebp]
  00053	0f 29 45 a0	 movaps	 XMMWORD PTR _sums$[ebp], xmm0

; 65   :   shuf = _mm_movehl_ps(shuf, sums);

  00057	0f 28 45 a0	 movaps	 xmm0, XMMWORD PTR _sums$[ebp]
  0005b	0f 28 4d c0	 movaps	 xmm1, XMMWORD PTR _shuf$[ebp]
  0005f	0f 12 c8	 movhlps xmm1, xmm0
  00062	0f 29 4d c0	 movaps	 XMMWORD PTR _shuf$[ebp], xmm1

; 66   :   sums = _mm_add_ss(sums, shuf);

  00066	0f 28 45 a0	 movaps	 xmm0, XMMWORD PTR _sums$[ebp]
  0006a	f3 0f 58 45 c0	 addss	 xmm0, XMMWORD PTR _shuf$[ebp]
  0006f	0f 29 45 a0	 movaps	 XMMWORD PTR _sums$[ebp], xmm0

; 67   :   return sums;

  00073	0f 28 45 a0	 movaps	 xmm0, XMMWORD PTR _sums$[ebp]

; 68   : #endif
; 69   : }

  00077	5f		 pop	 edi
  00078	5e		 pop	 esi
  00079	8b e5		 mov	 esp, ebp
  0007b	5d		 pop	 ebp
  0007c	8b e3		 mov	 esp, ebx
  0007e	5b		 pop	 ebx
  0007f	c3		 ret	 0
_glmm_vhadds ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_math.h
;	COMDAT _sqrtf
_TEXT	SEGMENT
tv72 = -196						; size = 4
__X$ = 8						; size = 4
_sqrtf	PROC						; COMDAT

; 759  :         {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c4 00 00
	00		 sub	 esp, 196		; 000000c4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 3c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-196]
  00012	b9 31 00 00 00	 mov	 ecx, 49			; 00000031H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __09340588_corecrt_math@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 760  :             return (float)sqrt(_X);

  00028	f3 0f 5a 45 08	 cvtss2sd xmm0, DWORD PTR __X$[ebp]
  0002d	83 ec 08	 sub	 esp, 8
  00030	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00035	e8 00 00 00 00	 call	 _sqrt
  0003a	83 c4 08	 add	 esp, 8
  0003d	d9 9d 3c ff ff
	ff		 fstp	 DWORD PTR tv72[ebp]
  00043	d9 85 3c ff ff
	ff		 fld	 DWORD PTR tv72[ebp]

; 761  :         }

  00049	5f		 pop	 edi
  0004a	5e		 pop	 esi
  0004b	5b		 pop	 ebx
  0004c	81 c4 c4 00 00
	00		 add	 esp, 196		; 000000c4H
  00052	3b ec		 cmp	 ebp, esp
  00054	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00059	8b e5		 mov	 esp, ebp
  0005b	5d		 pop	 ebp
  0005c	c3		 ret	 0
_sqrtf	ENDP
_TEXT	ENDS
END
