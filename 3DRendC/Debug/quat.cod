; Listing generated by Microsoft (R) Optimizing Compiler Version 19.27.29111.0 

	TITLE	C:\Users\Light\source\repos\3DRendC\glmc\quat.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

msvcjmc	SEGMENT
__09340588_corecrt_math@h DB 01H
__B0C4CEA9_malloc@h DB 01H
__AF08451A_xmmintrin@h DB 01H
__D164993B_x86@h DB 01H
__51BD2C42_util@h DB 01H
__34F2E310_vec2-ext@h DB 01H
__83360300_vec2@h DB 01H
__9285E8A4_vec3-ext@h DB 01H
__5722D62A_vec4-ext@h DB 01H
__87BB7FB2_vec4@h DB 01H
__82F46937_vec3@h DB 01H
__6C51F661_mat4@h DB 01H
__D6E4440C_mat4@h DB 01H
__691EE0E4_mat3@h DB 01H
__D3AB5289_mat3@h DB 01H
__68DC8AD3_mat2@h DB 01H
__D26938BE_mat2@h DB 01H
__EF0FC99D_affine@h DB 01H
__8C09B87C_affine-mat@h DB 01H
__1A33B462_affine@h DB 01H
__26C2D243_plane@h DB 01H
__B1B2DC28_cam@h DB 01H
__26922CBA_frustum@h DB 01H
__9A782FAE_quat@h DB 01H
__20CD9DC3_quat@h DB 01H
__0105C43C_euler@h DB 01H
__76E0E330_box@h DB 01H
__AF25309F_color@h DB 01H
__F66CEB67_corecrt_stdio_config@h DB 01H
__101834BA_corecrt_wstdio@h DB 01H
__AD6A91B7_stdio@h DB 01H
__98FD395E_io@h DB 01H
__253AA91C_project@h DB 01H
__C5964F96_sphere@h DB 01H
__CA1EBA5F_ease@h DB 01H
__E6C09561_curve@h DB 01H
__1F285908_bezier@h DB 01H
__F71D69B6_ray@h DB 01H
__C07C9586_affine2d@h DB 01H
__3F8BA224_vec3@h DB 01H
__3AC4B4A1_vec4@h DB 01H
__F616FBFC_quat@c DB 01H
msvcjmc	ENDS
PUBLIC	_acosf
PUBLIC	_atan2f
PUBLIC	_cosf
PUBLIC	_fabsf
PUBLIC	_sinf
PUBLIC	_sqrtf
PUBLIC	_glm_min
PUBLIC	_glm_max
PUBLIC	_glm_clamp
PUBLIC	_glm_clamp_zo
PUBLIC	_glm_vec4_broadcast
PUBLIC	_glm_vec4
PUBLIC	_glm_vec4_copy
PUBLIC	_glm_vec4_dot
PUBLIC	_glm_vec4_norm2
PUBLIC	_glm_vec4_norm
PUBLIC	_glm_vec4_add
PUBLIC	_glm_vec4_sub
PUBLIC	_glm_vec4_mul
PUBLIC	_glm_vec4_scale
PUBLIC	_glm_vec4_negate_to
PUBLIC	_glm_vec4_negate
PUBLIC	_glm_vec4_lerp
PUBLIC	_glm_vec4_lerpc
PUBLIC	_glm_vec3
PUBLIC	_glm_vec3_copy
PUBLIC	_glm_vec3_zero
PUBLIC	_glm_vec3_dot
PUBLIC	_glm_vec3_norm2
PUBLIC	_glm_vec3_norm
PUBLIC	_glm_vec3_add
PUBLIC	_glm_vec3_sub
PUBLIC	_glm_vec3_scale
PUBLIC	_glm_vec3_negate_to
PUBLIC	_glm_vec3_negate
PUBLIC	_glm_vec3_normalize
PUBLIC	_glm_vec3_normalize_to
PUBLIC	_glm_vec3_cross
PUBLIC	_glm_vec3_crossn
PUBLIC	_glm_normalize_to
PUBLIC	_glm_mat4_mulv_sse2
PUBLIC	_glm_mat4_copy
PUBLIC	_glm_mat4_identity
PUBLIC	_glm_mat4_mulv
PUBLIC	_glm_mat4_mulv3
PUBLIC	_glm_mat3_quat
PUBLIC	_glm_mul_rot_sse2
PUBLIC	_glm_mul_rot
PUBLIC	_glm_translate
PUBLIC	_glm_translate_make
PUBLIC	_glm_quat_mul_sse2
PUBLIC	_glm_quat_identity
PUBLIC	_glm_quat_identity_array
PUBLIC	_glm_quat_init
PUBLIC	_glm_quatv
PUBLIC	_glm_quat
PUBLIC	_glm_quat_copy
PUBLIC	_glm_quat_norm
PUBLIC	_glm_quat_normalize_to
PUBLIC	_glm_quat_normalize
PUBLIC	_glm_quat_dot
PUBLIC	_glm_quat_conjugate
PUBLIC	_glm_quat_inv
PUBLIC	_glm_quat_add
PUBLIC	_glm_quat_sub
PUBLIC	_glm_quat_real
PUBLIC	_glm_quat_imag
PUBLIC	_glm_quat_imagn
PUBLIC	_glm_quat_imaglen
PUBLIC	_glm_quat_angle
PUBLIC	_glm_quat_axis
PUBLIC	_glm_quat_mul
PUBLIC	_glm_quat_mat4
PUBLIC	_glm_quat_mat4t
PUBLIC	_glm_quat_mat3
PUBLIC	_glm_quat_mat3t
PUBLIC	_glm_quat_lerp
PUBLIC	_glm_quat_lerpc
PUBLIC	_glm_quat_slerp
PUBLIC	_glm_quat_look
PUBLIC	_glm_quat_for
PUBLIC	_glm_quat_forp
PUBLIC	_glm_quat_rotatev
PUBLIC	_glm_quat_rotate
PUBLIC	_glm_quat_rotate_at
PUBLIC	_glm_quat_rotate_atm
PUBLIC	_glmc_quat_identity
PUBLIC	_glmc_quat_identity_array
PUBLIC	_glmc_quat_init
PUBLIC	_glmc_quat
PUBLIC	_glmc_quatv
PUBLIC	_glmc_quat_copy
PUBLIC	_glmc_quat_norm
PUBLIC	_glmc_quat_normalize_to
PUBLIC	_glmc_quat_normalize
PUBLIC	_glmc_quat_dot
PUBLIC	_glmc_quat_conjugate
PUBLIC	_glmc_quat_inv
PUBLIC	_glmc_quat_add
PUBLIC	_glmc_quat_sub
PUBLIC	_glmc_quat_real
PUBLIC	_glmc_quat_imag
PUBLIC	_glmc_quat_imagn
PUBLIC	_glmc_quat_imaglen
PUBLIC	_glmc_quat_angle
PUBLIC	_glmc_quat_axis
PUBLIC	_glmc_quat_mul
PUBLIC	_glmc_quat_mat4
PUBLIC	_glmc_quat_mat4t
PUBLIC	_glmc_quat_mat3
PUBLIC	_glmc_quat_mat3t
PUBLIC	_glmc_quat_lerp
PUBLIC	_glmc_quat_lerpc
PUBLIC	_glmc_quat_slerp
PUBLIC	_glmc_quat_look
PUBLIC	_glmc_quat_for
PUBLIC	_glmc_quat_forp
PUBLIC	_glmc_quat_rotatev
PUBLIC	_glmc_quat_rotate
PUBLIC	_glmc_quat_rotate_at
PUBLIC	_glmc_quat_rotate_atm
PUBLIC	__JustMyCode_Default
PUBLIC	__real@00000000
PUBLIC	__real@3a83126f
PUBLIC	__real@3f000000
PUBLIC	__real@3f800000
PUBLIC	__real@40000000
PUBLIC	__xmm@80000000000000000000000080000000
PUBLIC	__xmm@80000000000000008000000000000000
PUBLIC	__xmm@80000000800000000000000000000000
PUBLIC	__xmm@80000000800000008000000080000000
EXTRN	_acos:PROC
EXTRN	_atan2:PROC
EXTRN	_cos:PROC
EXTRN	_fabs:PROC
EXTRN	_sin:PROC
EXTRN	_sqrt:PROC
EXTRN	@_RTC_CheckStackVars@8:PROC
EXTRN	@__CheckForDebuggerJustMyCode@4:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
;	COMDAT __xmm@80000000800000008000000080000000
CONST	SEGMENT
__xmm@80000000800000008000000080000000 DB 00H, 00H, 00H, 080H, 00H, 00H, 00H
	DB	080H, 00H, 00H, 00H, 080H, 00H, 00H, 00H, 080H
CONST	ENDS
;	COMDAT __xmm@80000000800000000000000000000000
CONST	SEGMENT
__xmm@80000000800000000000000000000000 DB 00H, 00H, 00H, 00H, 00H, 00H, 00H
	DB	00H, 00H, 00H, 00H, 080H, 00H, 00H, 00H, 080H
CONST	ENDS
;	COMDAT __xmm@80000000000000008000000000000000
CONST	SEGMENT
__xmm@80000000000000008000000000000000 DB 00H, 00H, 00H, 00H, 00H, 00H, 00H
	DB	080H, 00H, 00H, 00H, 00H, 00H, 00H, 00H, 080H
CONST	ENDS
;	COMDAT __xmm@80000000000000000000000080000000
CONST	SEGMENT
__xmm@80000000000000000000000080000000 DB 00H, 00H, 00H, 080H, 00H, 00H, 00H
	DB	00H, 00H, 00H, 00H, 00H, 00H, 00H, 00H, 080H
CONST	ENDS
;	COMDAT __real@40000000
CONST	SEGMENT
__real@40000000 DD 040000000r			; 2
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@3f000000
CONST	SEGMENT
__real@3f000000 DD 03f000000r			; 0.5
CONST	ENDS
;	COMDAT __real@3a83126f
CONST	SEGMENT
__real@3a83126f DD 03a83126fr			; 0.001
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
; Function compile flags: /Odt
;	COMDAT __JustMyCode_Default
_TEXT	SEGMENT
__JustMyCode_Default PROC				; COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
__JustMyCode_Default ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Light\source\repos\3DRendC\glmc\quat.c
;	COMDAT _glmc_quat_rotate_atm
_TEXT	SEGMENT
_m$ = 8							; size = 4
_q$ = 12						; size = 4
_pivot$ = 16						; size = 4
_glmc_quat_rotate_atm PROC				; COMDAT

; 217  : glmc_quat_rotate_atm(mat4 m, versor q, vec3 pivot) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __F616FBFC_quat@c
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 218  :   glm_quat_rotate_atm(m, q, pivot);

  00028	8b 45 10	 mov	 eax, DWORD PTR _pivot$[ebp]
  0002b	50		 push	 eax
  0002c	8b 4d 0c	 mov	 ecx, DWORD PTR _q$[ebp]
  0002f	51		 push	 ecx
  00030	8b 55 08	 mov	 edx, DWORD PTR _m$[ebp]
  00033	52		 push	 edx
  00034	e8 00 00 00 00	 call	 _glm_quat_rotate_atm
  00039	83 c4 0c	 add	 esp, 12			; 0000000cH

; 219  : }

  0003c	5f		 pop	 edi
  0003d	5e		 pop	 esi
  0003e	5b		 pop	 ebx
  0003f	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00045	3b ec		 cmp	 ebp, esp
  00047	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004c	8b e5		 mov	 esp, ebp
  0004e	5d		 pop	 ebp
  0004f	c3		 ret	 0
_glmc_quat_rotate_atm ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Light\source\repos\3DRendC\glmc\quat.c
;	COMDAT _glmc_quat_rotate_at
_TEXT	SEGMENT
_model$ = 8						; size = 4
_q$ = 12						; size = 4
_pivot$ = 16						; size = 4
_glmc_quat_rotate_at PROC				; COMDAT

; 211  : glmc_quat_rotate_at(mat4 model, versor q, vec3 pivot) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __F616FBFC_quat@c
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 212  :   glm_quat_rotate_at(model, q, pivot);

  00028	8b 45 10	 mov	 eax, DWORD PTR _pivot$[ebp]
  0002b	50		 push	 eax
  0002c	8b 4d 0c	 mov	 ecx, DWORD PTR _q$[ebp]
  0002f	51		 push	 ecx
  00030	8b 55 08	 mov	 edx, DWORD PTR _model$[ebp]
  00033	52		 push	 edx
  00034	e8 00 00 00 00	 call	 _glm_quat_rotate_at
  00039	83 c4 0c	 add	 esp, 12			; 0000000cH

; 213  : }

  0003c	5f		 pop	 edi
  0003d	5e		 pop	 esi
  0003e	5b		 pop	 ebx
  0003f	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00045	3b ec		 cmp	 ebp, esp
  00047	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004c	8b e5		 mov	 esp, ebp
  0004e	5d		 pop	 ebp
  0004f	c3		 ret	 0
_glmc_quat_rotate_at ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Light\source\repos\3DRendC\glmc\quat.c
;	COMDAT _glmc_quat_rotate
_TEXT	SEGMENT
_m$ = 8							; size = 4
_q$ = 12						; size = 4
_dest$ = 16						; size = 4
_glmc_quat_rotate PROC					; COMDAT

; 205  : glmc_quat_rotate(mat4 m, versor q, mat4 dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __F616FBFC_quat@c
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 206  :   glm_quat_rotate(m, q, dest);

  00028	8b 45 10	 mov	 eax, DWORD PTR _dest$[ebp]
  0002b	50		 push	 eax
  0002c	8b 4d 0c	 mov	 ecx, DWORD PTR _q$[ebp]
  0002f	51		 push	 ecx
  00030	8b 55 08	 mov	 edx, DWORD PTR _m$[ebp]
  00033	52		 push	 edx
  00034	e8 00 00 00 00	 call	 _glm_quat_rotate
  00039	83 c4 0c	 add	 esp, 12			; 0000000cH

; 207  : }

  0003c	5f		 pop	 edi
  0003d	5e		 pop	 esi
  0003e	5b		 pop	 ebx
  0003f	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00045	3b ec		 cmp	 ebp, esp
  00047	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004c	8b e5		 mov	 esp, ebp
  0004e	5d		 pop	 ebp
  0004f	c3		 ret	 0
_glmc_quat_rotate ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Light\source\repos\3DRendC\glmc\quat.c
;	COMDAT _glmc_quat_rotatev
_TEXT	SEGMENT
_q$ = 8							; size = 4
_v$ = 12						; size = 4
_dest$ = 16						; size = 4
_glmc_quat_rotatev PROC					; COMDAT

; 199  : glmc_quat_rotatev(versor q, vec3 v, vec3 dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __F616FBFC_quat@c
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 200  :   glm_quat_rotatev(q, v, dest);

  00028	8b 45 10	 mov	 eax, DWORD PTR _dest$[ebp]
  0002b	50		 push	 eax
  0002c	8b 4d 0c	 mov	 ecx, DWORD PTR _v$[ebp]
  0002f	51		 push	 ecx
  00030	8b 55 08	 mov	 edx, DWORD PTR _q$[ebp]
  00033	52		 push	 edx
  00034	e8 00 00 00 00	 call	 _glm_quat_rotatev
  00039	83 c4 0c	 add	 esp, 12			; 0000000cH

; 201  : }

  0003c	5f		 pop	 edi
  0003d	5e		 pop	 esi
  0003e	5b		 pop	 ebx
  0003f	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00045	3b ec		 cmp	 ebp, esp
  00047	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004c	8b e5		 mov	 esp, ebp
  0004e	5d		 pop	 ebp
  0004f	c3		 ret	 0
_glmc_quat_rotatev ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Light\source\repos\3DRendC\glmc\quat.c
;	COMDAT _glmc_quat_forp
_TEXT	SEGMENT
_from$ = 8						; size = 4
_to$ = 12						; size = 4
_up$ = 16						; size = 4
_dest$ = 20						; size = 4
_glmc_quat_forp PROC					; COMDAT

; 193  : glmc_quat_forp(vec3 from, vec3 to, vec3 up, versor dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __F616FBFC_quat@c
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 194  :   glm_quat_forp(from, to, up, dest);

  00028	8b 45 14	 mov	 eax, DWORD PTR _dest$[ebp]
  0002b	50		 push	 eax
  0002c	8b 4d 10	 mov	 ecx, DWORD PTR _up$[ebp]
  0002f	51		 push	 ecx
  00030	8b 55 0c	 mov	 edx, DWORD PTR _to$[ebp]
  00033	52		 push	 edx
  00034	8b 45 08	 mov	 eax, DWORD PTR _from$[ebp]
  00037	50		 push	 eax
  00038	e8 00 00 00 00	 call	 _glm_quat_forp
  0003d	83 c4 10	 add	 esp, 16			; 00000010H

; 195  : }

  00040	5f		 pop	 edi
  00041	5e		 pop	 esi
  00042	5b		 pop	 ebx
  00043	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00049	3b ec		 cmp	 ebp, esp
  0004b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00050	8b e5		 mov	 esp, ebp
  00052	5d		 pop	 ebp
  00053	c3		 ret	 0
_glmc_quat_forp ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Light\source\repos\3DRendC\glmc\quat.c
;	COMDAT _glmc_quat_for
_TEXT	SEGMENT
_dir$ = 8						; size = 4
_up$ = 12						; size = 4
_dest$ = 16						; size = 4
_glmc_quat_for PROC					; COMDAT

; 187  : glmc_quat_for(vec3 dir, vec3 up, versor dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __F616FBFC_quat@c
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 188  :   glm_quat_for(dir, up, dest);

  00028	8b 45 10	 mov	 eax, DWORD PTR _dest$[ebp]
  0002b	50		 push	 eax
  0002c	8b 4d 0c	 mov	 ecx, DWORD PTR _up$[ebp]
  0002f	51		 push	 ecx
  00030	8b 55 08	 mov	 edx, DWORD PTR _dir$[ebp]
  00033	52		 push	 edx
  00034	e8 00 00 00 00	 call	 _glm_quat_for
  00039	83 c4 0c	 add	 esp, 12			; 0000000cH

; 189  : }

  0003c	5f		 pop	 edi
  0003d	5e		 pop	 esi
  0003e	5b		 pop	 ebx
  0003f	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00045	3b ec		 cmp	 ebp, esp
  00047	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004c	8b e5		 mov	 esp, ebp
  0004e	5d		 pop	 ebp
  0004f	c3		 ret	 0
_glmc_quat_for ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Light\source\repos\3DRendC\glmc\quat.c
;	COMDAT _glmc_quat_look
_TEXT	SEGMENT
_eye$ = 8						; size = 4
_ori$ = 12						; size = 4
_dest$ = 16						; size = 4
_glmc_quat_look PROC					; COMDAT

; 181  : glmc_quat_look(vec3 eye, versor ori, mat4 dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __F616FBFC_quat@c
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 182  :   glm_quat_look(eye, ori, dest);

  00028	8b 45 10	 mov	 eax, DWORD PTR _dest$[ebp]
  0002b	50		 push	 eax
  0002c	8b 4d 0c	 mov	 ecx, DWORD PTR _ori$[ebp]
  0002f	51		 push	 ecx
  00030	8b 55 08	 mov	 edx, DWORD PTR _eye$[ebp]
  00033	52		 push	 edx
  00034	e8 00 00 00 00	 call	 _glm_quat_look
  00039	83 c4 0c	 add	 esp, 12			; 0000000cH

; 183  : }

  0003c	5f		 pop	 edi
  0003d	5e		 pop	 esi
  0003e	5b		 pop	 ebx
  0003f	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00045	3b ec		 cmp	 ebp, esp
  00047	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004c	8b e5		 mov	 esp, ebp
  0004e	5d		 pop	 ebp
  0004f	c3		 ret	 0
_glmc_quat_look ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Light\source\repos\3DRendC\glmc\quat.c
;	COMDAT _glmc_quat_slerp
_TEXT	SEGMENT
_from$ = 8						; size = 4
_to$ = 12						; size = 4
_t$ = 16						; size = 4
_dest$ = 20						; size = 4
_glmc_quat_slerp PROC					; COMDAT

; 175  : glmc_quat_slerp(versor from, versor to, float t, versor dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __F616FBFC_quat@c
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 176  :   glm_quat_slerp(from, to, t, dest);

  00028	8b 45 14	 mov	 eax, DWORD PTR _dest$[ebp]
  0002b	50		 push	 eax
  0002c	51		 push	 ecx
  0002d	f3 0f 10 45 10	 movss	 xmm0, DWORD PTR _t$[ebp]
  00032	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00037	8b 4d 0c	 mov	 ecx, DWORD PTR _to$[ebp]
  0003a	51		 push	 ecx
  0003b	8b 55 08	 mov	 edx, DWORD PTR _from$[ebp]
  0003e	52		 push	 edx
  0003f	e8 00 00 00 00	 call	 _glm_quat_slerp
  00044	83 c4 10	 add	 esp, 16			; 00000010H

; 177  : }

  00047	5f		 pop	 edi
  00048	5e		 pop	 esi
  00049	5b		 pop	 ebx
  0004a	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00050	3b ec		 cmp	 ebp, esp
  00052	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00057	8b e5		 mov	 esp, ebp
  00059	5d		 pop	 ebp
  0005a	c3		 ret	 0
_glmc_quat_slerp ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Light\source\repos\3DRendC\glmc\quat.c
;	COMDAT _glmc_quat_lerpc
_TEXT	SEGMENT
_from$ = 8						; size = 4
_to$ = 12						; size = 4
_t$ = 16						; size = 4
_dest$ = 20						; size = 4
_glmc_quat_lerpc PROC					; COMDAT

; 169  : glmc_quat_lerpc(versor from, versor to, float t, versor dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __F616FBFC_quat@c
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 170  :   glm_quat_lerpc(from, to, t, dest);

  00028	8b 45 14	 mov	 eax, DWORD PTR _dest$[ebp]
  0002b	50		 push	 eax
  0002c	51		 push	 ecx
  0002d	f3 0f 10 45 10	 movss	 xmm0, DWORD PTR _t$[ebp]
  00032	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00037	8b 4d 0c	 mov	 ecx, DWORD PTR _to$[ebp]
  0003a	51		 push	 ecx
  0003b	8b 55 08	 mov	 edx, DWORD PTR _from$[ebp]
  0003e	52		 push	 edx
  0003f	e8 00 00 00 00	 call	 _glm_quat_lerpc
  00044	83 c4 10	 add	 esp, 16			; 00000010H

; 171  : }

  00047	5f		 pop	 edi
  00048	5e		 pop	 esi
  00049	5b		 pop	 ebx
  0004a	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00050	3b ec		 cmp	 ebp, esp
  00052	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00057	8b e5		 mov	 esp, ebp
  00059	5d		 pop	 ebp
  0005a	c3		 ret	 0
_glmc_quat_lerpc ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Light\source\repos\3DRendC\glmc\quat.c
;	COMDAT _glmc_quat_lerp
_TEXT	SEGMENT
_from$ = 8						; size = 4
_to$ = 12						; size = 4
_t$ = 16						; size = 4
_dest$ = 20						; size = 4
_glmc_quat_lerp PROC					; COMDAT

; 163  : glmc_quat_lerp(versor from, versor to, float t, versor dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __F616FBFC_quat@c
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 164  :   glm_quat_lerp(from, to, t, dest);

  00028	8b 45 14	 mov	 eax, DWORD PTR _dest$[ebp]
  0002b	50		 push	 eax
  0002c	51		 push	 ecx
  0002d	f3 0f 10 45 10	 movss	 xmm0, DWORD PTR _t$[ebp]
  00032	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00037	8b 4d 0c	 mov	 ecx, DWORD PTR _to$[ebp]
  0003a	51		 push	 ecx
  0003b	8b 55 08	 mov	 edx, DWORD PTR _from$[ebp]
  0003e	52		 push	 edx
  0003f	e8 00 00 00 00	 call	 _glm_quat_lerp
  00044	83 c4 10	 add	 esp, 16			; 00000010H

; 165  : }

  00047	5f		 pop	 edi
  00048	5e		 pop	 esi
  00049	5b		 pop	 ebx
  0004a	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00050	3b ec		 cmp	 ebp, esp
  00052	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00057	8b e5		 mov	 esp, ebp
  00059	5d		 pop	 ebp
  0005a	c3		 ret	 0
_glmc_quat_lerp ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Light\source\repos\3DRendC\glmc\quat.c
;	COMDAT _glmc_quat_mat3t
_TEXT	SEGMENT
_q$ = 8							; size = 4
_dest$ = 12						; size = 4
_glmc_quat_mat3t PROC					; COMDAT

; 157  : glmc_quat_mat3t(versor q, mat3 dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __F616FBFC_quat@c
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 158  :   glm_quat_mat3t(q, dest);

  00028	8b 45 0c	 mov	 eax, DWORD PTR _dest$[ebp]
  0002b	50		 push	 eax
  0002c	8b 4d 08	 mov	 ecx, DWORD PTR _q$[ebp]
  0002f	51		 push	 ecx
  00030	e8 00 00 00 00	 call	 _glm_quat_mat3t
  00035	83 c4 08	 add	 esp, 8

; 159  : }

  00038	5f		 pop	 edi
  00039	5e		 pop	 esi
  0003a	5b		 pop	 ebx
  0003b	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00041	3b ec		 cmp	 ebp, esp
  00043	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00048	8b e5		 mov	 esp, ebp
  0004a	5d		 pop	 ebp
  0004b	c3		 ret	 0
_glmc_quat_mat3t ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Light\source\repos\3DRendC\glmc\quat.c
;	COMDAT _glmc_quat_mat3
_TEXT	SEGMENT
_q$ = 8							; size = 4
_dest$ = 12						; size = 4
_glmc_quat_mat3 PROC					; COMDAT

; 151  : glmc_quat_mat3(versor q, mat3 dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __F616FBFC_quat@c
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 152  :   glm_quat_mat3(q, dest);

  00028	8b 45 0c	 mov	 eax, DWORD PTR _dest$[ebp]
  0002b	50		 push	 eax
  0002c	8b 4d 08	 mov	 ecx, DWORD PTR _q$[ebp]
  0002f	51		 push	 ecx
  00030	e8 00 00 00 00	 call	 _glm_quat_mat3
  00035	83 c4 08	 add	 esp, 8

; 153  : }

  00038	5f		 pop	 edi
  00039	5e		 pop	 esi
  0003a	5b		 pop	 ebx
  0003b	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00041	3b ec		 cmp	 ebp, esp
  00043	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00048	8b e5		 mov	 esp, ebp
  0004a	5d		 pop	 ebp
  0004b	c3		 ret	 0
_glmc_quat_mat3 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Light\source\repos\3DRendC\glmc\quat.c
;	COMDAT _glmc_quat_mat4t
_TEXT	SEGMENT
_q$ = 8							; size = 4
_dest$ = 12						; size = 4
_glmc_quat_mat4t PROC					; COMDAT

; 145  : glmc_quat_mat4t(versor q, mat4 dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __F616FBFC_quat@c
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 146  :   glm_quat_mat4t(q, dest);

  00028	8b 45 0c	 mov	 eax, DWORD PTR _dest$[ebp]
  0002b	50		 push	 eax
  0002c	8b 4d 08	 mov	 ecx, DWORD PTR _q$[ebp]
  0002f	51		 push	 ecx
  00030	e8 00 00 00 00	 call	 _glm_quat_mat4t
  00035	83 c4 08	 add	 esp, 8

; 147  : }

  00038	5f		 pop	 edi
  00039	5e		 pop	 esi
  0003a	5b		 pop	 ebx
  0003b	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00041	3b ec		 cmp	 ebp, esp
  00043	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00048	8b e5		 mov	 esp, ebp
  0004a	5d		 pop	 ebp
  0004b	c3		 ret	 0
_glmc_quat_mat4t ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Light\source\repos\3DRendC\glmc\quat.c
;	COMDAT _glmc_quat_mat4
_TEXT	SEGMENT
_q$ = 8							; size = 4
_dest$ = 12						; size = 4
_glmc_quat_mat4 PROC					; COMDAT

; 139  : glmc_quat_mat4(versor q, mat4 dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __F616FBFC_quat@c
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 140  :   glm_quat_mat4(q, dest);

  00028	8b 45 0c	 mov	 eax, DWORD PTR _dest$[ebp]
  0002b	50		 push	 eax
  0002c	8b 4d 08	 mov	 ecx, DWORD PTR _q$[ebp]
  0002f	51		 push	 ecx
  00030	e8 00 00 00 00	 call	 _glm_quat_mat4
  00035	83 c4 08	 add	 esp, 8

; 141  : }

  00038	5f		 pop	 edi
  00039	5e		 pop	 esi
  0003a	5b		 pop	 ebx
  0003b	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00041	3b ec		 cmp	 ebp, esp
  00043	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00048	8b e5		 mov	 esp, ebp
  0004a	5d		 pop	 ebp
  0004b	c3		 ret	 0
_glmc_quat_mat4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Light\source\repos\3DRendC\glmc\quat.c
;	COMDAT _glmc_quat_mul
_TEXT	SEGMENT
_p$ = 8							; size = 4
_q$ = 12						; size = 4
_dest$ = 16						; size = 4
_glmc_quat_mul PROC					; COMDAT

; 133  : glmc_quat_mul(versor p, versor q, versor dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __F616FBFC_quat@c
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 134  :   glm_quat_mul(p, q, dest);

  00028	8b 45 10	 mov	 eax, DWORD PTR _dest$[ebp]
  0002b	50		 push	 eax
  0002c	8b 4d 0c	 mov	 ecx, DWORD PTR _q$[ebp]
  0002f	51		 push	 ecx
  00030	8b 55 08	 mov	 edx, DWORD PTR _p$[ebp]
  00033	52		 push	 edx
  00034	e8 00 00 00 00	 call	 _glm_quat_mul
  00039	83 c4 0c	 add	 esp, 12			; 0000000cH

; 135  : }

  0003c	5f		 pop	 edi
  0003d	5e		 pop	 esi
  0003e	5b		 pop	 ebx
  0003f	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00045	3b ec		 cmp	 ebp, esp
  00047	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004c	8b e5		 mov	 esp, ebp
  0004e	5d		 pop	 ebp
  0004f	c3		 ret	 0
_glmc_quat_mul ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Light\source\repos\3DRendC\glmc\quat.c
;	COMDAT _glmc_quat_axis
_TEXT	SEGMENT
_q$ = 8							; size = 4
_dest$ = 12						; size = 4
_glmc_quat_axis PROC					; COMDAT

; 127  : glmc_quat_axis(versor q, vec3 dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __F616FBFC_quat@c
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 128  :   glm_quat_axis(q, dest);

  00028	8b 45 0c	 mov	 eax, DWORD PTR _dest$[ebp]
  0002b	50		 push	 eax
  0002c	8b 4d 08	 mov	 ecx, DWORD PTR _q$[ebp]
  0002f	51		 push	 ecx
  00030	e8 00 00 00 00	 call	 _glm_quat_axis
  00035	83 c4 08	 add	 esp, 8

; 129  : }

  00038	5f		 pop	 edi
  00039	5e		 pop	 esi
  0003a	5b		 pop	 ebx
  0003b	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00041	3b ec		 cmp	 ebp, esp
  00043	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00048	8b e5		 mov	 esp, ebp
  0004a	5d		 pop	 ebp
  0004b	c3		 ret	 0
_glmc_quat_axis ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Light\source\repos\3DRendC\glmc\quat.c
;	COMDAT _glmc_quat_angle
_TEXT	SEGMENT
_q$ = 8							; size = 4
_glmc_quat_angle PROC					; COMDAT

; 121  : glmc_quat_angle(versor q) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __F616FBFC_quat@c
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 122  :   return glm_quat_angle(q);

  00028	8b 45 08	 mov	 eax, DWORD PTR _q$[ebp]
  0002b	50		 push	 eax
  0002c	e8 00 00 00 00	 call	 _glm_quat_angle
  00031	83 c4 04	 add	 esp, 4

; 123  : }

  00034	5f		 pop	 edi
  00035	5e		 pop	 esi
  00036	5b		 pop	 ebx
  00037	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0003d	3b ec		 cmp	 ebp, esp
  0003f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00044	8b e5		 mov	 esp, ebp
  00046	5d		 pop	 ebp
  00047	c3		 ret	 0
_glmc_quat_angle ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Light\source\repos\3DRendC\glmc\quat.c
;	COMDAT _glmc_quat_imaglen
_TEXT	SEGMENT
_q$ = 8							; size = 4
_glmc_quat_imaglen PROC					; COMDAT

; 115  : glmc_quat_imaglen(versor q) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __F616FBFC_quat@c
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 116  :   return glm_quat_imaglen(q);

  00028	8b 45 08	 mov	 eax, DWORD PTR _q$[ebp]
  0002b	50		 push	 eax
  0002c	e8 00 00 00 00	 call	 _glm_quat_imaglen
  00031	83 c4 04	 add	 esp, 4

; 117  : }

  00034	5f		 pop	 edi
  00035	5e		 pop	 esi
  00036	5b		 pop	 ebx
  00037	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0003d	3b ec		 cmp	 ebp, esp
  0003f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00044	8b e5		 mov	 esp, ebp
  00046	5d		 pop	 ebp
  00047	c3		 ret	 0
_glmc_quat_imaglen ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Light\source\repos\3DRendC\glmc\quat.c
;	COMDAT _glmc_quat_imagn
_TEXT	SEGMENT
_q$ = 8							; size = 4
_dest$ = 12						; size = 4
_glmc_quat_imagn PROC					; COMDAT

; 109  : glmc_quat_imagn(versor q, vec3 dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __F616FBFC_quat@c
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 110  :   glm_quat_imagn(q, dest);

  00028	8b 45 0c	 mov	 eax, DWORD PTR _dest$[ebp]
  0002b	50		 push	 eax
  0002c	8b 4d 08	 mov	 ecx, DWORD PTR _q$[ebp]
  0002f	51		 push	 ecx
  00030	e8 00 00 00 00	 call	 _glm_quat_imagn
  00035	83 c4 08	 add	 esp, 8

; 111  : }

  00038	5f		 pop	 edi
  00039	5e		 pop	 esi
  0003a	5b		 pop	 ebx
  0003b	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00041	3b ec		 cmp	 ebp, esp
  00043	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00048	8b e5		 mov	 esp, ebp
  0004a	5d		 pop	 ebp
  0004b	c3		 ret	 0
_glmc_quat_imagn ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Light\source\repos\3DRendC\glmc\quat.c
;	COMDAT _glmc_quat_imag
_TEXT	SEGMENT
_q$ = 8							; size = 4
_dest$ = 12						; size = 4
_glmc_quat_imag PROC					; COMDAT

; 103  : glmc_quat_imag(versor q, vec3 dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __F616FBFC_quat@c
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 104  :   glm_quat_imag(q, dest);

  00028	8b 45 0c	 mov	 eax, DWORD PTR _dest$[ebp]
  0002b	50		 push	 eax
  0002c	8b 4d 08	 mov	 ecx, DWORD PTR _q$[ebp]
  0002f	51		 push	 ecx
  00030	e8 00 00 00 00	 call	 _glm_quat_imag
  00035	83 c4 08	 add	 esp, 8

; 105  : }

  00038	5f		 pop	 edi
  00039	5e		 pop	 esi
  0003a	5b		 pop	 ebx
  0003b	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00041	3b ec		 cmp	 ebp, esp
  00043	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00048	8b e5		 mov	 esp, ebp
  0004a	5d		 pop	 ebp
  0004b	c3		 ret	 0
_glmc_quat_imag ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Light\source\repos\3DRendC\glmc\quat.c
;	COMDAT _glmc_quat_real
_TEXT	SEGMENT
_q$ = 8							; size = 4
_glmc_quat_real PROC					; COMDAT

; 97   : glmc_quat_real(versor q) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __F616FBFC_quat@c
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 98   :   return glm_quat_real(q);

  00028	8b 45 08	 mov	 eax, DWORD PTR _q$[ebp]
  0002b	50		 push	 eax
  0002c	e8 00 00 00 00	 call	 _glm_quat_real
  00031	83 c4 04	 add	 esp, 4

; 99   : }

  00034	5f		 pop	 edi
  00035	5e		 pop	 esi
  00036	5b		 pop	 ebx
  00037	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0003d	3b ec		 cmp	 ebp, esp
  0003f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00044	8b e5		 mov	 esp, ebp
  00046	5d		 pop	 ebp
  00047	c3		 ret	 0
_glmc_quat_real ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Light\source\repos\3DRendC\glmc\quat.c
;	COMDAT _glmc_quat_sub
_TEXT	SEGMENT
_p$ = 8							; size = 4
_q$ = 12						; size = 4
_dest$ = 16						; size = 4
_glmc_quat_sub PROC					; COMDAT

; 91   : glmc_quat_sub(versor p, versor q, versor dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __F616FBFC_quat@c
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 92   :   glm_quat_sub(p, q, dest);

  00028	8b 45 10	 mov	 eax, DWORD PTR _dest$[ebp]
  0002b	50		 push	 eax
  0002c	8b 4d 0c	 mov	 ecx, DWORD PTR _q$[ebp]
  0002f	51		 push	 ecx
  00030	8b 55 08	 mov	 edx, DWORD PTR _p$[ebp]
  00033	52		 push	 edx
  00034	e8 00 00 00 00	 call	 _glm_quat_sub
  00039	83 c4 0c	 add	 esp, 12			; 0000000cH

; 93   : }

  0003c	5f		 pop	 edi
  0003d	5e		 pop	 esi
  0003e	5b		 pop	 ebx
  0003f	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00045	3b ec		 cmp	 ebp, esp
  00047	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004c	8b e5		 mov	 esp, ebp
  0004e	5d		 pop	 ebp
  0004f	c3		 ret	 0
_glmc_quat_sub ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Light\source\repos\3DRendC\glmc\quat.c
;	COMDAT _glmc_quat_add
_TEXT	SEGMENT
_p$ = 8							; size = 4
_q$ = 12						; size = 4
_dest$ = 16						; size = 4
_glmc_quat_add PROC					; COMDAT

; 85   : glmc_quat_add(versor p, versor q, versor dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __F616FBFC_quat@c
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 86   :   glm_quat_add(p, q, dest);

  00028	8b 45 10	 mov	 eax, DWORD PTR _dest$[ebp]
  0002b	50		 push	 eax
  0002c	8b 4d 0c	 mov	 ecx, DWORD PTR _q$[ebp]
  0002f	51		 push	 ecx
  00030	8b 55 08	 mov	 edx, DWORD PTR _p$[ebp]
  00033	52		 push	 edx
  00034	e8 00 00 00 00	 call	 _glm_quat_add
  00039	83 c4 0c	 add	 esp, 12			; 0000000cH

; 87   : }

  0003c	5f		 pop	 edi
  0003d	5e		 pop	 esi
  0003e	5b		 pop	 ebx
  0003f	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00045	3b ec		 cmp	 ebp, esp
  00047	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004c	8b e5		 mov	 esp, ebp
  0004e	5d		 pop	 ebp
  0004f	c3		 ret	 0
_glmc_quat_add ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Light\source\repos\3DRendC\glmc\quat.c
;	COMDAT _glmc_quat_inv
_TEXT	SEGMENT
_q$ = 8							; size = 4
_dest$ = 12						; size = 4
_glmc_quat_inv PROC					; COMDAT

; 79   : glmc_quat_inv(versor q, versor dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __F616FBFC_quat@c
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 80   :   glm_quat_inv(q, dest);

  00028	8b 45 0c	 mov	 eax, DWORD PTR _dest$[ebp]
  0002b	50		 push	 eax
  0002c	8b 4d 08	 mov	 ecx, DWORD PTR _q$[ebp]
  0002f	51		 push	 ecx
  00030	e8 00 00 00 00	 call	 _glm_quat_inv
  00035	83 c4 08	 add	 esp, 8

; 81   : }

  00038	5f		 pop	 edi
  00039	5e		 pop	 esi
  0003a	5b		 pop	 ebx
  0003b	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00041	3b ec		 cmp	 ebp, esp
  00043	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00048	8b e5		 mov	 esp, ebp
  0004a	5d		 pop	 ebp
  0004b	c3		 ret	 0
_glmc_quat_inv ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Light\source\repos\3DRendC\glmc\quat.c
;	COMDAT _glmc_quat_conjugate
_TEXT	SEGMENT
_q$ = 8							; size = 4
_dest$ = 12						; size = 4
_glmc_quat_conjugate PROC				; COMDAT

; 73   : glmc_quat_conjugate(versor q, versor dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __F616FBFC_quat@c
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 74   :   glm_quat_conjugate(q, dest);

  00028	8b 45 0c	 mov	 eax, DWORD PTR _dest$[ebp]
  0002b	50		 push	 eax
  0002c	8b 4d 08	 mov	 ecx, DWORD PTR _q$[ebp]
  0002f	51		 push	 ecx
  00030	e8 00 00 00 00	 call	 _glm_quat_conjugate
  00035	83 c4 08	 add	 esp, 8

; 75   : }

  00038	5f		 pop	 edi
  00039	5e		 pop	 esi
  0003a	5b		 pop	 ebx
  0003b	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00041	3b ec		 cmp	 ebp, esp
  00043	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00048	8b e5		 mov	 esp, ebp
  0004a	5d		 pop	 ebp
  0004b	c3		 ret	 0
_glmc_quat_conjugate ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Light\source\repos\3DRendC\glmc\quat.c
;	COMDAT _glmc_quat_dot
_TEXT	SEGMENT
_p$ = 8							; size = 4
_q$ = 12						; size = 4
_glmc_quat_dot PROC					; COMDAT

; 67   : glmc_quat_dot(versor p, versor q) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __F616FBFC_quat@c
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 68   :   return glm_quat_dot(p, q);

  00028	8b 45 0c	 mov	 eax, DWORD PTR _q$[ebp]
  0002b	50		 push	 eax
  0002c	8b 4d 08	 mov	 ecx, DWORD PTR _p$[ebp]
  0002f	51		 push	 ecx
  00030	e8 00 00 00 00	 call	 _glm_quat_dot
  00035	83 c4 08	 add	 esp, 8

; 69   : }

  00038	5f		 pop	 edi
  00039	5e		 pop	 esi
  0003a	5b		 pop	 ebx
  0003b	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00041	3b ec		 cmp	 ebp, esp
  00043	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00048	8b e5		 mov	 esp, ebp
  0004a	5d		 pop	 ebp
  0004b	c3		 ret	 0
_glmc_quat_dot ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Light\source\repos\3DRendC\glmc\quat.c
;	COMDAT _glmc_quat_normalize
_TEXT	SEGMENT
_q$ = 8							; size = 4
_glmc_quat_normalize PROC				; COMDAT

; 61   : glmc_quat_normalize(versor q) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __F616FBFC_quat@c
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 62   :   glm_quat_normalize(q);

  00028	8b 45 08	 mov	 eax, DWORD PTR _q$[ebp]
  0002b	50		 push	 eax
  0002c	e8 00 00 00 00	 call	 _glm_quat_normalize
  00031	83 c4 04	 add	 esp, 4

; 63   : }

  00034	5f		 pop	 edi
  00035	5e		 pop	 esi
  00036	5b		 pop	 ebx
  00037	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0003d	3b ec		 cmp	 ebp, esp
  0003f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00044	8b e5		 mov	 esp, ebp
  00046	5d		 pop	 ebp
  00047	c3		 ret	 0
_glmc_quat_normalize ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Light\source\repos\3DRendC\glmc\quat.c
;	COMDAT _glmc_quat_normalize_to
_TEXT	SEGMENT
_q$ = 8							; size = 4
_dest$ = 12						; size = 4
_glmc_quat_normalize_to PROC				; COMDAT

; 55   : glmc_quat_normalize_to(versor q, versor dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __F616FBFC_quat@c
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 56   :   glm_quat_normalize_to(q, dest);

  00028	8b 45 0c	 mov	 eax, DWORD PTR _dest$[ebp]
  0002b	50		 push	 eax
  0002c	8b 4d 08	 mov	 ecx, DWORD PTR _q$[ebp]
  0002f	51		 push	 ecx
  00030	e8 00 00 00 00	 call	 _glm_quat_normalize_to
  00035	83 c4 08	 add	 esp, 8

; 57   : }

  00038	5f		 pop	 edi
  00039	5e		 pop	 esi
  0003a	5b		 pop	 ebx
  0003b	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00041	3b ec		 cmp	 ebp, esp
  00043	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00048	8b e5		 mov	 esp, ebp
  0004a	5d		 pop	 ebp
  0004b	c3		 ret	 0
_glmc_quat_normalize_to ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Light\source\repos\3DRendC\glmc\quat.c
;	COMDAT _glmc_quat_norm
_TEXT	SEGMENT
_q$ = 8							; size = 4
_glmc_quat_norm PROC					; COMDAT

; 49   : glmc_quat_norm(versor q) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __F616FBFC_quat@c
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 50   :   return glm_quat_norm(q);

  00028	8b 45 08	 mov	 eax, DWORD PTR _q$[ebp]
  0002b	50		 push	 eax
  0002c	e8 00 00 00 00	 call	 _glm_quat_norm
  00031	83 c4 04	 add	 esp, 4

; 51   : }

  00034	5f		 pop	 edi
  00035	5e		 pop	 esi
  00036	5b		 pop	 ebx
  00037	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0003d	3b ec		 cmp	 ebp, esp
  0003f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00044	8b e5		 mov	 esp, ebp
  00046	5d		 pop	 ebp
  00047	c3		 ret	 0
_glmc_quat_norm ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Light\source\repos\3DRendC\glmc\quat.c
;	COMDAT _glmc_quat_copy
_TEXT	SEGMENT
_q$ = 8							; size = 4
_dest$ = 12						; size = 4
_glmc_quat_copy PROC					; COMDAT

; 43   : glmc_quat_copy(versor q, versor dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __F616FBFC_quat@c
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 44   :   glm_quat_copy(q, dest);

  00028	8b 45 0c	 mov	 eax, DWORD PTR _dest$[ebp]
  0002b	50		 push	 eax
  0002c	8b 4d 08	 mov	 ecx, DWORD PTR _q$[ebp]
  0002f	51		 push	 ecx
  00030	e8 00 00 00 00	 call	 _glm_quat_copy
  00035	83 c4 08	 add	 esp, 8

; 45   : }

  00038	5f		 pop	 edi
  00039	5e		 pop	 esi
  0003a	5b		 pop	 ebx
  0003b	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00041	3b ec		 cmp	 ebp, esp
  00043	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00048	8b e5		 mov	 esp, ebp
  0004a	5d		 pop	 ebp
  0004b	c3		 ret	 0
_glmc_quat_copy ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Light\source\repos\3DRendC\glmc\quat.c
;	COMDAT _glmc_quatv
_TEXT	SEGMENT
_q$ = 8							; size = 4
_angle$ = 12						; size = 4
_axis$ = 16						; size = 4
_glmc_quatv PROC					; COMDAT

; 37   : glmc_quatv(versor q, float angle, vec3 axis) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __F616FBFC_quat@c
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 38   :   glm_quatv(q, angle, axis);

  00028	8b 45 10	 mov	 eax, DWORD PTR _axis$[ebp]
  0002b	50		 push	 eax
  0002c	51		 push	 ecx
  0002d	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _angle$[ebp]
  00032	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00037	8b 4d 08	 mov	 ecx, DWORD PTR _q$[ebp]
  0003a	51		 push	 ecx
  0003b	e8 00 00 00 00	 call	 _glm_quatv
  00040	83 c4 0c	 add	 esp, 12			; 0000000cH

; 39   : }

  00043	5f		 pop	 edi
  00044	5e		 pop	 esi
  00045	5b		 pop	 ebx
  00046	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0004c	3b ec		 cmp	 ebp, esp
  0004e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00053	8b e5		 mov	 esp, ebp
  00055	5d		 pop	 ebp
  00056	c3		 ret	 0
_glmc_quatv ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Light\source\repos\3DRendC\glmc\quat.c
;	COMDAT _glmc_quat
_TEXT	SEGMENT
_q$ = 8							; size = 4
_angle$ = 12						; size = 4
_x$ = 16						; size = 4
_y$ = 20						; size = 4
_z$ = 24						; size = 4
_glmc_quat PROC						; COMDAT

; 31   : glmc_quat(versor q, float angle, float x, float y, float z) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __F616FBFC_quat@c
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 32   :   glm_quat(q, angle, x, y, z);

  00028	51		 push	 ecx
  00029	f3 0f 10 45 18	 movss	 xmm0, DWORD PTR _z$[ebp]
  0002e	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00033	51		 push	 ecx
  00034	f3 0f 10 45 14	 movss	 xmm0, DWORD PTR _y$[ebp]
  00039	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0003e	51		 push	 ecx
  0003f	f3 0f 10 45 10	 movss	 xmm0, DWORD PTR _x$[ebp]
  00044	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00049	51		 push	 ecx
  0004a	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _angle$[ebp]
  0004f	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00054	8b 45 08	 mov	 eax, DWORD PTR _q$[ebp]
  00057	50		 push	 eax
  00058	e8 00 00 00 00	 call	 _glm_quat
  0005d	83 c4 14	 add	 esp, 20			; 00000014H

; 33   : }

  00060	5f		 pop	 edi
  00061	5e		 pop	 esi
  00062	5b		 pop	 ebx
  00063	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00069	3b ec		 cmp	 ebp, esp
  0006b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00070	8b e5		 mov	 esp, ebp
  00072	5d		 pop	 ebp
  00073	c3		 ret	 0
_glmc_quat ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Light\source\repos\3DRendC\glmc\quat.c
;	COMDAT _glmc_quat_init
_TEXT	SEGMENT
_q$ = 8							; size = 4
_x$ = 12						; size = 4
_y$ = 16						; size = 4
_z$ = 20						; size = 4
_w$ = 24						; size = 4
_glmc_quat_init PROC					; COMDAT

; 25   : glmc_quat_init(versor q, float x, float y, float z, float w) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __F616FBFC_quat@c
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 26   :   glm_quat_init(q, x, y, z, w);

  00028	51		 push	 ecx
  00029	f3 0f 10 45 18	 movss	 xmm0, DWORD PTR _w$[ebp]
  0002e	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00033	51		 push	 ecx
  00034	f3 0f 10 45 14	 movss	 xmm0, DWORD PTR _z$[ebp]
  00039	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0003e	51		 push	 ecx
  0003f	f3 0f 10 45 10	 movss	 xmm0, DWORD PTR _y$[ebp]
  00044	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00049	51		 push	 ecx
  0004a	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _x$[ebp]
  0004f	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00054	8b 45 08	 mov	 eax, DWORD PTR _q$[ebp]
  00057	50		 push	 eax
  00058	e8 00 00 00 00	 call	 _glm_quat_init
  0005d	83 c4 14	 add	 esp, 20			; 00000014H

; 27   : }

  00060	5f		 pop	 edi
  00061	5e		 pop	 esi
  00062	5b		 pop	 ebx
  00063	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00069	3b ec		 cmp	 ebp, esp
  0006b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00070	8b e5		 mov	 esp, ebp
  00072	5d		 pop	 ebp
  00073	c3		 ret	 0
_glmc_quat_init ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Light\source\repos\3DRendC\glmc\quat.c
;	COMDAT _glmc_quat_identity_array
_TEXT	SEGMENT
_q$ = 8							; size = 4
_count$ = 12						; size = 4
_glmc_quat_identity_array PROC				; COMDAT

; 19   : glmc_quat_identity_array(versor * __restrict q, size_t count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __F616FBFC_quat@c
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 20   :   glm_quat_identity_array(q, count);

  00028	8b 45 0c	 mov	 eax, DWORD PTR _count$[ebp]
  0002b	50		 push	 eax
  0002c	8b 4d 08	 mov	 ecx, DWORD PTR _q$[ebp]
  0002f	51		 push	 ecx
  00030	e8 00 00 00 00	 call	 _glm_quat_identity_array
  00035	83 c4 08	 add	 esp, 8

; 21   : }

  00038	5f		 pop	 edi
  00039	5e		 pop	 esi
  0003a	5b		 pop	 ebx
  0003b	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00041	3b ec		 cmp	 ebp, esp
  00043	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00048	8b e5		 mov	 esp, ebp
  0004a	5d		 pop	 ebp
  0004b	c3		 ret	 0
_glmc_quat_identity_array ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Light\source\repos\3DRendC\glmc\quat.c
;	COMDAT _glmc_quat_identity
_TEXT	SEGMENT
_q$ = 8							; size = 4
_glmc_quat_identity PROC				; COMDAT

; 13   : glmc_quat_identity(versor q) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __F616FBFC_quat@c
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 14   :   glm_quat_identity(q);

  00028	8b 45 08	 mov	 eax, DWORD PTR _q$[ebp]
  0002b	50		 push	 eax
  0002c	e8 00 00 00 00	 call	 _glm_quat_identity
  00031	83 c4 04	 add	 esp, 4

; 15   : }

  00034	5f		 pop	 edi
  00035	5e		 pop	 esi
  00036	5b		 pop	 ebx
  00037	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0003d	3b ec		 cmp	 ebp, esp
  0003f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00044	8b e5		 mov	 esp, ebp
  00046	5d		 pop	 ebp
  00047	c3		 ret	 0
_glmc_quat_identity ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Light\source\repos\3DRendC\include\quat.h
;	COMDAT _glm_quat_rotate_atm
_TEXT	SEGMENT
_pivotInv$ = -24					; size = 12
__$ArrayPad$ = -4					; size = 4
_m$ = 8							; size = 4
_q$ = 12						; size = 4
_pivot$ = 16						; size = 4
_glm_quat_rotate_atm PROC				; COMDAT

; 804  : glm_quat_rotate_atm(mat4 m, versor q, vec3 pivot) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 f8	 and	 esp, -8			; fffffff8H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec e0 00 00
	00		 sub	 esp, 224		; 000000e0H
  0001c	56		 push	 esi
  0001d	57		 push	 edi
  0001e	8d bd 20 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-224]
  00024	b9 38 00 00 00	 mov	 ecx, 56			; 00000038H
  00029	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002e	f3 ab		 rep stosd
  00030	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00035	33 c5		 xor	 eax, ebp
  00037	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0003a	b9 00 00 00 00	 mov	 ecx, OFFSET __20CD9DC3_quat@h
  0003f	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 805  :   CGLM_ALIGN(8) vec3 pivotInv;
; 806  : 
; 807  :   glm_vec3_negate_to(pivot, pivotInv);

  00044	8d 45 e8	 lea	 eax, DWORD PTR _pivotInv$[ebp]
  00047	50		 push	 eax
  00048	8b 4b 10	 mov	 ecx, DWORD PTR _pivot$[ebx]
  0004b	51		 push	 ecx
  0004c	e8 00 00 00 00	 call	 _glm_vec3_negate_to
  00051	83 c4 08	 add	 esp, 8

; 808  : 
; 809  :   glm_translate_make(m, pivot);

  00054	8b 43 10	 mov	 eax, DWORD PTR _pivot$[ebx]
  00057	50		 push	 eax
  00058	8b 4b 08	 mov	 ecx, DWORD PTR _m$[ebx]
  0005b	51		 push	 ecx
  0005c	e8 00 00 00 00	 call	 _glm_translate_make
  00061	83 c4 08	 add	 esp, 8

; 810  :   glm_quat_rotate(m, q, m);

  00064	8b 43 08	 mov	 eax, DWORD PTR _m$[ebx]
  00067	50		 push	 eax
  00068	8b 4b 0c	 mov	 ecx, DWORD PTR _q$[ebx]
  0006b	51		 push	 ecx
  0006c	8b 53 08	 mov	 edx, DWORD PTR _m$[ebx]
  0006f	52		 push	 edx
  00070	e8 00 00 00 00	 call	 _glm_quat_rotate
  00075	83 c4 0c	 add	 esp, 12			; 0000000cH

; 811  :   glm_translate(m, pivotInv);

  00078	8d 45 e8	 lea	 eax, DWORD PTR _pivotInv$[ebp]
  0007b	50		 push	 eax
  0007c	8b 4b 08	 mov	 ecx, DWORD PTR _m$[ebx]
  0007f	51		 push	 ecx
  00080	e8 00 00 00 00	 call	 _glm_translate
  00085	83 c4 08	 add	 esp, 8

; 812  : }

  00088	52		 push	 edx
  00089	8b cd		 mov	 ecx, ebp
  0008b	50		 push	 eax
  0008c	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN5@glm_quat_r
  00092	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00097	58		 pop	 eax
  00098	5a		 pop	 edx
  00099	5f		 pop	 edi
  0009a	5e		 pop	 esi
  0009b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0009e	33 cd		 xor	 ecx, ebp
  000a0	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000a5	8b e5		 mov	 esp, ebp
  000a7	5d		 pop	 ebp
  000a8	8b e3		 mov	 esp, ebx
  000aa	5b		 pop	 ebx
  000ab	c3		 ret	 0
$LN5@glm_quat_r:
  000ac	01 00 00 00	 DD	 1
  000b0	00 00 00 00	 DD	 $LN4@glm_quat_r
$LN4@glm_quat_r:
  000b4	e8 ff ff ff	 DD	 -24			; ffffffe8H
  000b8	0c 00 00 00	 DD	 12			; 0000000cH
  000bc	00 00 00 00	 DD	 $LN3@glm_quat_r
$LN3@glm_quat_r:
  000c0	70		 DB	 112			; 00000070H
  000c1	69		 DB	 105			; 00000069H
  000c2	76		 DB	 118			; 00000076H
  000c3	6f		 DB	 111			; 0000006fH
  000c4	74		 DB	 116			; 00000074H
  000c5	49		 DB	 73			; 00000049H
  000c6	6e		 DB	 110			; 0000006eH
  000c7	76		 DB	 118			; 00000076H
  000c8	00		 DB	 0
_glm_quat_rotate_atm ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Light\source\repos\3DRendC\include\quat.h
;	COMDAT _glm_quat_rotate_at
_TEXT	SEGMENT
_pivotInv$ = -24					; size = 12
__$ArrayPad$ = -4					; size = 4
_m$ = 8							; size = 4
_q$ = 12						; size = 4
_pivot$ = 16						; size = 4
_glm_quat_rotate_at PROC				; COMDAT

; 780  : glm_quat_rotate_at(mat4 m, versor q, vec3 pivot) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 f8	 and	 esp, -8			; fffffff8H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec e0 00 00
	00		 sub	 esp, 224		; 000000e0H
  0001c	56		 push	 esi
  0001d	57		 push	 edi
  0001e	8d bd 20 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-224]
  00024	b9 38 00 00 00	 mov	 ecx, 56			; 00000038H
  00029	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002e	f3 ab		 rep stosd
  00030	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00035	33 c5		 xor	 eax, ebp
  00037	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0003a	b9 00 00 00 00	 mov	 ecx, OFFSET __20CD9DC3_quat@h
  0003f	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 781  :   CGLM_ALIGN(8) vec3 pivotInv;
; 782  : 
; 783  :   glm_vec3_negate_to(pivot, pivotInv);

  00044	8d 45 e8	 lea	 eax, DWORD PTR _pivotInv$[ebp]
  00047	50		 push	 eax
  00048	8b 4b 10	 mov	 ecx, DWORD PTR _pivot$[ebx]
  0004b	51		 push	 ecx
  0004c	e8 00 00 00 00	 call	 _glm_vec3_negate_to
  00051	83 c4 08	 add	 esp, 8

; 784  : 
; 785  :   glm_translate(m, pivot);

  00054	8b 43 10	 mov	 eax, DWORD PTR _pivot$[ebx]
  00057	50		 push	 eax
  00058	8b 4b 08	 mov	 ecx, DWORD PTR _m$[ebx]
  0005b	51		 push	 ecx
  0005c	e8 00 00 00 00	 call	 _glm_translate
  00061	83 c4 08	 add	 esp, 8

; 786  :   glm_quat_rotate(m, q, m);

  00064	8b 43 08	 mov	 eax, DWORD PTR _m$[ebx]
  00067	50		 push	 eax
  00068	8b 4b 0c	 mov	 ecx, DWORD PTR _q$[ebx]
  0006b	51		 push	 ecx
  0006c	8b 53 08	 mov	 edx, DWORD PTR _m$[ebx]
  0006f	52		 push	 edx
  00070	e8 00 00 00 00	 call	 _glm_quat_rotate
  00075	83 c4 0c	 add	 esp, 12			; 0000000cH

; 787  :   glm_translate(m, pivotInv);

  00078	8d 45 e8	 lea	 eax, DWORD PTR _pivotInv$[ebp]
  0007b	50		 push	 eax
  0007c	8b 4b 08	 mov	 ecx, DWORD PTR _m$[ebx]
  0007f	51		 push	 ecx
  00080	e8 00 00 00 00	 call	 _glm_translate
  00085	83 c4 08	 add	 esp, 8

; 788  : }

  00088	52		 push	 edx
  00089	8b cd		 mov	 ecx, ebp
  0008b	50		 push	 eax
  0008c	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN5@glm_quat_r
  00092	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00097	58		 pop	 eax
  00098	5a		 pop	 edx
  00099	5f		 pop	 edi
  0009a	5e		 pop	 esi
  0009b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0009e	33 cd		 xor	 ecx, ebp
  000a0	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000a5	8b e5		 mov	 esp, ebp
  000a7	5d		 pop	 ebp
  000a8	8b e3		 mov	 esp, ebx
  000aa	5b		 pop	 ebx
  000ab	c3		 ret	 0
$LN5@glm_quat_r:
  000ac	01 00 00 00	 DD	 1
  000b0	00 00 00 00	 DD	 $LN4@glm_quat_r
$LN4@glm_quat_r:
  000b4	e8 ff ff ff	 DD	 -24			; ffffffe8H
  000b8	0c 00 00 00	 DD	 12			; 0000000cH
  000bc	00 00 00 00	 DD	 $LN3@glm_quat_r
$LN3@glm_quat_r:
  000c0	70		 DB	 112			; 00000070H
  000c1	69		 DB	 105			; 00000069H
  000c2	76		 DB	 118			; 00000076H
  000c3	6f		 DB	 111			; 0000006fH
  000c4	74		 DB	 116			; 00000074H
  000c5	49		 DB	 73			; 00000049H
  000c6	6e		 DB	 110			; 0000006eH
  000c7	76		 DB	 118			; 00000076H
  000c8	00		 DB	 0
_glm_quat_rotate_at ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Light\source\repos\3DRendC\include\quat.h
;	COMDAT _glm_quat_rotate
_TEXT	SEGMENT
_rot$ = -80						; size = 64
__$ArrayPad$ = -4					; size = 4
_m$ = 8							; size = 4
_q$ = 12						; size = 4
_dest$ = 16						; size = 4
_glm_quat_rotate PROC					; COMDAT

; 765  : glm_quat_rotate(mat4 m, versor q, mat4 dest) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 f0	 and	 esp, -16		; fffffff0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec 18 01 00
	00		 sub	 esp, 280		; 00000118H
  0001c	56		 push	 esi
  0001d	57		 push	 edi
  0001e	8d bd e8 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-280]
  00024	b9 46 00 00 00	 mov	 ecx, 70			; 00000046H
  00029	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002e	f3 ab		 rep stosd
  00030	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00035	33 c5		 xor	 eax, ebp
  00037	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0003a	b9 00 00 00 00	 mov	 ecx, OFFSET __20CD9DC3_quat@h
  0003f	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 766  :   CGLM_ALIGN_MAT mat4 rot;
; 767  :   glm_quat_mat4(q, rot);

  00044	8d 45 b0	 lea	 eax, DWORD PTR _rot$[ebp]
  00047	50		 push	 eax
  00048	8b 4b 0c	 mov	 ecx, DWORD PTR _q$[ebx]
  0004b	51		 push	 ecx
  0004c	e8 00 00 00 00	 call	 _glm_quat_mat4
  00051	83 c4 08	 add	 esp, 8

; 768  :   glm_mul_rot(m, rot, dest);

  00054	8b 43 10	 mov	 eax, DWORD PTR _dest$[ebx]
  00057	50		 push	 eax
  00058	8d 4d b0	 lea	 ecx, DWORD PTR _rot$[ebp]
  0005b	51		 push	 ecx
  0005c	8b 53 08	 mov	 edx, DWORD PTR _m$[ebx]
  0005f	52		 push	 edx
  00060	e8 00 00 00 00	 call	 _glm_mul_rot
  00065	83 c4 0c	 add	 esp, 12			; 0000000cH

; 769  : }

  00068	52		 push	 edx
  00069	8b cd		 mov	 ecx, ebp
  0006b	50		 push	 eax
  0006c	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN5@glm_quat_r
  00072	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00077	58		 pop	 eax
  00078	5a		 pop	 edx
  00079	5f		 pop	 edi
  0007a	5e		 pop	 esi
  0007b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0007e	33 cd		 xor	 ecx, ebp
  00080	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00085	8b e5		 mov	 esp, ebp
  00087	5d		 pop	 ebp
  00088	8b e3		 mov	 esp, ebx
  0008a	5b		 pop	 ebx
  0008b	c3		 ret	 0
$LN5@glm_quat_r:
  0008c	01 00 00 00	 DD	 1
  00090	00 00 00 00	 DD	 $LN4@glm_quat_r
$LN4@glm_quat_r:
  00094	b0 ff ff ff	 DD	 -80			; ffffffb0H
  00098	40 00 00 00	 DD	 64			; 00000040H
  0009c	00 00 00 00	 DD	 $LN3@glm_quat_r
$LN3@glm_quat_r:
  000a0	72		 DB	 114			; 00000072H
  000a1	6f		 DB	 111			; 0000006fH
  000a2	74		 DB	 116			; 00000074H
  000a3	00		 DB	 0
_glm_quat_rotate ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Light\source\repos\3DRendC\include\quat.h
;	COMDAT _glm_quat_rotatev
_TEXT	SEGMENT
tv155 = -320						; size = 4
tv173 = -316						; size = 4
tv144 = -316						; size = 4
_s$ = -116						; size = 4
_v2$ = -104						; size = 12
_v1$ = -80						; size = 12
_u$ = -56						; size = 12
_p$ = -32						; size = 16
__$ArrayPad$ = -4					; size = 4
_q$ = 8							; size = 4
_v$ = 12						; size = 4
_dest$ = 16						; size = 4
_glm_quat_rotatev PROC					; COMDAT

; 737  : glm_quat_rotatev(versor q, vec3 v, vec3 dest) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 f0	 and	 esp, -16		; fffffff0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec 48 01 00
	00		 sub	 esp, 328		; 00000148H
  0001c	56		 push	 esi
  0001d	57		 push	 edi
  0001e	8d bd b8 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-328]
  00024	b9 52 00 00 00	 mov	 ecx, 82			; 00000052H
  00029	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002e	f3 ab		 rep stosd
  00030	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00035	33 c5		 xor	 eax, ebp
  00037	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0003a	b9 00 00 00 00	 mov	 ecx, OFFSET __20CD9DC3_quat@h
  0003f	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 738  :   CGLM_ALIGN(16) versor p;
; 739  :   CGLM_ALIGN(8)  vec3   u, v1, v2;
; 740  :   float s;
; 741  : 
; 742  :   glm_quat_normalize_to(q, p);

  00044	8d 45 e0	 lea	 eax, DWORD PTR _p$[ebp]
  00047	50		 push	 eax
  00048	8b 4b 08	 mov	 ecx, DWORD PTR _q$[ebx]
  0004b	51		 push	 ecx
  0004c	e8 00 00 00 00	 call	 _glm_quat_normalize_to
  00051	83 c4 08	 add	 esp, 8

; 743  :   glm_quat_imag(p, u);

  00054	8d 45 c8	 lea	 eax, DWORD PTR _u$[ebp]
  00057	50		 push	 eax
  00058	8d 4d e0	 lea	 ecx, DWORD PTR _p$[ebp]
  0005b	51		 push	 ecx
  0005c	e8 00 00 00 00	 call	 _glm_quat_imag
  00061	83 c4 08	 add	 esp, 8

; 744  :   s = glm_quat_real(p);

  00064	8d 45 e0	 lea	 eax, DWORD PTR _p$[ebp]
  00067	50		 push	 eax
  00068	e8 00 00 00 00	 call	 _glm_quat_real
  0006d	83 c4 04	 add	 esp, 4
  00070	d9 5d 8c	 fstp	 DWORD PTR _s$[ebp]

; 745  : 
; 746  :   glm_vec3_scale(u, 2.0f * glm_vec3_dot(u, v), v1);

  00073	8d 45 b0	 lea	 eax, DWORD PTR _v1$[ebp]
  00076	50		 push	 eax
  00077	8b 4b 0c	 mov	 ecx, DWORD PTR _v$[ebx]
  0007a	51		 push	 ecx
  0007b	8d 55 c8	 lea	 edx, DWORD PTR _u$[ebp]
  0007e	52		 push	 edx
  0007f	e8 00 00 00 00	 call	 _glm_vec3_dot
  00084	83 c4 08	 add	 esp, 8
  00087	d9 9d c4 fe ff
	ff		 fstp	 DWORD PTR tv144[ebp]
  0008d	f3 0f 10 85 c4
	fe ff ff	 movss	 xmm0, DWORD PTR tv144[ebp]
  00095	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@40000000
  0009d	51		 push	 ecx
  0009e	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000a3	8d 45 c8	 lea	 eax, DWORD PTR _u$[ebp]
  000a6	50		 push	 eax
  000a7	e8 00 00 00 00	 call	 _glm_vec3_scale
  000ac	83 c4 0c	 add	 esp, 12			; 0000000cH

; 747  :   glm_vec3_scale(v, s * s - glm_vec3_dot(u, u), v2);

  000af	8d 45 98	 lea	 eax, DWORD PTR _v2$[ebp]
  000b2	50		 push	 eax
  000b3	f3 0f 10 45 8c	 movss	 xmm0, DWORD PTR _s$[ebp]
  000b8	f3 0f 59 45 8c	 mulss	 xmm0, DWORD PTR _s$[ebp]
  000bd	8d 4d c8	 lea	 ecx, DWORD PTR _u$[ebp]
  000c0	51		 push	 ecx
  000c1	8d 55 c8	 lea	 edx, DWORD PTR _u$[ebp]
  000c4	52		 push	 edx
  000c5	f3 0f 11 85 c4
	fe ff ff	 movss	 DWORD PTR tv173[ebp], xmm0
  000cd	e8 00 00 00 00	 call	 _glm_vec3_dot
  000d2	83 c4 08	 add	 esp, 8
  000d5	d9 9d c0 fe ff
	ff		 fstp	 DWORD PTR tv155[ebp]
  000db	f3 0f 10 85 c4
	fe ff ff	 movss	 xmm0, DWORD PTR tv173[ebp]
  000e3	f3 0f 5c 85 c0
	fe ff ff	 subss	 xmm0, DWORD PTR tv155[ebp]
  000eb	51		 push	 ecx
  000ec	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000f1	8b 43 0c	 mov	 eax, DWORD PTR _v$[ebx]
  000f4	50		 push	 eax
  000f5	e8 00 00 00 00	 call	 _glm_vec3_scale
  000fa	83 c4 0c	 add	 esp, 12			; 0000000cH

; 748  :   glm_vec3_add(v1, v2, v1);

  000fd	8d 45 b0	 lea	 eax, DWORD PTR _v1$[ebp]
  00100	50		 push	 eax
  00101	8d 4d 98	 lea	 ecx, DWORD PTR _v2$[ebp]
  00104	51		 push	 ecx
  00105	8d 55 b0	 lea	 edx, DWORD PTR _v1$[ebp]
  00108	52		 push	 edx
  00109	e8 00 00 00 00	 call	 _glm_vec3_add
  0010e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 749  : 
; 750  :   glm_vec3_cross(u, v, v2);

  00111	8d 45 98	 lea	 eax, DWORD PTR _v2$[ebp]
  00114	50		 push	 eax
  00115	8b 4b 0c	 mov	 ecx, DWORD PTR _v$[ebx]
  00118	51		 push	 ecx
  00119	8d 55 c8	 lea	 edx, DWORD PTR _u$[ebp]
  0011c	52		 push	 edx
  0011d	e8 00 00 00 00	 call	 _glm_vec3_cross
  00122	83 c4 0c	 add	 esp, 12			; 0000000cH

; 751  :   glm_vec3_scale(v2, 2.0f * s, v2);

  00125	8d 45 98	 lea	 eax, DWORD PTR _v2$[ebp]
  00128	50		 push	 eax
  00129	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@40000000
  00131	f3 0f 59 45 8c	 mulss	 xmm0, DWORD PTR _s$[ebp]
  00136	51		 push	 ecx
  00137	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0013c	8d 4d 98	 lea	 ecx, DWORD PTR _v2$[ebp]
  0013f	51		 push	 ecx
  00140	e8 00 00 00 00	 call	 _glm_vec3_scale
  00145	83 c4 0c	 add	 esp, 12			; 0000000cH

; 752  : 
; 753  :   glm_vec3_add(v1, v2, dest);

  00148	8b 43 10	 mov	 eax, DWORD PTR _dest$[ebx]
  0014b	50		 push	 eax
  0014c	8d 4d 98	 lea	 ecx, DWORD PTR _v2$[ebp]
  0014f	51		 push	 ecx
  00150	8d 55 b0	 lea	 edx, DWORD PTR _v1$[ebp]
  00153	52		 push	 edx
  00154	e8 00 00 00 00	 call	 _glm_vec3_add
  00159	83 c4 0c	 add	 esp, 12			; 0000000cH

; 754  : }

  0015c	52		 push	 edx
  0015d	8b cd		 mov	 ecx, ebp
  0015f	50		 push	 eax
  00160	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN8@glm_quat_r
  00166	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  0016b	58		 pop	 eax
  0016c	5a		 pop	 edx
  0016d	5f		 pop	 edi
  0016e	5e		 pop	 esi
  0016f	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00172	33 cd		 xor	 ecx, ebp
  00174	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00179	8b e5		 mov	 esp, ebp
  0017b	5d		 pop	 ebp
  0017c	8b e3		 mov	 esp, ebx
  0017e	5b		 pop	 ebx
  0017f	c3		 ret	 0
$LN8@glm_quat_r:
  00180	04 00 00 00	 DD	 4
  00184	00 00 00 00	 DD	 $LN7@glm_quat_r
$LN7@glm_quat_r:
  00188	e0 ff ff ff	 DD	 -32			; ffffffe0H
  0018c	10 00 00 00	 DD	 16			; 00000010H
  00190	00 00 00 00	 DD	 $LN3@glm_quat_r
  00194	c8 ff ff ff	 DD	 -56			; ffffffc8H
  00198	0c 00 00 00	 DD	 12			; 0000000cH
  0019c	00 00 00 00	 DD	 $LN4@glm_quat_r
  001a0	b0 ff ff ff	 DD	 -80			; ffffffb0H
  001a4	0c 00 00 00	 DD	 12			; 0000000cH
  001a8	00 00 00 00	 DD	 $LN5@glm_quat_r
  001ac	98 ff ff ff	 DD	 -104			; ffffff98H
  001b0	0c 00 00 00	 DD	 12			; 0000000cH
  001b4	00 00 00 00	 DD	 $LN6@glm_quat_r
$LN6@glm_quat_r:
  001b8	76		 DB	 118			; 00000076H
  001b9	32		 DB	 50			; 00000032H
  001ba	00		 DB	 0
$LN5@glm_quat_r:
  001bb	76		 DB	 118			; 00000076H
  001bc	31		 DB	 49			; 00000031H
  001bd	00		 DB	 0
$LN4@glm_quat_r:
  001be	75		 DB	 117			; 00000075H
  001bf	00		 DB	 0
$LN3@glm_quat_r:
  001c0	70		 DB	 112			; 00000070H
  001c1	00		 DB	 0
_glm_quat_rotatev ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Light\source\repos\3DRendC\include\quat.h
;	COMDAT _glm_quat_forp
_TEXT	SEGMENT
_dir$ = -24						; size = 12
__$ArrayPad$ = -4					; size = 4
_from$ = 8						; size = 4
_to$ = 12						; size = 4
_up$ = 16						; size = 4
_dest$ = 20						; size = 4
_glm_quat_forp PROC					; COMDAT

; 722  : glm_quat_forp(vec3 from, vec3 to, vec3 up, versor dest) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 f8	 and	 esp, -8			; fffffff8H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec e0 00 00
	00		 sub	 esp, 224		; 000000e0H
  0001c	56		 push	 esi
  0001d	57		 push	 edi
  0001e	8d bd 20 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-224]
  00024	b9 38 00 00 00	 mov	 ecx, 56			; 00000038H
  00029	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002e	f3 ab		 rep stosd
  00030	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00035	33 c5		 xor	 eax, ebp
  00037	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0003a	b9 00 00 00 00	 mov	 ecx, OFFSET __20CD9DC3_quat@h
  0003f	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 723  :   CGLM_ALIGN(8) vec3 dir;
; 724  :   glm_vec3_sub(to, from, dir);

  00044	8d 45 e8	 lea	 eax, DWORD PTR _dir$[ebp]
  00047	50		 push	 eax
  00048	8b 4b 08	 mov	 ecx, DWORD PTR _from$[ebx]
  0004b	51		 push	 ecx
  0004c	8b 53 0c	 mov	 edx, DWORD PTR _to$[ebx]
  0004f	52		 push	 edx
  00050	e8 00 00 00 00	 call	 _glm_vec3_sub
  00055	83 c4 0c	 add	 esp, 12			; 0000000cH

; 725  :   glm_quat_for(dir, up, dest);

  00058	8b 43 14	 mov	 eax, DWORD PTR _dest$[ebx]
  0005b	50		 push	 eax
  0005c	8b 4b 10	 mov	 ecx, DWORD PTR _up$[ebx]
  0005f	51		 push	 ecx
  00060	8d 55 e8	 lea	 edx, DWORD PTR _dir$[ebp]
  00063	52		 push	 edx
  00064	e8 00 00 00 00	 call	 _glm_quat_for
  00069	83 c4 0c	 add	 esp, 12			; 0000000cH

; 726  : }

  0006c	52		 push	 edx
  0006d	8b cd		 mov	 ecx, ebp
  0006f	50		 push	 eax
  00070	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN5@glm_quat_f
  00076	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  0007b	58		 pop	 eax
  0007c	5a		 pop	 edx
  0007d	5f		 pop	 edi
  0007e	5e		 pop	 esi
  0007f	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00082	33 cd		 xor	 ecx, ebp
  00084	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00089	8b e5		 mov	 esp, ebp
  0008b	5d		 pop	 ebp
  0008c	8b e3		 mov	 esp, ebx
  0008e	5b		 pop	 ebx
  0008f	c3		 ret	 0
$LN5@glm_quat_f:
  00090	01 00 00 00	 DD	 1
  00094	00 00 00 00	 DD	 $LN4@glm_quat_f
$LN4@glm_quat_f:
  00098	e8 ff ff ff	 DD	 -24			; ffffffe8H
  0009c	0c 00 00 00	 DD	 12			; 0000000cH
  000a0	00 00 00 00	 DD	 $LN3@glm_quat_f
$LN3@glm_quat_f:
  000a4	64		 DB	 100			; 00000064H
  000a5	69		 DB	 105			; 00000069H
  000a6	72		 DB	 114			; 00000072H
  000a7	00		 DB	 0
_glm_quat_forp ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Light\source\repos\3DRendC\include\quat.h
;	COMDAT _glm_quat_for
_TEXT	SEGMENT
_m$ = -64						; size = 36
__$ArrayPad$ = -4					; size = 4
_dir$ = 8						; size = 4
_up$ = 12						; size = 4
_dest$ = 16						; size = 4
_glm_quat_for PROC					; COMDAT

; 697  : glm_quat_for(vec3 dir, vec3 up, versor dest) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 f0	 and	 esp, -16		; fffffff0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec 08 01 00
	00		 sub	 esp, 264		; 00000108H
  0001c	56		 push	 esi
  0001d	57		 push	 edi
  0001e	8d bd f8 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-264]
  00024	b9 42 00 00 00	 mov	 ecx, 66			; 00000042H
  00029	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002e	f3 ab		 rep stosd
  00030	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00035	33 c5		 xor	 eax, ebp
  00037	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0003a	b9 00 00 00 00	 mov	 ecx, OFFSET __20CD9DC3_quat@h
  0003f	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 698  :   CGLM_ALIGN_MAT mat3 m;
; 699  : 
; 700  :   glm_vec3_normalize_to(dir, m[2]); 

  00044	b8 0c 00 00 00	 mov	 eax, 12			; 0000000cH
  00049	d1 e0		 shl	 eax, 1
  0004b	8d 4c 05 c0	 lea	 ecx, DWORD PTR _m$[ebp+eax]
  0004f	51		 push	 ecx
  00050	8b 53 08	 mov	 edx, DWORD PTR _dir$[ebx]
  00053	52		 push	 edx
  00054	e8 00 00 00 00	 call	 _glm_vec3_normalize_to
  00059	83 c4 08	 add	 esp, 8

; 701  : 
; 702  :   /* No need to negate in LH, but we use RH here */
; 703  :   glm_vec3_negate(m[2]);

  0005c	b8 0c 00 00 00	 mov	 eax, 12			; 0000000cH
  00061	d1 e0		 shl	 eax, 1
  00063	8d 4c 05 c0	 lea	 ecx, DWORD PTR _m$[ebp+eax]
  00067	51		 push	 ecx
  00068	e8 00 00 00 00	 call	 _glm_vec3_negate
  0006d	83 c4 04	 add	 esp, 4

; 704  :   
; 705  :   glm_vec3_crossn(up, m[2], m[0]);

  00070	b8 0c 00 00 00	 mov	 eax, 12			; 0000000cH
  00075	6b c8 00	 imul	 ecx, eax, 0
  00078	8d 54 0d c0	 lea	 edx, DWORD PTR _m$[ebp+ecx]
  0007c	52		 push	 edx
  0007d	b8 0c 00 00 00	 mov	 eax, 12			; 0000000cH
  00082	d1 e0		 shl	 eax, 1
  00084	8d 4c 05 c0	 lea	 ecx, DWORD PTR _m$[ebp+eax]
  00088	51		 push	 ecx
  00089	8b 53 0c	 mov	 edx, DWORD PTR _up$[ebx]
  0008c	52		 push	 edx
  0008d	e8 00 00 00 00	 call	 _glm_vec3_crossn
  00092	83 c4 0c	 add	 esp, 12			; 0000000cH

; 706  :   glm_vec3_cross(m[2], m[0], m[1]);

  00095	b8 0c 00 00 00	 mov	 eax, 12			; 0000000cH
  0009a	c1 e0 00	 shl	 eax, 0
  0009d	8d 4c 05 c0	 lea	 ecx, DWORD PTR _m$[ebp+eax]
  000a1	51		 push	 ecx
  000a2	ba 0c 00 00 00	 mov	 edx, 12			; 0000000cH
  000a7	6b c2 00	 imul	 eax, edx, 0
  000aa	8d 4c 05 c0	 lea	 ecx, DWORD PTR _m$[ebp+eax]
  000ae	51		 push	 ecx
  000af	ba 0c 00 00 00	 mov	 edx, 12			; 0000000cH
  000b4	d1 e2		 shl	 edx, 1
  000b6	8d 44 15 c0	 lea	 eax, DWORD PTR _m$[ebp+edx]
  000ba	50		 push	 eax
  000bb	e8 00 00 00 00	 call	 _glm_vec3_cross
  000c0	83 c4 0c	 add	 esp, 12			; 0000000cH

; 707  : 
; 708  :   glm_mat3_quat(m, dest);

  000c3	8b 43 10	 mov	 eax, DWORD PTR _dest$[ebx]
  000c6	50		 push	 eax
  000c7	8d 4d c0	 lea	 ecx, DWORD PTR _m$[ebp]
  000ca	51		 push	 ecx
  000cb	e8 00 00 00 00	 call	 _glm_mat3_quat
  000d0	83 c4 08	 add	 esp, 8

; 709  : }

  000d3	52		 push	 edx
  000d4	8b cd		 mov	 ecx, ebp
  000d6	50		 push	 eax
  000d7	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN5@glm_quat_f
  000dd	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  000e2	58		 pop	 eax
  000e3	5a		 pop	 edx
  000e4	5f		 pop	 edi
  000e5	5e		 pop	 esi
  000e6	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000e9	33 cd		 xor	 ecx, ebp
  000eb	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000f0	8b e5		 mov	 esp, ebp
  000f2	5d		 pop	 ebp
  000f3	8b e3		 mov	 esp, ebx
  000f5	5b		 pop	 ebx
  000f6	c3		 ret	 0
  000f7	90		 npad	 1
$LN5@glm_quat_f:
  000f8	01 00 00 00	 DD	 1
  000fc	00 00 00 00	 DD	 $LN4@glm_quat_f
$LN4@glm_quat_f:
  00100	c0 ff ff ff	 DD	 -64			; ffffffc0H
  00104	24 00 00 00	 DD	 36			; 00000024H
  00108	00 00 00 00	 DD	 $LN3@glm_quat_f
$LN3@glm_quat_f:
  0010c	6d		 DB	 109			; 0000006dH
  0010d	00		 DB	 0
_glm_quat_for ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Light\source\repos\3DRendC\include\quat.h
;	COMDAT _glm_quat_look
_TEXT	SEGMENT
_eye$ = 8						; size = 4
_ori$ = 12						; size = 4
_dest$ = 16						; size = 4
_glm_quat_look PROC					; COMDAT

; 679  : glm_quat_look(vec3 eye, versor ori, mat4 dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __20CD9DC3_quat@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 680  :   /* orientation */
; 681  :   glm_quat_mat4t(ori, dest);

  00028	8b 45 10	 mov	 eax, DWORD PTR _dest$[ebp]
  0002b	50		 push	 eax
  0002c	8b 4d 0c	 mov	 ecx, DWORD PTR _ori$[ebp]
  0002f	51		 push	 ecx
  00030	e8 00 00 00 00	 call	 _glm_quat_mat4t
  00035	83 c4 08	 add	 esp, 8

; 682  : 
; 683  :   /* translate */
; 684  :   glm_mat4_mulv3(dest, eye, 1.0f, dest[3]);

  00038	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  0003d	6b c8 03	 imul	 ecx, eax, 3
  00040	03 4d 10	 add	 ecx, DWORD PTR _dest$[ebp]
  00043	51		 push	 ecx
  00044	51		 push	 ecx
  00045	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  0004d	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00052	8b 55 08	 mov	 edx, DWORD PTR _eye$[ebp]
  00055	52		 push	 edx
  00056	8b 45 10	 mov	 eax, DWORD PTR _dest$[ebp]
  00059	50		 push	 eax
  0005a	e8 00 00 00 00	 call	 _glm_mat4_mulv3
  0005f	83 c4 10	 add	 esp, 16			; 00000010H

; 685  :   glm_vec3_negate(dest[3]);

  00062	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  00067	6b c8 03	 imul	 ecx, eax, 3
  0006a	03 4d 10	 add	 ecx, DWORD PTR _dest$[ebp]
  0006d	51		 push	 ecx
  0006e	e8 00 00 00 00	 call	 _glm_vec3_negate
  00073	83 c4 04	 add	 esp, 4

; 686  : }

  00076	5f		 pop	 edi
  00077	5e		 pop	 esi
  00078	5b		 pop	 ebx
  00079	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0007f	3b ec		 cmp	 ebp, esp
  00081	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00086	8b e5		 mov	 esp, ebp
  00088	5d		 pop	 ebp
  00089	c3		 ret	 0
_glm_quat_look ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Light\source\repos\3DRendC\include\quat.h
;	COMDAT _glm_quat_slerp
_TEXT	SEGMENT
tv172 = -300						; size = 4
tv156 = -300						; size = 4
_angle$ = -100						; size = 4
_sinTheta$ = -88					; size = 4
_cosTheta$ = -76					; size = 4
_q2$ = -64						; size = 16
_q1$ = -32						; size = 16
__$ArrayPad$ = -4					; size = 4
_from$ = 8						; size = 4
_to$ = 12						; size = 4
_t$ = 16						; size = 4
_dest$ = 20						; size = 4
_glm_quat_slerp PROC					; COMDAT

; 636  : glm_quat_slerp(versor from, versor to, float t, versor dest) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 f0	 and	 esp, -16		; fffffff0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec 38 01 00
	00		 sub	 esp, 312		; 00000138H
  0001c	56		 push	 esi
  0001d	57		 push	 edi
  0001e	8d bd c8 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-312]
  00024	b9 4e 00 00 00	 mov	 ecx, 78			; 0000004eH
  00029	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002e	f3 ab		 rep stosd
  00030	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00035	33 c5		 xor	 eax, ebp
  00037	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0003a	b9 00 00 00 00	 mov	 ecx, OFFSET __20CD9DC3_quat@h
  0003f	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 637  :   CGLM_ALIGN(16) vec4 q1, q2;
; 638  :   float cosTheta, sinTheta, angle;
; 639  : 
; 640  :   cosTheta = glm_quat_dot(from, to);

  00044	8b 43 0c	 mov	 eax, DWORD PTR _to$[ebx]
  00047	50		 push	 eax
  00048	8b 4b 08	 mov	 ecx, DWORD PTR _from$[ebx]
  0004b	51		 push	 ecx
  0004c	e8 00 00 00 00	 call	 _glm_quat_dot
  00051	83 c4 08	 add	 esp, 8
  00054	d9 5d b4	 fstp	 DWORD PTR _cosTheta$[ebp]

; 641  :   glm_quat_copy(from, q1);

  00057	8d 45 e0	 lea	 eax, DWORD PTR _q1$[ebp]
  0005a	50		 push	 eax
  0005b	8b 4b 08	 mov	 ecx, DWORD PTR _from$[ebx]
  0005e	51		 push	 ecx
  0005f	e8 00 00 00 00	 call	 _glm_quat_copy
  00064	83 c4 08	 add	 esp, 8

; 642  : 
; 643  :   if (fabsf(cosTheta) >= 1.0f) {

  00067	51		 push	 ecx
  00068	f3 0f 10 45 b4	 movss	 xmm0, DWORD PTR _cosTheta$[ebp]
  0006d	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00072	e8 00 00 00 00	 call	 _fabsf
  00077	83 c4 04	 add	 esp, 4
  0007a	d9 9d d4 fe ff
	ff		 fstp	 DWORD PTR tv156[ebp]
  00080	f3 0f 10 85 d4
	fe ff ff	 movss	 xmm0, DWORD PTR tv156[ebp]
  00088	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@3f800000
  0008f	72 15		 jb	 SHORT $LN2@glm_quat_s

; 644  :     glm_quat_copy(q1, dest);

  00091	8b 43 14	 mov	 eax, DWORD PTR _dest$[ebx]
  00094	50		 push	 eax
  00095	8d 4d e0	 lea	 ecx, DWORD PTR _q1$[ebp]
  00098	51		 push	 ecx
  00099	e8 00 00 00 00	 call	 _glm_quat_copy
  0009e	83 c4 08	 add	 esp, 8

; 645  :     return;

  000a1	e9 40 01 00 00	 jmp	 $LN1@glm_quat_s
$LN2@glm_quat_s:

; 646  :   }
; 647  : 
; 648  :   if (cosTheta < 0.0f) {

  000a6	0f 57 c0	 xorps	 xmm0, xmm0
  000a9	0f 2f 45 b4	 comiss	 xmm0, DWORD PTR _cosTheta$[ebp]
  000ad	76 1d		 jbe	 SHORT $LN3@glm_quat_s

; 649  :     glm_vec4_negate(q1);

  000af	8d 45 e0	 lea	 eax, DWORD PTR _q1$[ebp]
  000b2	50		 push	 eax
  000b3	e8 00 00 00 00	 call	 _glm_vec4_negate
  000b8	83 c4 04	 add	 esp, 4

; 650  :     cosTheta = -cosTheta;

  000bb	f3 0f 10 45 b4	 movss	 xmm0, DWORD PTR _cosTheta$[ebp]
  000c0	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
  000c7	f3 0f 11 45 b4	 movss	 DWORD PTR _cosTheta$[ebp], xmm0
$LN3@glm_quat_s:

; 651  :   }
; 652  : 
; 653  :   sinTheta = sqrtf(1.0f - cosTheta * cosTheta);

  000cc	f3 0f 10 45 b4	 movss	 xmm0, DWORD PTR _cosTheta$[ebp]
  000d1	f3 0f 59 45 b4	 mulss	 xmm0, DWORD PTR _cosTheta$[ebp]
  000d6	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@3f800000
  000de	f3 0f 5c c8	 subss	 xmm1, xmm0
  000e2	51		 push	 ecx
  000e3	f3 0f 11 0c 24	 movss	 DWORD PTR [esp], xmm1
  000e8	e8 00 00 00 00	 call	 _sqrtf
  000ed	83 c4 04	 add	 esp, 4
  000f0	d9 5d a8	 fstp	 DWORD PTR _sinTheta$[ebp]

; 654  : 
; 655  :   /* LERP to avoid zero division */
; 656  :   if (fabsf(sinTheta) < 0.001f) {

  000f3	51		 push	 ecx
  000f4	f3 0f 10 45 a8	 movss	 xmm0, DWORD PTR _sinTheta$[ebp]
  000f9	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000fe	e8 00 00 00 00	 call	 _fabsf
  00103	83 c4 04	 add	 esp, 4
  00106	d9 9d d4 fe ff
	ff		 fstp	 DWORD PTR tv172[ebp]
  0010c	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3a83126f
  00114	0f 2f 85 d4 fe
	ff ff		 comiss	 xmm0, DWORD PTR tv172[ebp]
  0011b	76 24		 jbe	 SHORT $LN4@glm_quat_s

; 657  :     glm_quat_lerp(from, to, t, dest);

  0011d	8b 43 14	 mov	 eax, DWORD PTR _dest$[ebx]
  00120	50		 push	 eax
  00121	51		 push	 ecx
  00122	f3 0f 10 43 10	 movss	 xmm0, DWORD PTR _t$[ebx]
  00127	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0012c	8b 4b 0c	 mov	 ecx, DWORD PTR _to$[ebx]
  0012f	51		 push	 ecx
  00130	8b 53 08	 mov	 edx, DWORD PTR _from$[ebx]
  00133	52		 push	 edx
  00134	e8 00 00 00 00	 call	 _glm_quat_lerp
  00139	83 c4 10	 add	 esp, 16			; 00000010H

; 658  :     return;

  0013c	e9 a5 00 00 00	 jmp	 $LN1@glm_quat_s
$LN4@glm_quat_s:

; 659  :   }
; 660  : 
; 661  :   /* SLERP */
; 662  :   angle = acosf(cosTheta);

  00141	51		 push	 ecx
  00142	f3 0f 10 45 b4	 movss	 xmm0, DWORD PTR _cosTheta$[ebp]
  00147	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0014c	e8 00 00 00 00	 call	 _acosf
  00151	83 c4 04	 add	 esp, 4
  00154	d9 5d 9c	 fstp	 DWORD PTR _angle$[ebp]

; 663  :   glm_vec4_scale(q1, sinf((1.0f - t) * angle), q1);

  00157	8d 45 e0	 lea	 eax, DWORD PTR _q1$[ebp]
  0015a	50		 push	 eax
  0015b	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00163	f3 0f 5c 43 10	 subss	 xmm0, DWORD PTR _t$[ebx]
  00168	f3 0f 59 45 9c	 mulss	 xmm0, DWORD PTR _angle$[ebp]
  0016d	51		 push	 ecx
  0016e	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00173	e8 00 00 00 00	 call	 _sinf
  00178	d9 1c 24	 fstp	 DWORD PTR [esp]
  0017b	8d 4d e0	 lea	 ecx, DWORD PTR _q1$[ebp]
  0017e	51		 push	 ecx
  0017f	e8 00 00 00 00	 call	 _glm_vec4_scale
  00184	83 c4 0c	 add	 esp, 12			; 0000000cH

; 664  :   glm_vec4_scale(to, sinf(t * angle), q2);

  00187	8d 45 c0	 lea	 eax, DWORD PTR _q2$[ebp]
  0018a	50		 push	 eax
  0018b	f3 0f 10 43 10	 movss	 xmm0, DWORD PTR _t$[ebx]
  00190	f3 0f 59 45 9c	 mulss	 xmm0, DWORD PTR _angle$[ebp]
  00195	51		 push	 ecx
  00196	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0019b	e8 00 00 00 00	 call	 _sinf
  001a0	d9 1c 24	 fstp	 DWORD PTR [esp]
  001a3	8b 4b 0c	 mov	 ecx, DWORD PTR _to$[ebx]
  001a6	51		 push	 ecx
  001a7	e8 00 00 00 00	 call	 _glm_vec4_scale
  001ac	83 c4 0c	 add	 esp, 12			; 0000000cH

; 665  : 
; 666  :   glm_vec4_add(q1, q2, q1);

  001af	8d 45 e0	 lea	 eax, DWORD PTR _q1$[ebp]
  001b2	50		 push	 eax
  001b3	8d 4d c0	 lea	 ecx, DWORD PTR _q2$[ebp]
  001b6	51		 push	 ecx
  001b7	8d 55 e0	 lea	 edx, DWORD PTR _q1$[ebp]
  001ba	52		 push	 edx
  001bb	e8 00 00 00 00	 call	 _glm_vec4_add
  001c0	83 c4 0c	 add	 esp, 12			; 0000000cH

; 667  :   glm_vec4_scale(q1, 1.0f / sinTheta, dest);

  001c3	8b 43 14	 mov	 eax, DWORD PTR _dest$[ebx]
  001c6	50		 push	 eax
  001c7	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  001cf	f3 0f 5e 45 a8	 divss	 xmm0, DWORD PTR _sinTheta$[ebp]
  001d4	51		 push	 ecx
  001d5	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001da	8d 4d e0	 lea	 ecx, DWORD PTR _q1$[ebp]
  001dd	51		 push	 ecx
  001de	e8 00 00 00 00	 call	 _glm_vec4_scale
  001e3	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@glm_quat_s:

; 668  : }

  001e6	52		 push	 edx
  001e7	8b cd		 mov	 ecx, ebp
  001e9	50		 push	 eax
  001ea	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN9@glm_quat_s
  001f0	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  001f5	58		 pop	 eax
  001f6	5a		 pop	 edx
  001f7	5f		 pop	 edi
  001f8	5e		 pop	 esi
  001f9	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001fc	33 cd		 xor	 ecx, ebp
  001fe	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00203	8b e5		 mov	 esp, ebp
  00205	5d		 pop	 ebp
  00206	8b e3		 mov	 esp, ebx
  00208	5b		 pop	 ebx
  00209	c3		 ret	 0
  0020a	66 90		 npad	 2
$LN9@glm_quat_s:
  0020c	02 00 00 00	 DD	 2
  00210	00 00 00 00	 DD	 $LN8@glm_quat_s
$LN8@glm_quat_s:
  00214	e0 ff ff ff	 DD	 -32			; ffffffe0H
  00218	10 00 00 00	 DD	 16			; 00000010H
  0021c	00 00 00 00	 DD	 $LN6@glm_quat_s
  00220	c0 ff ff ff	 DD	 -64			; ffffffc0H
  00224	10 00 00 00	 DD	 16			; 00000010H
  00228	00 00 00 00	 DD	 $LN7@glm_quat_s
$LN7@glm_quat_s:
  0022c	71		 DB	 113			; 00000071H
  0022d	32		 DB	 50			; 00000032H
  0022e	00		 DB	 0
$LN6@glm_quat_s:
  0022f	71		 DB	 113			; 00000071H
  00230	31		 DB	 49			; 00000031H
  00231	00		 DB	 0
_glm_quat_slerp ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Light\source\repos\3DRendC\include\quat.h
;	COMDAT _glm_quat_lerpc
_TEXT	SEGMENT
_from$ = 8						; size = 4
_to$ = 12						; size = 4
_t$ = 16						; size = 4
_dest$ = 20						; size = 4
_glm_quat_lerpc PROC					; COMDAT

; 621  : glm_quat_lerpc(versor from, versor to, float t, versor dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __20CD9DC3_quat@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 622  :   glm_vec4_lerpc(from, to, t, dest);

  00028	8b 45 14	 mov	 eax, DWORD PTR _dest$[ebp]
  0002b	50		 push	 eax
  0002c	51		 push	 ecx
  0002d	f3 0f 10 45 10	 movss	 xmm0, DWORD PTR _t$[ebp]
  00032	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00037	8b 4d 0c	 mov	 ecx, DWORD PTR _to$[ebp]
  0003a	51		 push	 ecx
  0003b	8b 55 08	 mov	 edx, DWORD PTR _from$[ebp]
  0003e	52		 push	 edx
  0003f	e8 00 00 00 00	 call	 _glm_vec4_lerpc
  00044	83 c4 10	 add	 esp, 16			; 00000010H

; 623  : }

  00047	5f		 pop	 edi
  00048	5e		 pop	 esi
  00049	5b		 pop	 ebx
  0004a	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00050	3b ec		 cmp	 ebp, esp
  00052	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00057	8b e5		 mov	 esp, ebp
  00059	5d		 pop	 ebp
  0005a	c3		 ret	 0
_glm_quat_lerpc ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Light\source\repos\3DRendC\include\quat.h
;	COMDAT _glm_quat_lerp
_TEXT	SEGMENT
_from$ = 8						; size = 4
_to$ = 12						; size = 4
_t$ = 16						; size = 4
_dest$ = 20						; size = 4
_glm_quat_lerp PROC					; COMDAT

; 606  : glm_quat_lerp(versor from, versor to, float t, versor dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __20CD9DC3_quat@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 607  :   glm_vec4_lerp(from, to, t, dest);

  00028	8b 45 14	 mov	 eax, DWORD PTR _dest$[ebp]
  0002b	50		 push	 eax
  0002c	51		 push	 ecx
  0002d	f3 0f 10 45 10	 movss	 xmm0, DWORD PTR _t$[ebp]
  00032	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00037	8b 4d 0c	 mov	 ecx, DWORD PTR _to$[ebp]
  0003a	51		 push	 ecx
  0003b	8b 55 08	 mov	 edx, DWORD PTR _from$[ebp]
  0003e	52		 push	 edx
  0003f	e8 00 00 00 00	 call	 _glm_vec4_lerp
  00044	83 c4 10	 add	 esp, 16			; 00000010H

; 608  : }

  00047	5f		 pop	 edi
  00048	5e		 pop	 esi
  00049	5b		 pop	 ebx
  0004a	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00050	3b ec		 cmp	 ebp, esp
  00052	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00057	8b e5		 mov	 esp, ebp
  00059	5d		 pop	 ebp
  0005a	c3		 ret	 0
_glm_quat_lerp ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Light\source\repos\3DRendC\include\quat.h
;	COMDAT _glm_quat_mat3t
_TEXT	SEGMENT
tv68 = -376						; size = 4
_s$ = -176						; size = 4
_norm$ = -164						; size = 4
_wz$ = -152						; size = 4
_wy$ = -140						; size = 4
_wx$ = -128						; size = 4
_xz$ = -116						; size = 4
_yz$ = -104						; size = 4
_xy$ = -92						; size = 4
_zz$ = -80						; size = 4
_yy$ = -68						; size = 4
_xx$ = -56						; size = 4
_z$ = -44						; size = 4
_y$ = -32						; size = 4
_x$ = -20						; size = 4
_w$ = -8						; size = 4
_q$ = 8							; size = 4
_dest$ = 12						; size = 4
_glm_quat_mat3t PROC					; COMDAT

; 564  : glm_quat_mat3t(versor q, mat3 dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 78 01 00
	00		 sub	 esp, 376		; 00000178H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 88 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-376]
  00012	b9 5e 00 00 00	 mov	 ecx, 94			; 0000005eH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __20CD9DC3_quat@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 565  :   float w, x, y, z,
; 566  :         xx, yy, zz,
; 567  :         xy, yz, xz,
; 568  :         wx, wy, wz, norm, s;
; 569  : 
; 570  :   norm = glm_quat_norm(q);

  00028	8b 45 08	 mov	 eax, DWORD PTR _q$[ebp]
  0002b	50		 push	 eax
  0002c	e8 00 00 00 00	 call	 _glm_quat_norm
  00031	83 c4 04	 add	 esp, 4
  00034	d9 9d 5c ff ff
	ff		 fstp	 DWORD PTR _norm$[ebp]

; 571  :   s    = norm > 0.0f ? 2.0f / norm : 0.0f;

  0003a	f3 0f 10 85 5c
	ff ff ff	 movss	 xmm0, DWORD PTR _norm$[ebp]
  00042	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  00049	76 1a		 jbe	 SHORT $LN3@glm_quat_m
  0004b	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@40000000
  00053	f3 0f 5e 85 5c
	ff ff ff	 divss	 xmm0, DWORD PTR _norm$[ebp]
  0005b	f3 0f 11 85 88
	fe ff ff	 movss	 DWORD PTR tv68[ebp], xmm0
  00063	eb 0b		 jmp	 SHORT $LN4@glm_quat_m
$LN3@glm_quat_m:
  00065	0f 57 c0	 xorps	 xmm0, xmm0
  00068	f3 0f 11 85 88
	fe ff ff	 movss	 DWORD PTR tv68[ebp], xmm0
$LN4@glm_quat_m:
  00070	f3 0f 10 85 88
	fe ff ff	 movss	 xmm0, DWORD PTR tv68[ebp]
  00078	f3 0f 11 85 50
	ff ff ff	 movss	 DWORD PTR _s$[ebp], xmm0

; 572  : 
; 573  :   x = q[0];

  00080	b8 04 00 00 00	 mov	 eax, 4
  00085	6b c8 00	 imul	 ecx, eax, 0
  00088	8b 55 08	 mov	 edx, DWORD PTR _q$[ebp]
  0008b	f3 0f 10 04 0a	 movss	 xmm0, DWORD PTR [edx+ecx]
  00090	f3 0f 11 45 ec	 movss	 DWORD PTR _x$[ebp], xmm0

; 574  :   y = q[1];

  00095	b8 04 00 00 00	 mov	 eax, 4
  0009a	c1 e0 00	 shl	 eax, 0
  0009d	8b 4d 08	 mov	 ecx, DWORD PTR _q$[ebp]
  000a0	f3 0f 10 04 01	 movss	 xmm0, DWORD PTR [ecx+eax]
  000a5	f3 0f 11 45 e0	 movss	 DWORD PTR _y$[ebp], xmm0

; 575  :   z = q[2];

  000aa	b8 04 00 00 00	 mov	 eax, 4
  000af	d1 e0		 shl	 eax, 1
  000b1	8b 4d 08	 mov	 ecx, DWORD PTR _q$[ebp]
  000b4	f3 0f 10 04 01	 movss	 xmm0, DWORD PTR [ecx+eax]
  000b9	f3 0f 11 45 d4	 movss	 DWORD PTR _z$[ebp], xmm0

; 576  :   w = q[3];

  000be	b8 04 00 00 00	 mov	 eax, 4
  000c3	6b c8 03	 imul	 ecx, eax, 3
  000c6	8b 55 08	 mov	 edx, DWORD PTR _q$[ebp]
  000c9	f3 0f 10 04 0a	 movss	 xmm0, DWORD PTR [edx+ecx]
  000ce	f3 0f 11 45 f8	 movss	 DWORD PTR _w$[ebp], xmm0

; 577  : 
; 578  :   xx = s * x * x;   xy = s * x * y;   wx = s * w * x;

  000d3	f3 0f 10 85 50
	ff ff ff	 movss	 xmm0, DWORD PTR _s$[ebp]
  000db	f3 0f 59 45 ec	 mulss	 xmm0, DWORD PTR _x$[ebp]
  000e0	f3 0f 59 45 ec	 mulss	 xmm0, DWORD PTR _x$[ebp]
  000e5	f3 0f 11 45 c8	 movss	 DWORD PTR _xx$[ebp], xmm0
  000ea	f3 0f 10 85 50
	ff ff ff	 movss	 xmm0, DWORD PTR _s$[ebp]
  000f2	f3 0f 59 45 ec	 mulss	 xmm0, DWORD PTR _x$[ebp]
  000f7	f3 0f 59 45 e0	 mulss	 xmm0, DWORD PTR _y$[ebp]
  000fc	f3 0f 11 45 a4	 movss	 DWORD PTR _xy$[ebp], xmm0
  00101	f3 0f 10 85 50
	ff ff ff	 movss	 xmm0, DWORD PTR _s$[ebp]
  00109	f3 0f 59 45 f8	 mulss	 xmm0, DWORD PTR _w$[ebp]
  0010e	f3 0f 59 45 ec	 mulss	 xmm0, DWORD PTR _x$[ebp]
  00113	f3 0f 11 45 80	 movss	 DWORD PTR _wx$[ebp], xmm0

; 579  :   yy = s * y * y;   yz = s * y * z;   wy = s * w * y;

  00118	f3 0f 10 85 50
	ff ff ff	 movss	 xmm0, DWORD PTR _s$[ebp]
  00120	f3 0f 59 45 e0	 mulss	 xmm0, DWORD PTR _y$[ebp]
  00125	f3 0f 59 45 e0	 mulss	 xmm0, DWORD PTR _y$[ebp]
  0012a	f3 0f 11 45 bc	 movss	 DWORD PTR _yy$[ebp], xmm0
  0012f	f3 0f 10 85 50
	ff ff ff	 movss	 xmm0, DWORD PTR _s$[ebp]
  00137	f3 0f 59 45 e0	 mulss	 xmm0, DWORD PTR _y$[ebp]
  0013c	f3 0f 59 45 d4	 mulss	 xmm0, DWORD PTR _z$[ebp]
  00141	f3 0f 11 45 98	 movss	 DWORD PTR _yz$[ebp], xmm0
  00146	f3 0f 10 85 50
	ff ff ff	 movss	 xmm0, DWORD PTR _s$[ebp]
  0014e	f3 0f 59 45 f8	 mulss	 xmm0, DWORD PTR _w$[ebp]
  00153	f3 0f 59 45 e0	 mulss	 xmm0, DWORD PTR _y$[ebp]
  00158	f3 0f 11 85 74
	ff ff ff	 movss	 DWORD PTR _wy$[ebp], xmm0

; 580  :   zz = s * z * z;   xz = s * x * z;   wz = s * w * z;

  00160	f3 0f 10 85 50
	ff ff ff	 movss	 xmm0, DWORD PTR _s$[ebp]
  00168	f3 0f 59 45 d4	 mulss	 xmm0, DWORD PTR _z$[ebp]
  0016d	f3 0f 59 45 d4	 mulss	 xmm0, DWORD PTR _z$[ebp]
  00172	f3 0f 11 45 b0	 movss	 DWORD PTR _zz$[ebp], xmm0
  00177	f3 0f 10 85 50
	ff ff ff	 movss	 xmm0, DWORD PTR _s$[ebp]
  0017f	f3 0f 59 45 ec	 mulss	 xmm0, DWORD PTR _x$[ebp]
  00184	f3 0f 59 45 d4	 mulss	 xmm0, DWORD PTR _z$[ebp]
  00189	f3 0f 11 45 8c	 movss	 DWORD PTR _xz$[ebp], xmm0
  0018e	f3 0f 10 85 50
	ff ff ff	 movss	 xmm0, DWORD PTR _s$[ebp]
  00196	f3 0f 59 45 f8	 mulss	 xmm0, DWORD PTR _w$[ebp]
  0019b	f3 0f 59 45 d4	 mulss	 xmm0, DWORD PTR _z$[ebp]
  001a0	f3 0f 11 85 68
	ff ff ff	 movss	 DWORD PTR _wz$[ebp], xmm0

; 581  : 
; 582  :   dest[0][0] = 1.0f - yy - zz;

  001a8	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  001b0	f3 0f 5c 45 bc	 subss	 xmm0, DWORD PTR _yy$[ebp]
  001b5	f3 0f 5c 45 b0	 subss	 xmm0, DWORD PTR _zz$[ebp]
  001ba	b8 0c 00 00 00	 mov	 eax, 12			; 0000000cH
  001bf	6b c8 00	 imul	 ecx, eax, 0
  001c2	03 4d 0c	 add	 ecx, DWORD PTR _dest$[ebp]
  001c5	ba 04 00 00 00	 mov	 edx, 4
  001ca	6b c2 00	 imul	 eax, edx, 0
  001cd	f3 0f 11 04 01	 movss	 DWORD PTR [ecx+eax], xmm0

; 583  :   dest[1][1] = 1.0f - xx - zz;

  001d2	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  001da	f3 0f 5c 45 c8	 subss	 xmm0, DWORD PTR _xx$[ebp]
  001df	f3 0f 5c 45 b0	 subss	 xmm0, DWORD PTR _zz$[ebp]
  001e4	b8 0c 00 00 00	 mov	 eax, 12			; 0000000cH
  001e9	c1 e0 00	 shl	 eax, 0
  001ec	03 45 0c	 add	 eax, DWORD PTR _dest$[ebp]
  001ef	b9 04 00 00 00	 mov	 ecx, 4
  001f4	c1 e1 00	 shl	 ecx, 0
  001f7	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0

; 584  :   dest[2][2] = 1.0f - xx - yy;

  001fc	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00204	f3 0f 5c 45 c8	 subss	 xmm0, DWORD PTR _xx$[ebp]
  00209	f3 0f 5c 45 bc	 subss	 xmm0, DWORD PTR _yy$[ebp]
  0020e	b8 0c 00 00 00	 mov	 eax, 12			; 0000000cH
  00213	d1 e0		 shl	 eax, 1
  00215	03 45 0c	 add	 eax, DWORD PTR _dest$[ebp]
  00218	b9 04 00 00 00	 mov	 ecx, 4
  0021d	d1 e1		 shl	 ecx, 1
  0021f	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0

; 585  : 
; 586  :   dest[1][0] = xy + wz;

  00224	f3 0f 10 45 a4	 movss	 xmm0, DWORD PTR _xy$[ebp]
  00229	f3 0f 58 85 68
	ff ff ff	 addss	 xmm0, DWORD PTR _wz$[ebp]
  00231	b8 0c 00 00 00	 mov	 eax, 12			; 0000000cH
  00236	c1 e0 00	 shl	 eax, 0
  00239	03 45 0c	 add	 eax, DWORD PTR _dest$[ebp]
  0023c	b9 04 00 00 00	 mov	 ecx, 4
  00241	6b d1 00	 imul	 edx, ecx, 0
  00244	f3 0f 11 04 10	 movss	 DWORD PTR [eax+edx], xmm0

; 587  :   dest[2][1] = yz + wx;

  00249	f3 0f 10 45 98	 movss	 xmm0, DWORD PTR _yz$[ebp]
  0024e	f3 0f 58 45 80	 addss	 xmm0, DWORD PTR _wx$[ebp]
  00253	b8 0c 00 00 00	 mov	 eax, 12			; 0000000cH
  00258	d1 e0		 shl	 eax, 1
  0025a	03 45 0c	 add	 eax, DWORD PTR _dest$[ebp]
  0025d	b9 04 00 00 00	 mov	 ecx, 4
  00262	c1 e1 00	 shl	 ecx, 0
  00265	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0

; 588  :   dest[0][2] = xz + wy;

  0026a	f3 0f 10 45 8c	 movss	 xmm0, DWORD PTR _xz$[ebp]
  0026f	f3 0f 58 85 74
	ff ff ff	 addss	 xmm0, DWORD PTR _wy$[ebp]
  00277	b8 0c 00 00 00	 mov	 eax, 12			; 0000000cH
  0027c	6b c8 00	 imul	 ecx, eax, 0
  0027f	03 4d 0c	 add	 ecx, DWORD PTR _dest$[ebp]
  00282	ba 04 00 00 00	 mov	 edx, 4
  00287	d1 e2		 shl	 edx, 1
  00289	f3 0f 11 04 11	 movss	 DWORD PTR [ecx+edx], xmm0

; 589  : 
; 590  :   dest[0][1] = xy - wz;

  0028e	f3 0f 10 45 a4	 movss	 xmm0, DWORD PTR _xy$[ebp]
  00293	f3 0f 5c 85 68
	ff ff ff	 subss	 xmm0, DWORD PTR _wz$[ebp]
  0029b	b8 0c 00 00 00	 mov	 eax, 12			; 0000000cH
  002a0	6b c8 00	 imul	 ecx, eax, 0
  002a3	03 4d 0c	 add	 ecx, DWORD PTR _dest$[ebp]
  002a6	ba 04 00 00 00	 mov	 edx, 4
  002ab	c1 e2 00	 shl	 edx, 0
  002ae	f3 0f 11 04 11	 movss	 DWORD PTR [ecx+edx], xmm0

; 591  :   dest[1][2] = yz - wx;

  002b3	f3 0f 10 45 98	 movss	 xmm0, DWORD PTR _yz$[ebp]
  002b8	f3 0f 5c 45 80	 subss	 xmm0, DWORD PTR _wx$[ebp]
  002bd	b8 0c 00 00 00	 mov	 eax, 12			; 0000000cH
  002c2	c1 e0 00	 shl	 eax, 0
  002c5	03 45 0c	 add	 eax, DWORD PTR _dest$[ebp]
  002c8	b9 04 00 00 00	 mov	 ecx, 4
  002cd	d1 e1		 shl	 ecx, 1
  002cf	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0

; 592  :   dest[2][0] = xz - wy;

  002d4	f3 0f 10 45 8c	 movss	 xmm0, DWORD PTR _xz$[ebp]
  002d9	f3 0f 5c 85 74
	ff ff ff	 subss	 xmm0, DWORD PTR _wy$[ebp]
  002e1	b8 0c 00 00 00	 mov	 eax, 12			; 0000000cH
  002e6	d1 e0		 shl	 eax, 1
  002e8	03 45 0c	 add	 eax, DWORD PTR _dest$[ebp]
  002eb	b9 04 00 00 00	 mov	 ecx, 4
  002f0	6b d1 00	 imul	 edx, ecx, 0
  002f3	f3 0f 11 04 10	 movss	 DWORD PTR [eax+edx], xmm0

; 593  : }

  002f8	5f		 pop	 edi
  002f9	5e		 pop	 esi
  002fa	5b		 pop	 ebx
  002fb	81 c4 78 01 00
	00		 add	 esp, 376		; 00000178H
  00301	3b ec		 cmp	 ebp, esp
  00303	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00308	8b e5		 mov	 esp, ebp
  0030a	5d		 pop	 ebp
  0030b	c3		 ret	 0
_glm_quat_mat3t ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Light\source\repos\3DRendC\include\quat.h
;	COMDAT _glm_quat_mat3
_TEXT	SEGMENT
tv68 = -376						; size = 4
_s$ = -176						; size = 4
_norm$ = -164						; size = 4
_wz$ = -152						; size = 4
_wy$ = -140						; size = 4
_wx$ = -128						; size = 4
_xz$ = -116						; size = 4
_yz$ = -104						; size = 4
_xy$ = -92						; size = 4
_zz$ = -80						; size = 4
_yy$ = -68						; size = 4
_xx$ = -56						; size = 4
_z$ = -44						; size = 4
_y$ = -32						; size = 4
_x$ = -20						; size = 4
_w$ = -8						; size = 4
_q$ = 8							; size = 4
_dest$ = 12						; size = 4
_glm_quat_mat3 PROC					; COMDAT

; 525  : glm_quat_mat3(versor q, mat3 dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 78 01 00
	00		 sub	 esp, 376		; 00000178H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 88 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-376]
  00012	b9 5e 00 00 00	 mov	 ecx, 94			; 0000005eH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __20CD9DC3_quat@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 526  :   float w, x, y, z,
; 527  :         xx, yy, zz,
; 528  :         xy, yz, xz,
; 529  :         wx, wy, wz, norm, s;
; 530  : 
; 531  :   norm = glm_quat_norm(q);

  00028	8b 45 08	 mov	 eax, DWORD PTR _q$[ebp]
  0002b	50		 push	 eax
  0002c	e8 00 00 00 00	 call	 _glm_quat_norm
  00031	83 c4 04	 add	 esp, 4
  00034	d9 9d 5c ff ff
	ff		 fstp	 DWORD PTR _norm$[ebp]

; 532  :   s    = norm > 0.0f ? 2.0f / norm : 0.0f;

  0003a	f3 0f 10 85 5c
	ff ff ff	 movss	 xmm0, DWORD PTR _norm$[ebp]
  00042	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  00049	76 1a		 jbe	 SHORT $LN3@glm_quat_m
  0004b	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@40000000
  00053	f3 0f 5e 85 5c
	ff ff ff	 divss	 xmm0, DWORD PTR _norm$[ebp]
  0005b	f3 0f 11 85 88
	fe ff ff	 movss	 DWORD PTR tv68[ebp], xmm0
  00063	eb 0b		 jmp	 SHORT $LN4@glm_quat_m
$LN3@glm_quat_m:
  00065	0f 57 c0	 xorps	 xmm0, xmm0
  00068	f3 0f 11 85 88
	fe ff ff	 movss	 DWORD PTR tv68[ebp], xmm0
$LN4@glm_quat_m:
  00070	f3 0f 10 85 88
	fe ff ff	 movss	 xmm0, DWORD PTR tv68[ebp]
  00078	f3 0f 11 85 50
	ff ff ff	 movss	 DWORD PTR _s$[ebp], xmm0

; 533  : 
; 534  :   x = q[0];

  00080	b8 04 00 00 00	 mov	 eax, 4
  00085	6b c8 00	 imul	 ecx, eax, 0
  00088	8b 55 08	 mov	 edx, DWORD PTR _q$[ebp]
  0008b	f3 0f 10 04 0a	 movss	 xmm0, DWORD PTR [edx+ecx]
  00090	f3 0f 11 45 ec	 movss	 DWORD PTR _x$[ebp], xmm0

; 535  :   y = q[1];

  00095	b8 04 00 00 00	 mov	 eax, 4
  0009a	c1 e0 00	 shl	 eax, 0
  0009d	8b 4d 08	 mov	 ecx, DWORD PTR _q$[ebp]
  000a0	f3 0f 10 04 01	 movss	 xmm0, DWORD PTR [ecx+eax]
  000a5	f3 0f 11 45 e0	 movss	 DWORD PTR _y$[ebp], xmm0

; 536  :   z = q[2];

  000aa	b8 04 00 00 00	 mov	 eax, 4
  000af	d1 e0		 shl	 eax, 1
  000b1	8b 4d 08	 mov	 ecx, DWORD PTR _q$[ebp]
  000b4	f3 0f 10 04 01	 movss	 xmm0, DWORD PTR [ecx+eax]
  000b9	f3 0f 11 45 d4	 movss	 DWORD PTR _z$[ebp], xmm0

; 537  :   w = q[3];

  000be	b8 04 00 00 00	 mov	 eax, 4
  000c3	6b c8 03	 imul	 ecx, eax, 3
  000c6	8b 55 08	 mov	 edx, DWORD PTR _q$[ebp]
  000c9	f3 0f 10 04 0a	 movss	 xmm0, DWORD PTR [edx+ecx]
  000ce	f3 0f 11 45 f8	 movss	 DWORD PTR _w$[ebp], xmm0

; 538  : 
; 539  :   xx = s * x * x;   xy = s * x * y;   wx = s * w * x;

  000d3	f3 0f 10 85 50
	ff ff ff	 movss	 xmm0, DWORD PTR _s$[ebp]
  000db	f3 0f 59 45 ec	 mulss	 xmm0, DWORD PTR _x$[ebp]
  000e0	f3 0f 59 45 ec	 mulss	 xmm0, DWORD PTR _x$[ebp]
  000e5	f3 0f 11 45 c8	 movss	 DWORD PTR _xx$[ebp], xmm0
  000ea	f3 0f 10 85 50
	ff ff ff	 movss	 xmm0, DWORD PTR _s$[ebp]
  000f2	f3 0f 59 45 ec	 mulss	 xmm0, DWORD PTR _x$[ebp]
  000f7	f3 0f 59 45 e0	 mulss	 xmm0, DWORD PTR _y$[ebp]
  000fc	f3 0f 11 45 a4	 movss	 DWORD PTR _xy$[ebp], xmm0
  00101	f3 0f 10 85 50
	ff ff ff	 movss	 xmm0, DWORD PTR _s$[ebp]
  00109	f3 0f 59 45 f8	 mulss	 xmm0, DWORD PTR _w$[ebp]
  0010e	f3 0f 59 45 ec	 mulss	 xmm0, DWORD PTR _x$[ebp]
  00113	f3 0f 11 45 80	 movss	 DWORD PTR _wx$[ebp], xmm0

; 540  :   yy = s * y * y;   yz = s * y * z;   wy = s * w * y;

  00118	f3 0f 10 85 50
	ff ff ff	 movss	 xmm0, DWORD PTR _s$[ebp]
  00120	f3 0f 59 45 e0	 mulss	 xmm0, DWORD PTR _y$[ebp]
  00125	f3 0f 59 45 e0	 mulss	 xmm0, DWORD PTR _y$[ebp]
  0012a	f3 0f 11 45 bc	 movss	 DWORD PTR _yy$[ebp], xmm0
  0012f	f3 0f 10 85 50
	ff ff ff	 movss	 xmm0, DWORD PTR _s$[ebp]
  00137	f3 0f 59 45 e0	 mulss	 xmm0, DWORD PTR _y$[ebp]
  0013c	f3 0f 59 45 d4	 mulss	 xmm0, DWORD PTR _z$[ebp]
  00141	f3 0f 11 45 98	 movss	 DWORD PTR _yz$[ebp], xmm0
  00146	f3 0f 10 85 50
	ff ff ff	 movss	 xmm0, DWORD PTR _s$[ebp]
  0014e	f3 0f 59 45 f8	 mulss	 xmm0, DWORD PTR _w$[ebp]
  00153	f3 0f 59 45 e0	 mulss	 xmm0, DWORD PTR _y$[ebp]
  00158	f3 0f 11 85 74
	ff ff ff	 movss	 DWORD PTR _wy$[ebp], xmm0

; 541  :   zz = s * z * z;   xz = s * x * z;   wz = s * w * z;

  00160	f3 0f 10 85 50
	ff ff ff	 movss	 xmm0, DWORD PTR _s$[ebp]
  00168	f3 0f 59 45 d4	 mulss	 xmm0, DWORD PTR _z$[ebp]
  0016d	f3 0f 59 45 d4	 mulss	 xmm0, DWORD PTR _z$[ebp]
  00172	f3 0f 11 45 b0	 movss	 DWORD PTR _zz$[ebp], xmm0
  00177	f3 0f 10 85 50
	ff ff ff	 movss	 xmm0, DWORD PTR _s$[ebp]
  0017f	f3 0f 59 45 ec	 mulss	 xmm0, DWORD PTR _x$[ebp]
  00184	f3 0f 59 45 d4	 mulss	 xmm0, DWORD PTR _z$[ebp]
  00189	f3 0f 11 45 8c	 movss	 DWORD PTR _xz$[ebp], xmm0
  0018e	f3 0f 10 85 50
	ff ff ff	 movss	 xmm0, DWORD PTR _s$[ebp]
  00196	f3 0f 59 45 f8	 mulss	 xmm0, DWORD PTR _w$[ebp]
  0019b	f3 0f 59 45 d4	 mulss	 xmm0, DWORD PTR _z$[ebp]
  001a0	f3 0f 11 85 68
	ff ff ff	 movss	 DWORD PTR _wz$[ebp], xmm0

; 542  : 
; 543  :   dest[0][0] = 1.0f - yy - zz;

  001a8	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  001b0	f3 0f 5c 45 bc	 subss	 xmm0, DWORD PTR _yy$[ebp]
  001b5	f3 0f 5c 45 b0	 subss	 xmm0, DWORD PTR _zz$[ebp]
  001ba	b8 0c 00 00 00	 mov	 eax, 12			; 0000000cH
  001bf	6b c8 00	 imul	 ecx, eax, 0
  001c2	03 4d 0c	 add	 ecx, DWORD PTR _dest$[ebp]
  001c5	ba 04 00 00 00	 mov	 edx, 4
  001ca	6b c2 00	 imul	 eax, edx, 0
  001cd	f3 0f 11 04 01	 movss	 DWORD PTR [ecx+eax], xmm0

; 544  :   dest[1][1] = 1.0f - xx - zz;

  001d2	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  001da	f3 0f 5c 45 c8	 subss	 xmm0, DWORD PTR _xx$[ebp]
  001df	f3 0f 5c 45 b0	 subss	 xmm0, DWORD PTR _zz$[ebp]
  001e4	b8 0c 00 00 00	 mov	 eax, 12			; 0000000cH
  001e9	c1 e0 00	 shl	 eax, 0
  001ec	03 45 0c	 add	 eax, DWORD PTR _dest$[ebp]
  001ef	b9 04 00 00 00	 mov	 ecx, 4
  001f4	c1 e1 00	 shl	 ecx, 0
  001f7	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0

; 545  :   dest[2][2] = 1.0f - xx - yy;

  001fc	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00204	f3 0f 5c 45 c8	 subss	 xmm0, DWORD PTR _xx$[ebp]
  00209	f3 0f 5c 45 bc	 subss	 xmm0, DWORD PTR _yy$[ebp]
  0020e	b8 0c 00 00 00	 mov	 eax, 12			; 0000000cH
  00213	d1 e0		 shl	 eax, 1
  00215	03 45 0c	 add	 eax, DWORD PTR _dest$[ebp]
  00218	b9 04 00 00 00	 mov	 ecx, 4
  0021d	d1 e1		 shl	 ecx, 1
  0021f	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0

; 546  : 
; 547  :   dest[0][1] = xy + wz;

  00224	f3 0f 10 45 a4	 movss	 xmm0, DWORD PTR _xy$[ebp]
  00229	f3 0f 58 85 68
	ff ff ff	 addss	 xmm0, DWORD PTR _wz$[ebp]
  00231	b8 0c 00 00 00	 mov	 eax, 12			; 0000000cH
  00236	6b c8 00	 imul	 ecx, eax, 0
  00239	03 4d 0c	 add	 ecx, DWORD PTR _dest$[ebp]
  0023c	ba 04 00 00 00	 mov	 edx, 4
  00241	c1 e2 00	 shl	 edx, 0
  00244	f3 0f 11 04 11	 movss	 DWORD PTR [ecx+edx], xmm0

; 548  :   dest[1][2] = yz + wx;

  00249	f3 0f 10 45 98	 movss	 xmm0, DWORD PTR _yz$[ebp]
  0024e	f3 0f 58 45 80	 addss	 xmm0, DWORD PTR _wx$[ebp]
  00253	b8 0c 00 00 00	 mov	 eax, 12			; 0000000cH
  00258	c1 e0 00	 shl	 eax, 0
  0025b	03 45 0c	 add	 eax, DWORD PTR _dest$[ebp]
  0025e	b9 04 00 00 00	 mov	 ecx, 4
  00263	d1 e1		 shl	 ecx, 1
  00265	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0

; 549  :   dest[2][0] = xz + wy;

  0026a	f3 0f 10 45 8c	 movss	 xmm0, DWORD PTR _xz$[ebp]
  0026f	f3 0f 58 85 74
	ff ff ff	 addss	 xmm0, DWORD PTR _wy$[ebp]
  00277	b8 0c 00 00 00	 mov	 eax, 12			; 0000000cH
  0027c	d1 e0		 shl	 eax, 1
  0027e	03 45 0c	 add	 eax, DWORD PTR _dest$[ebp]
  00281	b9 04 00 00 00	 mov	 ecx, 4
  00286	6b d1 00	 imul	 edx, ecx, 0
  00289	f3 0f 11 04 10	 movss	 DWORD PTR [eax+edx], xmm0

; 550  : 
; 551  :   dest[1][0] = xy - wz;

  0028e	f3 0f 10 45 a4	 movss	 xmm0, DWORD PTR _xy$[ebp]
  00293	f3 0f 5c 85 68
	ff ff ff	 subss	 xmm0, DWORD PTR _wz$[ebp]
  0029b	b8 0c 00 00 00	 mov	 eax, 12			; 0000000cH
  002a0	c1 e0 00	 shl	 eax, 0
  002a3	03 45 0c	 add	 eax, DWORD PTR _dest$[ebp]
  002a6	b9 04 00 00 00	 mov	 ecx, 4
  002ab	6b d1 00	 imul	 edx, ecx, 0
  002ae	f3 0f 11 04 10	 movss	 DWORD PTR [eax+edx], xmm0

; 552  :   dest[2][1] = yz - wx;

  002b3	f3 0f 10 45 98	 movss	 xmm0, DWORD PTR _yz$[ebp]
  002b8	f3 0f 5c 45 80	 subss	 xmm0, DWORD PTR _wx$[ebp]
  002bd	b8 0c 00 00 00	 mov	 eax, 12			; 0000000cH
  002c2	d1 e0		 shl	 eax, 1
  002c4	03 45 0c	 add	 eax, DWORD PTR _dest$[ebp]
  002c7	b9 04 00 00 00	 mov	 ecx, 4
  002cc	c1 e1 00	 shl	 ecx, 0
  002cf	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0

; 553  :   dest[0][2] = xz - wy;

  002d4	f3 0f 10 45 8c	 movss	 xmm0, DWORD PTR _xz$[ebp]
  002d9	f3 0f 5c 85 74
	ff ff ff	 subss	 xmm0, DWORD PTR _wy$[ebp]
  002e1	b8 0c 00 00 00	 mov	 eax, 12			; 0000000cH
  002e6	6b c8 00	 imul	 ecx, eax, 0
  002e9	03 4d 0c	 add	 ecx, DWORD PTR _dest$[ebp]
  002ec	ba 04 00 00 00	 mov	 edx, 4
  002f1	d1 e2		 shl	 edx, 1
  002f3	f3 0f 11 04 11	 movss	 DWORD PTR [ecx+edx], xmm0

; 554  : }

  002f8	5f		 pop	 edi
  002f9	5e		 pop	 esi
  002fa	5b		 pop	 ebx
  002fb	81 c4 78 01 00
	00		 add	 esp, 376		; 00000178H
  00301	3b ec		 cmp	 ebp, esp
  00303	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00308	8b e5		 mov	 esp, ebp
  0030a	5d		 pop	 ebp
  0030b	c3		 ret	 0
_glm_quat_mat3 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Light\source\repos\3DRendC\include\quat.h
;	COMDAT _glm_quat_mat4t
_TEXT	SEGMENT
tv68 = -376						; size = 4
_s$ = -176						; size = 4
_norm$ = -164						; size = 4
_wz$ = -152						; size = 4
_wy$ = -140						; size = 4
_wx$ = -128						; size = 4
_xz$ = -116						; size = 4
_yz$ = -104						; size = 4
_xy$ = -92						; size = 4
_zz$ = -80						; size = 4
_yy$ = -68						; size = 4
_xx$ = -56						; size = 4
_z$ = -44						; size = 4
_y$ = -32						; size = 4
_x$ = -20						; size = 4
_w$ = -8						; size = 4
_q$ = 8							; size = 4
_dest$ = 12						; size = 4
_glm_quat_mat4t PROC					; COMDAT

; 478  : glm_quat_mat4t(versor q, mat4 dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 78 01 00
	00		 sub	 esp, 376		; 00000178H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 88 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-376]
  00012	b9 5e 00 00 00	 mov	 ecx, 94			; 0000005eH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __20CD9DC3_quat@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 479  :   float w, x, y, z,
; 480  :         xx, yy, zz,
; 481  :         xy, yz, xz,
; 482  :         wx, wy, wz, norm, s;
; 483  : 
; 484  :   norm = glm_quat_norm(q);

  00028	8b 45 08	 mov	 eax, DWORD PTR _q$[ebp]
  0002b	50		 push	 eax
  0002c	e8 00 00 00 00	 call	 _glm_quat_norm
  00031	83 c4 04	 add	 esp, 4
  00034	d9 9d 5c ff ff
	ff		 fstp	 DWORD PTR _norm$[ebp]

; 485  :   s    = norm > 0.0f ? 2.0f / norm : 0.0f;

  0003a	f3 0f 10 85 5c
	ff ff ff	 movss	 xmm0, DWORD PTR _norm$[ebp]
  00042	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  00049	76 1a		 jbe	 SHORT $LN3@glm_quat_m
  0004b	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@40000000
  00053	f3 0f 5e 85 5c
	ff ff ff	 divss	 xmm0, DWORD PTR _norm$[ebp]
  0005b	f3 0f 11 85 88
	fe ff ff	 movss	 DWORD PTR tv68[ebp], xmm0
  00063	eb 0b		 jmp	 SHORT $LN4@glm_quat_m
$LN3@glm_quat_m:
  00065	0f 57 c0	 xorps	 xmm0, xmm0
  00068	f3 0f 11 85 88
	fe ff ff	 movss	 DWORD PTR tv68[ebp], xmm0
$LN4@glm_quat_m:
  00070	f3 0f 10 85 88
	fe ff ff	 movss	 xmm0, DWORD PTR tv68[ebp]
  00078	f3 0f 11 85 50
	ff ff ff	 movss	 DWORD PTR _s$[ebp], xmm0

; 486  : 
; 487  :   x = q[0];

  00080	b8 04 00 00 00	 mov	 eax, 4
  00085	6b c8 00	 imul	 ecx, eax, 0
  00088	8b 55 08	 mov	 edx, DWORD PTR _q$[ebp]
  0008b	f3 0f 10 04 0a	 movss	 xmm0, DWORD PTR [edx+ecx]
  00090	f3 0f 11 45 ec	 movss	 DWORD PTR _x$[ebp], xmm0

; 488  :   y = q[1];

  00095	b8 04 00 00 00	 mov	 eax, 4
  0009a	c1 e0 00	 shl	 eax, 0
  0009d	8b 4d 08	 mov	 ecx, DWORD PTR _q$[ebp]
  000a0	f3 0f 10 04 01	 movss	 xmm0, DWORD PTR [ecx+eax]
  000a5	f3 0f 11 45 e0	 movss	 DWORD PTR _y$[ebp], xmm0

; 489  :   z = q[2];

  000aa	b8 04 00 00 00	 mov	 eax, 4
  000af	d1 e0		 shl	 eax, 1
  000b1	8b 4d 08	 mov	 ecx, DWORD PTR _q$[ebp]
  000b4	f3 0f 10 04 01	 movss	 xmm0, DWORD PTR [ecx+eax]
  000b9	f3 0f 11 45 d4	 movss	 DWORD PTR _z$[ebp], xmm0

; 490  :   w = q[3];

  000be	b8 04 00 00 00	 mov	 eax, 4
  000c3	6b c8 03	 imul	 ecx, eax, 3
  000c6	8b 55 08	 mov	 edx, DWORD PTR _q$[ebp]
  000c9	f3 0f 10 04 0a	 movss	 xmm0, DWORD PTR [edx+ecx]
  000ce	f3 0f 11 45 f8	 movss	 DWORD PTR _w$[ebp], xmm0

; 491  : 
; 492  :   xx = s * x * x;   xy = s * x * y;   wx = s * w * x;

  000d3	f3 0f 10 85 50
	ff ff ff	 movss	 xmm0, DWORD PTR _s$[ebp]
  000db	f3 0f 59 45 ec	 mulss	 xmm0, DWORD PTR _x$[ebp]
  000e0	f3 0f 59 45 ec	 mulss	 xmm0, DWORD PTR _x$[ebp]
  000e5	f3 0f 11 45 c8	 movss	 DWORD PTR _xx$[ebp], xmm0
  000ea	f3 0f 10 85 50
	ff ff ff	 movss	 xmm0, DWORD PTR _s$[ebp]
  000f2	f3 0f 59 45 ec	 mulss	 xmm0, DWORD PTR _x$[ebp]
  000f7	f3 0f 59 45 e0	 mulss	 xmm0, DWORD PTR _y$[ebp]
  000fc	f3 0f 11 45 a4	 movss	 DWORD PTR _xy$[ebp], xmm0
  00101	f3 0f 10 85 50
	ff ff ff	 movss	 xmm0, DWORD PTR _s$[ebp]
  00109	f3 0f 59 45 f8	 mulss	 xmm0, DWORD PTR _w$[ebp]
  0010e	f3 0f 59 45 ec	 mulss	 xmm0, DWORD PTR _x$[ebp]
  00113	f3 0f 11 45 80	 movss	 DWORD PTR _wx$[ebp], xmm0

; 493  :   yy = s * y * y;   yz = s * y * z;   wy = s * w * y;

  00118	f3 0f 10 85 50
	ff ff ff	 movss	 xmm0, DWORD PTR _s$[ebp]
  00120	f3 0f 59 45 e0	 mulss	 xmm0, DWORD PTR _y$[ebp]
  00125	f3 0f 59 45 e0	 mulss	 xmm0, DWORD PTR _y$[ebp]
  0012a	f3 0f 11 45 bc	 movss	 DWORD PTR _yy$[ebp], xmm0
  0012f	f3 0f 10 85 50
	ff ff ff	 movss	 xmm0, DWORD PTR _s$[ebp]
  00137	f3 0f 59 45 e0	 mulss	 xmm0, DWORD PTR _y$[ebp]
  0013c	f3 0f 59 45 d4	 mulss	 xmm0, DWORD PTR _z$[ebp]
  00141	f3 0f 11 45 98	 movss	 DWORD PTR _yz$[ebp], xmm0
  00146	f3 0f 10 85 50
	ff ff ff	 movss	 xmm0, DWORD PTR _s$[ebp]
  0014e	f3 0f 59 45 f8	 mulss	 xmm0, DWORD PTR _w$[ebp]
  00153	f3 0f 59 45 e0	 mulss	 xmm0, DWORD PTR _y$[ebp]
  00158	f3 0f 11 85 74
	ff ff ff	 movss	 DWORD PTR _wy$[ebp], xmm0

; 494  :   zz = s * z * z;   xz = s * x * z;   wz = s * w * z;

  00160	f3 0f 10 85 50
	ff ff ff	 movss	 xmm0, DWORD PTR _s$[ebp]
  00168	f3 0f 59 45 d4	 mulss	 xmm0, DWORD PTR _z$[ebp]
  0016d	f3 0f 59 45 d4	 mulss	 xmm0, DWORD PTR _z$[ebp]
  00172	f3 0f 11 45 b0	 movss	 DWORD PTR _zz$[ebp], xmm0
  00177	f3 0f 10 85 50
	ff ff ff	 movss	 xmm0, DWORD PTR _s$[ebp]
  0017f	f3 0f 59 45 ec	 mulss	 xmm0, DWORD PTR _x$[ebp]
  00184	f3 0f 59 45 d4	 mulss	 xmm0, DWORD PTR _z$[ebp]
  00189	f3 0f 11 45 8c	 movss	 DWORD PTR _xz$[ebp], xmm0
  0018e	f3 0f 10 85 50
	ff ff ff	 movss	 xmm0, DWORD PTR _s$[ebp]
  00196	f3 0f 59 45 f8	 mulss	 xmm0, DWORD PTR _w$[ebp]
  0019b	f3 0f 59 45 d4	 mulss	 xmm0, DWORD PTR _z$[ebp]
  001a0	f3 0f 11 85 68
	ff ff ff	 movss	 DWORD PTR _wz$[ebp], xmm0

; 495  : 
; 496  :   dest[0][0] = 1.0f - yy - zz;

  001a8	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  001b0	f3 0f 5c 45 bc	 subss	 xmm0, DWORD PTR _yy$[ebp]
  001b5	f3 0f 5c 45 b0	 subss	 xmm0, DWORD PTR _zz$[ebp]
  001ba	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  001bf	6b c8 00	 imul	 ecx, eax, 0
  001c2	03 4d 0c	 add	 ecx, DWORD PTR _dest$[ebp]
  001c5	ba 04 00 00 00	 mov	 edx, 4
  001ca	6b c2 00	 imul	 eax, edx, 0
  001cd	f3 0f 11 04 01	 movss	 DWORD PTR [ecx+eax], xmm0

; 497  :   dest[1][1] = 1.0f - xx - zz;

  001d2	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  001da	f3 0f 5c 45 c8	 subss	 xmm0, DWORD PTR _xx$[ebp]
  001df	f3 0f 5c 45 b0	 subss	 xmm0, DWORD PTR _zz$[ebp]
  001e4	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  001e9	c1 e0 00	 shl	 eax, 0
  001ec	03 45 0c	 add	 eax, DWORD PTR _dest$[ebp]
  001ef	b9 04 00 00 00	 mov	 ecx, 4
  001f4	c1 e1 00	 shl	 ecx, 0
  001f7	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0

; 498  :   dest[2][2] = 1.0f - xx - yy;

  001fc	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00204	f3 0f 5c 45 c8	 subss	 xmm0, DWORD PTR _xx$[ebp]
  00209	f3 0f 5c 45 bc	 subss	 xmm0, DWORD PTR _yy$[ebp]
  0020e	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  00213	d1 e0		 shl	 eax, 1
  00215	03 45 0c	 add	 eax, DWORD PTR _dest$[ebp]
  00218	b9 04 00 00 00	 mov	 ecx, 4
  0021d	d1 e1		 shl	 ecx, 1
  0021f	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0

; 499  : 
; 500  :   dest[1][0] = xy + wz;

  00224	f3 0f 10 45 a4	 movss	 xmm0, DWORD PTR _xy$[ebp]
  00229	f3 0f 58 85 68
	ff ff ff	 addss	 xmm0, DWORD PTR _wz$[ebp]
  00231	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  00236	c1 e0 00	 shl	 eax, 0
  00239	03 45 0c	 add	 eax, DWORD PTR _dest$[ebp]
  0023c	b9 04 00 00 00	 mov	 ecx, 4
  00241	6b d1 00	 imul	 edx, ecx, 0
  00244	f3 0f 11 04 10	 movss	 DWORD PTR [eax+edx], xmm0

; 501  :   dest[2][1] = yz + wx;

  00249	f3 0f 10 45 98	 movss	 xmm0, DWORD PTR _yz$[ebp]
  0024e	f3 0f 58 45 80	 addss	 xmm0, DWORD PTR _wx$[ebp]
  00253	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  00258	d1 e0		 shl	 eax, 1
  0025a	03 45 0c	 add	 eax, DWORD PTR _dest$[ebp]
  0025d	b9 04 00 00 00	 mov	 ecx, 4
  00262	c1 e1 00	 shl	 ecx, 0
  00265	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0

; 502  :   dest[0][2] = xz + wy;

  0026a	f3 0f 10 45 8c	 movss	 xmm0, DWORD PTR _xz$[ebp]
  0026f	f3 0f 58 85 74
	ff ff ff	 addss	 xmm0, DWORD PTR _wy$[ebp]
  00277	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  0027c	6b c8 00	 imul	 ecx, eax, 0
  0027f	03 4d 0c	 add	 ecx, DWORD PTR _dest$[ebp]
  00282	ba 04 00 00 00	 mov	 edx, 4
  00287	d1 e2		 shl	 edx, 1
  00289	f3 0f 11 04 11	 movss	 DWORD PTR [ecx+edx], xmm0

; 503  : 
; 504  :   dest[0][1] = xy - wz;

  0028e	f3 0f 10 45 a4	 movss	 xmm0, DWORD PTR _xy$[ebp]
  00293	f3 0f 5c 85 68
	ff ff ff	 subss	 xmm0, DWORD PTR _wz$[ebp]
  0029b	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  002a0	6b c8 00	 imul	 ecx, eax, 0
  002a3	03 4d 0c	 add	 ecx, DWORD PTR _dest$[ebp]
  002a6	ba 04 00 00 00	 mov	 edx, 4
  002ab	c1 e2 00	 shl	 edx, 0
  002ae	f3 0f 11 04 11	 movss	 DWORD PTR [ecx+edx], xmm0

; 505  :   dest[1][2] = yz - wx;

  002b3	f3 0f 10 45 98	 movss	 xmm0, DWORD PTR _yz$[ebp]
  002b8	f3 0f 5c 45 80	 subss	 xmm0, DWORD PTR _wx$[ebp]
  002bd	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  002c2	c1 e0 00	 shl	 eax, 0
  002c5	03 45 0c	 add	 eax, DWORD PTR _dest$[ebp]
  002c8	b9 04 00 00 00	 mov	 ecx, 4
  002cd	d1 e1		 shl	 ecx, 1
  002cf	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0

; 506  :   dest[2][0] = xz - wy;

  002d4	f3 0f 10 45 8c	 movss	 xmm0, DWORD PTR _xz$[ebp]
  002d9	f3 0f 5c 85 74
	ff ff ff	 subss	 xmm0, DWORD PTR _wy$[ebp]
  002e1	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  002e6	d1 e0		 shl	 eax, 1
  002e8	03 45 0c	 add	 eax, DWORD PTR _dest$[ebp]
  002eb	b9 04 00 00 00	 mov	 ecx, 4
  002f0	6b d1 00	 imul	 edx, ecx, 0
  002f3	f3 0f 11 04 10	 movss	 DWORD PTR [eax+edx], xmm0

; 507  : 
; 508  :   dest[0][3] = 0.0f;

  002f8	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  002fd	6b c8 00	 imul	 ecx, eax, 0
  00300	03 4d 0c	 add	 ecx, DWORD PTR _dest$[ebp]
  00303	ba 04 00 00 00	 mov	 edx, 4
  00308	6b c2 03	 imul	 eax, edx, 3
  0030b	0f 57 c0	 xorps	 xmm0, xmm0
  0030e	f3 0f 11 04 01	 movss	 DWORD PTR [ecx+eax], xmm0

; 509  :   dest[1][3] = 0.0f;

  00313	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  00318	c1 e0 00	 shl	 eax, 0
  0031b	03 45 0c	 add	 eax, DWORD PTR _dest$[ebp]
  0031e	b9 04 00 00 00	 mov	 ecx, 4
  00323	6b d1 03	 imul	 edx, ecx, 3
  00326	0f 57 c0	 xorps	 xmm0, xmm0
  00329	f3 0f 11 04 10	 movss	 DWORD PTR [eax+edx], xmm0

; 510  :   dest[2][3] = 0.0f;

  0032e	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  00333	d1 e0		 shl	 eax, 1
  00335	03 45 0c	 add	 eax, DWORD PTR _dest$[ebp]
  00338	b9 04 00 00 00	 mov	 ecx, 4
  0033d	6b d1 03	 imul	 edx, ecx, 3
  00340	0f 57 c0	 xorps	 xmm0, xmm0
  00343	f3 0f 11 04 10	 movss	 DWORD PTR [eax+edx], xmm0

; 511  :   dest[3][0] = 0.0f;

  00348	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  0034d	6b c8 03	 imul	 ecx, eax, 3
  00350	03 4d 0c	 add	 ecx, DWORD PTR _dest$[ebp]
  00353	ba 04 00 00 00	 mov	 edx, 4
  00358	6b c2 00	 imul	 eax, edx, 0
  0035b	0f 57 c0	 xorps	 xmm0, xmm0
  0035e	f3 0f 11 04 01	 movss	 DWORD PTR [ecx+eax], xmm0

; 512  :   dest[3][1] = 0.0f;

  00363	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  00368	6b c8 03	 imul	 ecx, eax, 3
  0036b	03 4d 0c	 add	 ecx, DWORD PTR _dest$[ebp]
  0036e	ba 04 00 00 00	 mov	 edx, 4
  00373	c1 e2 00	 shl	 edx, 0
  00376	0f 57 c0	 xorps	 xmm0, xmm0
  00379	f3 0f 11 04 11	 movss	 DWORD PTR [ecx+edx], xmm0

; 513  :   dest[3][2] = 0.0f;

  0037e	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  00383	6b c8 03	 imul	 ecx, eax, 3
  00386	03 4d 0c	 add	 ecx, DWORD PTR _dest$[ebp]
  00389	ba 04 00 00 00	 mov	 edx, 4
  0038e	d1 e2		 shl	 edx, 1
  00390	0f 57 c0	 xorps	 xmm0, xmm0
  00393	f3 0f 11 04 11	 movss	 DWORD PTR [ecx+edx], xmm0

; 514  :   dest[3][3] = 1.0f;

  00398	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  0039d	6b c8 03	 imul	 ecx, eax, 3
  003a0	03 4d 0c	 add	 ecx, DWORD PTR _dest$[ebp]
  003a3	ba 04 00 00 00	 mov	 edx, 4
  003a8	6b c2 03	 imul	 eax, edx, 3
  003ab	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  003b3	f3 0f 11 04 01	 movss	 DWORD PTR [ecx+eax], xmm0

; 515  : }

  003b8	5f		 pop	 edi
  003b9	5e		 pop	 esi
  003ba	5b		 pop	 ebx
  003bb	81 c4 78 01 00
	00		 add	 esp, 376		; 00000178H
  003c1	3b ec		 cmp	 ebp, esp
  003c3	e8 00 00 00 00	 call	 __RTC_CheckEsp
  003c8	8b e5		 mov	 esp, ebp
  003ca	5d		 pop	 ebp
  003cb	c3		 ret	 0
_glm_quat_mat4t ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Light\source\repos\3DRendC\include\quat.h
;	COMDAT _glm_quat_mat4
_TEXT	SEGMENT
tv68 = -376						; size = 4
_s$ = -176						; size = 4
_norm$ = -164						; size = 4
_wz$ = -152						; size = 4
_wy$ = -140						; size = 4
_wx$ = -128						; size = 4
_xz$ = -116						; size = 4
_yz$ = -104						; size = 4
_xy$ = -92						; size = 4
_zz$ = -80						; size = 4
_yy$ = -68						; size = 4
_xx$ = -56						; size = 4
_z$ = -44						; size = 4
_y$ = -32						; size = 4
_x$ = -20						; size = 4
_w$ = -8						; size = 4
_q$ = 8							; size = 4
_dest$ = 12						; size = 4
_glm_quat_mat4 PROC					; COMDAT

; 431  : glm_quat_mat4(versor q, mat4 dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 78 01 00
	00		 sub	 esp, 376		; 00000178H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 88 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-376]
  00012	b9 5e 00 00 00	 mov	 ecx, 94			; 0000005eH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __20CD9DC3_quat@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 432  :   float w, x, y, z,
; 433  :         xx, yy, zz,
; 434  :         xy, yz, xz,
; 435  :         wx, wy, wz, norm, s;
; 436  : 
; 437  :   norm = glm_quat_norm(q);

  00028	8b 45 08	 mov	 eax, DWORD PTR _q$[ebp]
  0002b	50		 push	 eax
  0002c	e8 00 00 00 00	 call	 _glm_quat_norm
  00031	83 c4 04	 add	 esp, 4
  00034	d9 9d 5c ff ff
	ff		 fstp	 DWORD PTR _norm$[ebp]

; 438  :   s    = norm > 0.0f ? 2.0f / norm : 0.0f;

  0003a	f3 0f 10 85 5c
	ff ff ff	 movss	 xmm0, DWORD PTR _norm$[ebp]
  00042	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  00049	76 1a		 jbe	 SHORT $LN3@glm_quat_m
  0004b	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@40000000
  00053	f3 0f 5e 85 5c
	ff ff ff	 divss	 xmm0, DWORD PTR _norm$[ebp]
  0005b	f3 0f 11 85 88
	fe ff ff	 movss	 DWORD PTR tv68[ebp], xmm0
  00063	eb 0b		 jmp	 SHORT $LN4@glm_quat_m
$LN3@glm_quat_m:
  00065	0f 57 c0	 xorps	 xmm0, xmm0
  00068	f3 0f 11 85 88
	fe ff ff	 movss	 DWORD PTR tv68[ebp], xmm0
$LN4@glm_quat_m:
  00070	f3 0f 10 85 88
	fe ff ff	 movss	 xmm0, DWORD PTR tv68[ebp]
  00078	f3 0f 11 85 50
	ff ff ff	 movss	 DWORD PTR _s$[ebp], xmm0

; 439  : 
; 440  :   x = q[0];

  00080	b8 04 00 00 00	 mov	 eax, 4
  00085	6b c8 00	 imul	 ecx, eax, 0
  00088	8b 55 08	 mov	 edx, DWORD PTR _q$[ebp]
  0008b	f3 0f 10 04 0a	 movss	 xmm0, DWORD PTR [edx+ecx]
  00090	f3 0f 11 45 ec	 movss	 DWORD PTR _x$[ebp], xmm0

; 441  :   y = q[1];

  00095	b8 04 00 00 00	 mov	 eax, 4
  0009a	c1 e0 00	 shl	 eax, 0
  0009d	8b 4d 08	 mov	 ecx, DWORD PTR _q$[ebp]
  000a0	f3 0f 10 04 01	 movss	 xmm0, DWORD PTR [ecx+eax]
  000a5	f3 0f 11 45 e0	 movss	 DWORD PTR _y$[ebp], xmm0

; 442  :   z = q[2];

  000aa	b8 04 00 00 00	 mov	 eax, 4
  000af	d1 e0		 shl	 eax, 1
  000b1	8b 4d 08	 mov	 ecx, DWORD PTR _q$[ebp]
  000b4	f3 0f 10 04 01	 movss	 xmm0, DWORD PTR [ecx+eax]
  000b9	f3 0f 11 45 d4	 movss	 DWORD PTR _z$[ebp], xmm0

; 443  :   w = q[3];

  000be	b8 04 00 00 00	 mov	 eax, 4
  000c3	6b c8 03	 imul	 ecx, eax, 3
  000c6	8b 55 08	 mov	 edx, DWORD PTR _q$[ebp]
  000c9	f3 0f 10 04 0a	 movss	 xmm0, DWORD PTR [edx+ecx]
  000ce	f3 0f 11 45 f8	 movss	 DWORD PTR _w$[ebp], xmm0

; 444  : 
; 445  :   xx = s * x * x;   xy = s * x * y;   wx = s * w * x;

  000d3	f3 0f 10 85 50
	ff ff ff	 movss	 xmm0, DWORD PTR _s$[ebp]
  000db	f3 0f 59 45 ec	 mulss	 xmm0, DWORD PTR _x$[ebp]
  000e0	f3 0f 59 45 ec	 mulss	 xmm0, DWORD PTR _x$[ebp]
  000e5	f3 0f 11 45 c8	 movss	 DWORD PTR _xx$[ebp], xmm0
  000ea	f3 0f 10 85 50
	ff ff ff	 movss	 xmm0, DWORD PTR _s$[ebp]
  000f2	f3 0f 59 45 ec	 mulss	 xmm0, DWORD PTR _x$[ebp]
  000f7	f3 0f 59 45 e0	 mulss	 xmm0, DWORD PTR _y$[ebp]
  000fc	f3 0f 11 45 a4	 movss	 DWORD PTR _xy$[ebp], xmm0
  00101	f3 0f 10 85 50
	ff ff ff	 movss	 xmm0, DWORD PTR _s$[ebp]
  00109	f3 0f 59 45 f8	 mulss	 xmm0, DWORD PTR _w$[ebp]
  0010e	f3 0f 59 45 ec	 mulss	 xmm0, DWORD PTR _x$[ebp]
  00113	f3 0f 11 45 80	 movss	 DWORD PTR _wx$[ebp], xmm0

; 446  :   yy = s * y * y;   yz = s * y * z;   wy = s * w * y;

  00118	f3 0f 10 85 50
	ff ff ff	 movss	 xmm0, DWORD PTR _s$[ebp]
  00120	f3 0f 59 45 e0	 mulss	 xmm0, DWORD PTR _y$[ebp]
  00125	f3 0f 59 45 e0	 mulss	 xmm0, DWORD PTR _y$[ebp]
  0012a	f3 0f 11 45 bc	 movss	 DWORD PTR _yy$[ebp], xmm0
  0012f	f3 0f 10 85 50
	ff ff ff	 movss	 xmm0, DWORD PTR _s$[ebp]
  00137	f3 0f 59 45 e0	 mulss	 xmm0, DWORD PTR _y$[ebp]
  0013c	f3 0f 59 45 d4	 mulss	 xmm0, DWORD PTR _z$[ebp]
  00141	f3 0f 11 45 98	 movss	 DWORD PTR _yz$[ebp], xmm0
  00146	f3 0f 10 85 50
	ff ff ff	 movss	 xmm0, DWORD PTR _s$[ebp]
  0014e	f3 0f 59 45 f8	 mulss	 xmm0, DWORD PTR _w$[ebp]
  00153	f3 0f 59 45 e0	 mulss	 xmm0, DWORD PTR _y$[ebp]
  00158	f3 0f 11 85 74
	ff ff ff	 movss	 DWORD PTR _wy$[ebp], xmm0

; 447  :   zz = s * z * z;   xz = s * x * z;   wz = s * w * z;

  00160	f3 0f 10 85 50
	ff ff ff	 movss	 xmm0, DWORD PTR _s$[ebp]
  00168	f3 0f 59 45 d4	 mulss	 xmm0, DWORD PTR _z$[ebp]
  0016d	f3 0f 59 45 d4	 mulss	 xmm0, DWORD PTR _z$[ebp]
  00172	f3 0f 11 45 b0	 movss	 DWORD PTR _zz$[ebp], xmm0
  00177	f3 0f 10 85 50
	ff ff ff	 movss	 xmm0, DWORD PTR _s$[ebp]
  0017f	f3 0f 59 45 ec	 mulss	 xmm0, DWORD PTR _x$[ebp]
  00184	f3 0f 59 45 d4	 mulss	 xmm0, DWORD PTR _z$[ebp]
  00189	f3 0f 11 45 8c	 movss	 DWORD PTR _xz$[ebp], xmm0
  0018e	f3 0f 10 85 50
	ff ff ff	 movss	 xmm0, DWORD PTR _s$[ebp]
  00196	f3 0f 59 45 f8	 mulss	 xmm0, DWORD PTR _w$[ebp]
  0019b	f3 0f 59 45 d4	 mulss	 xmm0, DWORD PTR _z$[ebp]
  001a0	f3 0f 11 85 68
	ff ff ff	 movss	 DWORD PTR _wz$[ebp], xmm0

; 448  : 
; 449  :   dest[0][0] = 1.0f - yy - zz;

  001a8	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  001b0	f3 0f 5c 45 bc	 subss	 xmm0, DWORD PTR _yy$[ebp]
  001b5	f3 0f 5c 45 b0	 subss	 xmm0, DWORD PTR _zz$[ebp]
  001ba	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  001bf	6b c8 00	 imul	 ecx, eax, 0
  001c2	03 4d 0c	 add	 ecx, DWORD PTR _dest$[ebp]
  001c5	ba 04 00 00 00	 mov	 edx, 4
  001ca	6b c2 00	 imul	 eax, edx, 0
  001cd	f3 0f 11 04 01	 movss	 DWORD PTR [ecx+eax], xmm0

; 450  :   dest[1][1] = 1.0f - xx - zz;

  001d2	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  001da	f3 0f 5c 45 c8	 subss	 xmm0, DWORD PTR _xx$[ebp]
  001df	f3 0f 5c 45 b0	 subss	 xmm0, DWORD PTR _zz$[ebp]
  001e4	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  001e9	c1 e0 00	 shl	 eax, 0
  001ec	03 45 0c	 add	 eax, DWORD PTR _dest$[ebp]
  001ef	b9 04 00 00 00	 mov	 ecx, 4
  001f4	c1 e1 00	 shl	 ecx, 0
  001f7	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0

; 451  :   dest[2][2] = 1.0f - xx - yy;

  001fc	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00204	f3 0f 5c 45 c8	 subss	 xmm0, DWORD PTR _xx$[ebp]
  00209	f3 0f 5c 45 bc	 subss	 xmm0, DWORD PTR _yy$[ebp]
  0020e	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  00213	d1 e0		 shl	 eax, 1
  00215	03 45 0c	 add	 eax, DWORD PTR _dest$[ebp]
  00218	b9 04 00 00 00	 mov	 ecx, 4
  0021d	d1 e1		 shl	 ecx, 1
  0021f	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0

; 452  : 
; 453  :   dest[0][1] = xy + wz;

  00224	f3 0f 10 45 a4	 movss	 xmm0, DWORD PTR _xy$[ebp]
  00229	f3 0f 58 85 68
	ff ff ff	 addss	 xmm0, DWORD PTR _wz$[ebp]
  00231	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  00236	6b c8 00	 imul	 ecx, eax, 0
  00239	03 4d 0c	 add	 ecx, DWORD PTR _dest$[ebp]
  0023c	ba 04 00 00 00	 mov	 edx, 4
  00241	c1 e2 00	 shl	 edx, 0
  00244	f3 0f 11 04 11	 movss	 DWORD PTR [ecx+edx], xmm0

; 454  :   dest[1][2] = yz + wx;

  00249	f3 0f 10 45 98	 movss	 xmm0, DWORD PTR _yz$[ebp]
  0024e	f3 0f 58 45 80	 addss	 xmm0, DWORD PTR _wx$[ebp]
  00253	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  00258	c1 e0 00	 shl	 eax, 0
  0025b	03 45 0c	 add	 eax, DWORD PTR _dest$[ebp]
  0025e	b9 04 00 00 00	 mov	 ecx, 4
  00263	d1 e1		 shl	 ecx, 1
  00265	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0

; 455  :   dest[2][0] = xz + wy;

  0026a	f3 0f 10 45 8c	 movss	 xmm0, DWORD PTR _xz$[ebp]
  0026f	f3 0f 58 85 74
	ff ff ff	 addss	 xmm0, DWORD PTR _wy$[ebp]
  00277	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  0027c	d1 e0		 shl	 eax, 1
  0027e	03 45 0c	 add	 eax, DWORD PTR _dest$[ebp]
  00281	b9 04 00 00 00	 mov	 ecx, 4
  00286	6b d1 00	 imul	 edx, ecx, 0
  00289	f3 0f 11 04 10	 movss	 DWORD PTR [eax+edx], xmm0

; 456  : 
; 457  :   dest[1][0] = xy - wz;

  0028e	f3 0f 10 45 a4	 movss	 xmm0, DWORD PTR _xy$[ebp]
  00293	f3 0f 5c 85 68
	ff ff ff	 subss	 xmm0, DWORD PTR _wz$[ebp]
  0029b	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  002a0	c1 e0 00	 shl	 eax, 0
  002a3	03 45 0c	 add	 eax, DWORD PTR _dest$[ebp]
  002a6	b9 04 00 00 00	 mov	 ecx, 4
  002ab	6b d1 00	 imul	 edx, ecx, 0
  002ae	f3 0f 11 04 10	 movss	 DWORD PTR [eax+edx], xmm0

; 458  :   dest[2][1] = yz - wx;

  002b3	f3 0f 10 45 98	 movss	 xmm0, DWORD PTR _yz$[ebp]
  002b8	f3 0f 5c 45 80	 subss	 xmm0, DWORD PTR _wx$[ebp]
  002bd	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  002c2	d1 e0		 shl	 eax, 1
  002c4	03 45 0c	 add	 eax, DWORD PTR _dest$[ebp]
  002c7	b9 04 00 00 00	 mov	 ecx, 4
  002cc	c1 e1 00	 shl	 ecx, 0
  002cf	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0

; 459  :   dest[0][2] = xz - wy;

  002d4	f3 0f 10 45 8c	 movss	 xmm0, DWORD PTR _xz$[ebp]
  002d9	f3 0f 5c 85 74
	ff ff ff	 subss	 xmm0, DWORD PTR _wy$[ebp]
  002e1	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  002e6	6b c8 00	 imul	 ecx, eax, 0
  002e9	03 4d 0c	 add	 ecx, DWORD PTR _dest$[ebp]
  002ec	ba 04 00 00 00	 mov	 edx, 4
  002f1	d1 e2		 shl	 edx, 1
  002f3	f3 0f 11 04 11	 movss	 DWORD PTR [ecx+edx], xmm0

; 460  : 
; 461  :   dest[0][3] = 0.0f;

  002f8	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  002fd	6b c8 00	 imul	 ecx, eax, 0
  00300	03 4d 0c	 add	 ecx, DWORD PTR _dest$[ebp]
  00303	ba 04 00 00 00	 mov	 edx, 4
  00308	6b c2 03	 imul	 eax, edx, 3
  0030b	0f 57 c0	 xorps	 xmm0, xmm0
  0030e	f3 0f 11 04 01	 movss	 DWORD PTR [ecx+eax], xmm0

; 462  :   dest[1][3] = 0.0f;

  00313	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  00318	c1 e0 00	 shl	 eax, 0
  0031b	03 45 0c	 add	 eax, DWORD PTR _dest$[ebp]
  0031e	b9 04 00 00 00	 mov	 ecx, 4
  00323	6b d1 03	 imul	 edx, ecx, 3
  00326	0f 57 c0	 xorps	 xmm0, xmm0
  00329	f3 0f 11 04 10	 movss	 DWORD PTR [eax+edx], xmm0

; 463  :   dest[2][3] = 0.0f;

  0032e	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  00333	d1 e0		 shl	 eax, 1
  00335	03 45 0c	 add	 eax, DWORD PTR _dest$[ebp]
  00338	b9 04 00 00 00	 mov	 ecx, 4
  0033d	6b d1 03	 imul	 edx, ecx, 3
  00340	0f 57 c0	 xorps	 xmm0, xmm0
  00343	f3 0f 11 04 10	 movss	 DWORD PTR [eax+edx], xmm0

; 464  :   dest[3][0] = 0.0f;

  00348	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  0034d	6b c8 03	 imul	 ecx, eax, 3
  00350	03 4d 0c	 add	 ecx, DWORD PTR _dest$[ebp]
  00353	ba 04 00 00 00	 mov	 edx, 4
  00358	6b c2 00	 imul	 eax, edx, 0
  0035b	0f 57 c0	 xorps	 xmm0, xmm0
  0035e	f3 0f 11 04 01	 movss	 DWORD PTR [ecx+eax], xmm0

; 465  :   dest[3][1] = 0.0f;

  00363	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  00368	6b c8 03	 imul	 ecx, eax, 3
  0036b	03 4d 0c	 add	 ecx, DWORD PTR _dest$[ebp]
  0036e	ba 04 00 00 00	 mov	 edx, 4
  00373	c1 e2 00	 shl	 edx, 0
  00376	0f 57 c0	 xorps	 xmm0, xmm0
  00379	f3 0f 11 04 11	 movss	 DWORD PTR [ecx+edx], xmm0

; 466  :   dest[3][2] = 0.0f;

  0037e	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  00383	6b c8 03	 imul	 ecx, eax, 3
  00386	03 4d 0c	 add	 ecx, DWORD PTR _dest$[ebp]
  00389	ba 04 00 00 00	 mov	 edx, 4
  0038e	d1 e2		 shl	 edx, 1
  00390	0f 57 c0	 xorps	 xmm0, xmm0
  00393	f3 0f 11 04 11	 movss	 DWORD PTR [ecx+edx], xmm0

; 467  :   dest[3][3] = 1.0f;

  00398	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  0039d	6b c8 03	 imul	 ecx, eax, 3
  003a0	03 4d 0c	 add	 ecx, DWORD PTR _dest$[ebp]
  003a3	ba 04 00 00 00	 mov	 edx, 4
  003a8	6b c2 03	 imul	 eax, edx, 3
  003ab	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  003b3	f3 0f 11 04 01	 movss	 DWORD PTR [ecx+eax], xmm0

; 468  : }

  003b8	5f		 pop	 edi
  003b9	5e		 pop	 esi
  003ba	5b		 pop	 ebx
  003bb	81 c4 78 01 00
	00		 add	 esp, 376		; 00000178H
  003c1	3b ec		 cmp	 ebp, esp
  003c3	e8 00 00 00 00	 call	 __RTC_CheckEsp
  003c8	8b e5		 mov	 esp, ebp
  003ca	5d		 pop	 ebp
  003cb	c3		 ret	 0
_glm_quat_mat4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Light\source\repos\3DRendC\include\quat.h
;	COMDAT _glm_quat_mul
_TEXT	SEGMENT
_p$ = 8							; size = 4
_q$ = 12						; size = 4
_dest$ = 16						; size = 4
_glm_quat_mul PROC					; COMDAT

; 406  : glm_quat_mul(versor p, versor q, versor dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __20CD9DC3_quat@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 407  :   /*
; 408  :     + (a1 b2 + b1 a2 + c1 d2 − d1 c2)i
; 409  :     + (a1 c2 − b1 d2 + c1 a2 + d1 b2)j
; 410  :     + (a1 d2 + b1 c2 − c1 b2 + d1 a2)k
; 411  :        a1 a2 − b1 b2 − c1 c2 − d1 d2
; 412  :    */
; 413  : #if defined( __SSE__ ) || defined( __SSE2__ )
; 414  :   glm_quat_mul_sse2(p, q, dest);

  00028	8b 45 10	 mov	 eax, DWORD PTR _dest$[ebp]
  0002b	50		 push	 eax
  0002c	8b 4d 0c	 mov	 ecx, DWORD PTR _q$[ebp]
  0002f	51		 push	 ecx
  00030	8b 55 08	 mov	 edx, DWORD PTR _p$[ebp]
  00033	52		 push	 edx
  00034	e8 00 00 00 00	 call	 _glm_quat_mul_sse2
  00039	83 c4 0c	 add	 esp, 12			; 0000000cH

; 415  : #else
; 416  :   dest[0] = p[3] * q[0] + p[0] * q[3] + p[1] * q[2] - p[2] * q[1];
; 417  :   dest[1] = p[3] * q[1] - p[0] * q[2] + p[1] * q[3] + p[2] * q[0];
; 418  :   dest[2] = p[3] * q[2] + p[0] * q[1] - p[1] * q[0] + p[2] * q[3];
; 419  :   dest[3] = p[3] * q[3] - p[0] * q[0] - p[1] * q[1] - p[2] * q[2];
; 420  : #endif
; 421  : }

  0003c	5f		 pop	 edi
  0003d	5e		 pop	 esi
  0003e	5b		 pop	 ebx
  0003f	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00045	3b ec		 cmp	 ebp, esp
  00047	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004c	8b e5		 mov	 esp, ebp
  0004e	5d		 pop	 ebp
  0004f	c3		 ret	 0
_glm_quat_mul ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Light\source\repos\3DRendC\include\quat.h
;	COMDAT _glm_quat_axis
_TEXT	SEGMENT
_q$ = 8							; size = 4
_dest$ = 12						; size = 4
_glm_quat_axis PROC					; COMDAT

; 388  : glm_quat_axis(versor q, vec3 dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __20CD9DC3_quat@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 389  :   glm_quat_imagn(q, dest);

  00028	8b 45 0c	 mov	 eax, DWORD PTR _dest$[ebp]
  0002b	50		 push	 eax
  0002c	8b 4d 08	 mov	 ecx, DWORD PTR _q$[ebp]
  0002f	51		 push	 ecx
  00030	e8 00 00 00 00	 call	 _glm_quat_imagn
  00035	83 c4 08	 add	 esp, 8

; 390  : }

  00038	5f		 pop	 edi
  00039	5e		 pop	 esi
  0003a	5b		 pop	 ebx
  0003b	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00041	3b ec		 cmp	 ebp, esp
  00043	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00048	8b e5		 mov	 esp, ebp
  0004a	5d		 pop	 ebp
  0004b	c3		 ret	 0
_glm_quat_axis ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Light\source\repos\3DRendC\include\quat.h
;	COMDAT _glm_quat_angle
_TEXT	SEGMENT
tv90 = -200						; size = 4
tv87 = -196						; size = 4
_q$ = 8							; size = 4
_glm_quat_angle PROC					; COMDAT

; 371  : glm_quat_angle(versor q) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c8 00 00
	00		 sub	 esp, 200		; 000000c8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 38 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-200]
  00012	b9 32 00 00 00	 mov	 ecx, 50			; 00000032H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __20CD9DC3_quat@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 372  :   /*
; 373  :    sin(theta / 2) = length(x*x + y*y + z*z)
; 374  :    cos(theta / 2) = w
; 375  :    theta          = 2 * atan(sin(theta / 2) / cos(theta / 2))
; 376  :    */
; 377  :   return 2.0f * atan2f(glm_quat_imaglen(q), glm_quat_real(q));

  00028	8b 45 08	 mov	 eax, DWORD PTR _q$[ebp]
  0002b	50		 push	 eax
  0002c	e8 00 00 00 00	 call	 _glm_quat_real
  00031	d9 1c 24	 fstp	 DWORD PTR [esp]
  00034	8b 4d 08	 mov	 ecx, DWORD PTR _q$[ebp]
  00037	51		 push	 ecx
  00038	e8 00 00 00 00	 call	 _glm_quat_imaglen
  0003d	d9 1c 24	 fstp	 DWORD PTR [esp]
  00040	e8 00 00 00 00	 call	 _atan2f
  00045	83 c4 08	 add	 esp, 8
  00048	d9 9d 3c ff ff
	ff		 fstp	 DWORD PTR tv87[ebp]
  0004e	f3 0f 10 85 3c
	ff ff ff	 movss	 xmm0, DWORD PTR tv87[ebp]
  00056	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@40000000
  0005e	f3 0f 11 85 38
	ff ff ff	 movss	 DWORD PTR tv90[ebp], xmm0
  00066	d9 85 38 ff ff
	ff		 fld	 DWORD PTR tv90[ebp]

; 378  : }

  0006c	5f		 pop	 edi
  0006d	5e		 pop	 esi
  0006e	5b		 pop	 ebx
  0006f	81 c4 c8 00 00
	00		 add	 esp, 200		; 000000c8H
  00075	3b ec		 cmp	 ebp, esp
  00077	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0007c	8b e5		 mov	 esp, ebp
  0007e	5d		 pop	 ebp
  0007f	c3		 ret	 0
_glm_quat_angle ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Light\source\repos\3DRendC\include\quat.h
;	COMDAT _glm_quat_imaglen
_TEXT	SEGMENT
_q$ = 8							; size = 4
_glm_quat_imaglen PROC					; COMDAT

; 360  : glm_quat_imaglen(versor q) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __20CD9DC3_quat@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 361  :   return glm_vec3_norm(q);

  00028	8b 45 08	 mov	 eax, DWORD PTR _q$[ebp]
  0002b	50		 push	 eax
  0002c	e8 00 00 00 00	 call	 _glm_vec3_norm
  00031	83 c4 04	 add	 esp, 4

; 362  : }

  00034	5f		 pop	 edi
  00035	5e		 pop	 esi
  00036	5b		 pop	 ebx
  00037	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0003d	3b ec		 cmp	 ebp, esp
  0003f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00044	8b e5		 mov	 esp, ebp
  00046	5d		 pop	 ebp
  00047	c3		 ret	 0
_glm_quat_imaglen ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Light\source\repos\3DRendC\include\quat.h
;	COMDAT _glm_quat_imagn
_TEXT	SEGMENT
_q$ = 8							; size = 4
_dest$ = 12						; size = 4
_glm_quat_imagn PROC					; COMDAT

; 349  : glm_quat_imagn(versor q, vec3 dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __20CD9DC3_quat@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 350  :   glm_normalize_to(q, dest);

  00028	8b 45 0c	 mov	 eax, DWORD PTR _dest$[ebp]
  0002b	50		 push	 eax
  0002c	8b 4d 08	 mov	 ecx, DWORD PTR _q$[ebp]
  0002f	51		 push	 ecx
  00030	e8 00 00 00 00	 call	 _glm_normalize_to
  00035	83 c4 08	 add	 esp, 8

; 351  : }

  00038	5f		 pop	 edi
  00039	5e		 pop	 esi
  0003a	5b		 pop	 ebx
  0003b	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00041	3b ec		 cmp	 ebp, esp
  00043	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00048	8b e5		 mov	 esp, ebp
  0004a	5d		 pop	 ebp
  0004b	c3		 ret	 0
_glm_quat_imagn ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Light\source\repos\3DRendC\include\quat.h
;	COMDAT _glm_quat_imag
_TEXT	SEGMENT
_q$ = 8							; size = 4
_dest$ = 12						; size = 4
_glm_quat_imag PROC					; COMDAT

; 336  : glm_quat_imag(versor q, vec3 dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __20CD9DC3_quat@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 337  :   dest[0] = q[0];

  00028	b8 04 00 00 00	 mov	 eax, 4
  0002d	6b c8 00	 imul	 ecx, eax, 0
  00030	ba 04 00 00 00	 mov	 edx, 4
  00035	6b c2 00	 imul	 eax, edx, 0
  00038	8b 55 0c	 mov	 edx, DWORD PTR _dest$[ebp]
  0003b	8b 75 08	 mov	 esi, DWORD PTR _q$[ebp]
  0003e	8b 0c 0e	 mov	 ecx, DWORD PTR [esi+ecx]
  00041	89 0c 02	 mov	 DWORD PTR [edx+eax], ecx

; 338  :   dest[1] = q[1];

  00044	b8 04 00 00 00	 mov	 eax, 4
  00049	c1 e0 00	 shl	 eax, 0
  0004c	b9 04 00 00 00	 mov	 ecx, 4
  00051	c1 e1 00	 shl	 ecx, 0
  00054	8b 55 0c	 mov	 edx, DWORD PTR _dest$[ebp]
  00057	8b 75 08	 mov	 esi, DWORD PTR _q$[ebp]
  0005a	8b 04 06	 mov	 eax, DWORD PTR [esi+eax]
  0005d	89 04 0a	 mov	 DWORD PTR [edx+ecx], eax

; 339  :   dest[2] = q[2];

  00060	b8 04 00 00 00	 mov	 eax, 4
  00065	d1 e0		 shl	 eax, 1
  00067	b9 04 00 00 00	 mov	 ecx, 4
  0006c	d1 e1		 shl	 ecx, 1
  0006e	8b 55 0c	 mov	 edx, DWORD PTR _dest$[ebp]
  00071	8b 75 08	 mov	 esi, DWORD PTR _q$[ebp]
  00074	8b 04 06	 mov	 eax, DWORD PTR [esi+eax]
  00077	89 04 0a	 mov	 DWORD PTR [edx+ecx], eax

; 340  : }

  0007a	5f		 pop	 edi
  0007b	5e		 pop	 esi
  0007c	5b		 pop	 ebx
  0007d	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00083	3b ec		 cmp	 ebp, esp
  00085	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0008a	8b e5		 mov	 esp, ebp
  0008c	5d		 pop	 ebp
  0008d	c3		 ret	 0
_glm_quat_imag ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Light\source\repos\3DRendC\include\quat.h
;	COMDAT _glm_quat_real
_TEXT	SEGMENT
_q$ = 8							; size = 4
_glm_quat_real PROC					; COMDAT

; 324  : glm_quat_real(versor q) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __20CD9DC3_quat@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 325  :   return q[3];

  00028	b8 04 00 00 00	 mov	 eax, 4
  0002d	6b c8 03	 imul	 ecx, eax, 3
  00030	8b 55 08	 mov	 edx, DWORD PTR _q$[ebp]
  00033	d9 04 0a	 fld	 DWORD PTR [edx+ecx]

; 326  : }

  00036	5f		 pop	 edi
  00037	5e		 pop	 esi
  00038	5b		 pop	 ebx
  00039	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0003f	3b ec		 cmp	 ebp, esp
  00041	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00046	8b e5		 mov	 esp, ebp
  00048	5d		 pop	 ebp
  00049	c3		 ret	 0
_glm_quat_real ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Light\source\repos\3DRendC\include\quat.h
;	COMDAT _glm_quat_sub
_TEXT	SEGMENT
_p$ = 8							; size = 4
_q$ = 12						; size = 4
_dest$ = 16						; size = 4
_glm_quat_sub PROC					; COMDAT

; 313  : glm_quat_sub(versor p, versor q, versor dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __20CD9DC3_quat@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 314  :   glm_vec4_sub(p, q, dest);

  00028	8b 45 10	 mov	 eax, DWORD PTR _dest$[ebp]
  0002b	50		 push	 eax
  0002c	8b 4d 0c	 mov	 ecx, DWORD PTR _q$[ebp]
  0002f	51		 push	 ecx
  00030	8b 55 08	 mov	 edx, DWORD PTR _p$[ebp]
  00033	52		 push	 edx
  00034	e8 00 00 00 00	 call	 _glm_vec4_sub
  00039	83 c4 0c	 add	 esp, 12			; 0000000cH

; 315  : }

  0003c	5f		 pop	 edi
  0003d	5e		 pop	 esi
  0003e	5b		 pop	 ebx
  0003f	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00045	3b ec		 cmp	 ebp, esp
  00047	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004c	8b e5		 mov	 esp, ebp
  0004e	5d		 pop	 ebp
  0004f	c3		 ret	 0
_glm_quat_sub ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Light\source\repos\3DRendC\include\quat.h
;	COMDAT _glm_quat_add
_TEXT	SEGMENT
_p$ = 8							; size = 4
_q$ = 12						; size = 4
_dest$ = 16						; size = 4
_glm_quat_add PROC					; COMDAT

; 300  : glm_quat_add(versor p, versor q, versor dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __20CD9DC3_quat@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 301  :   glm_vec4_add(p, q, dest);

  00028	8b 45 10	 mov	 eax, DWORD PTR _dest$[ebp]
  0002b	50		 push	 eax
  0002c	8b 4d 0c	 mov	 ecx, DWORD PTR _q$[ebp]
  0002f	51		 push	 ecx
  00030	8b 55 08	 mov	 edx, DWORD PTR _p$[ebp]
  00033	52		 push	 edx
  00034	e8 00 00 00 00	 call	 _glm_vec4_add
  00039	83 c4 0c	 add	 esp, 12			; 0000000cH

; 302  : }

  0003c	5f		 pop	 edi
  0003d	5e		 pop	 esi
  0003e	5b		 pop	 ebx
  0003f	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00045	3b ec		 cmp	 ebp, esp
  00047	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004c	8b e5		 mov	 esp, ebp
  0004e	5d		 pop	 ebp
  0004f	c3		 ret	 0
_glm_quat_add ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Light\source\repos\3DRendC\include\quat.h
;	COMDAT _glm_quat_inv
_TEXT	SEGMENT
tv79 = -232						; size = 4
_conj$ = -32						; size = 16
__$ArrayPad$ = -4					; size = 4
_q$ = 8							; size = 4
_dest$ = 12						; size = 4
_glm_quat_inv PROC					; COMDAT

; 285  : glm_quat_inv(versor q, versor dest) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 f0	 and	 esp, -16		; fffffff0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec e8 00 00
	00		 sub	 esp, 232		; 000000e8H
  0001c	56		 push	 esi
  0001d	57		 push	 edi
  0001e	8d bd 18 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-232]
  00024	b9 3a 00 00 00	 mov	 ecx, 58			; 0000003aH
  00029	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002e	f3 ab		 rep stosd
  00030	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00035	33 c5		 xor	 eax, ebp
  00037	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0003a	b9 00 00 00 00	 mov	 ecx, OFFSET __20CD9DC3_quat@h
  0003f	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 286  :   CGLM_ALIGN(16) versor conj;
; 287  :   glm_quat_conjugate(q, conj);

  00044	8d 45 e0	 lea	 eax, DWORD PTR _conj$[ebp]
  00047	50		 push	 eax
  00048	8b 4b 08	 mov	 ecx, DWORD PTR _q$[ebx]
  0004b	51		 push	 ecx
  0004c	e8 00 00 00 00	 call	 _glm_quat_conjugate
  00051	83 c4 08	 add	 esp, 8

; 288  :   glm_vec4_scale(conj, 1.0f / glm_vec4_norm2(q), dest);

  00054	8b 43 0c	 mov	 eax, DWORD PTR _dest$[ebx]
  00057	50		 push	 eax
  00058	8b 4b 08	 mov	 ecx, DWORD PTR _q$[ebx]
  0005b	51		 push	 ecx
  0005c	e8 00 00 00 00	 call	 _glm_vec4_norm2
  00061	83 c4 04	 add	 esp, 4
  00064	d9 9d 18 ff ff
	ff		 fstp	 DWORD PTR tv79[ebp]
  0006a	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00072	f3 0f 5e 85 18
	ff ff ff	 divss	 xmm0, DWORD PTR tv79[ebp]
  0007a	51		 push	 ecx
  0007b	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00080	8d 55 e0	 lea	 edx, DWORD PTR _conj$[ebp]
  00083	52		 push	 edx
  00084	e8 00 00 00 00	 call	 _glm_vec4_scale
  00089	83 c4 0c	 add	 esp, 12			; 0000000cH

; 289  : }

  0008c	52		 push	 edx
  0008d	8b cd		 mov	 ecx, ebp
  0008f	50		 push	 eax
  00090	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN5@glm_quat_i
  00096	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  0009b	58		 pop	 eax
  0009c	5a		 pop	 edx
  0009d	5f		 pop	 edi
  0009e	5e		 pop	 esi
  0009f	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000a2	33 cd		 xor	 ecx, ebp
  000a4	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000a9	8b e5		 mov	 esp, ebp
  000ab	5d		 pop	 ebp
  000ac	8b e3		 mov	 esp, ebx
  000ae	5b		 pop	 ebx
  000af	c3		 ret	 0
$LN5@glm_quat_i:
  000b0	01 00 00 00	 DD	 1
  000b4	00 00 00 00	 DD	 $LN4@glm_quat_i
$LN4@glm_quat_i:
  000b8	e0 ff ff ff	 DD	 -32			; ffffffe0H
  000bc	10 00 00 00	 DD	 16			; 00000010H
  000c0	00 00 00 00	 DD	 $LN3@glm_quat_i
$LN3@glm_quat_i:
  000c4	63		 DB	 99			; 00000063H
  000c5	6f		 DB	 111			; 0000006fH
  000c6	6e		 DB	 110			; 0000006eH
  000c7	6a		 DB	 106			; 0000006aH
  000c8	00		 DB	 0
_glm_quat_inv ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Light\source\repos\3DRendC\include\quat.h
;	COMDAT _glm_quat_conjugate
_TEXT	SEGMENT
_q$ = 8							; size = 4
_dest$ = 12						; size = 4
_glm_quat_conjugate PROC				; COMDAT

; 272  : glm_quat_conjugate(versor q, versor dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __20CD9DC3_quat@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 273  :   glm_vec4_negate_to(q, dest);

  00028	8b 45 0c	 mov	 eax, DWORD PTR _dest$[ebp]
  0002b	50		 push	 eax
  0002c	8b 4d 08	 mov	 ecx, DWORD PTR _q$[ebp]
  0002f	51		 push	 ecx
  00030	e8 00 00 00 00	 call	 _glm_vec4_negate_to
  00035	83 c4 08	 add	 esp, 8

; 274  :   dest[3] = -dest[3];

  00038	b8 04 00 00 00	 mov	 eax, 4
  0003d	6b c8 03	 imul	 ecx, eax, 3
  00040	8b 55 0c	 mov	 edx, DWORD PTR _dest$[ebp]
  00043	f3 0f 10 04 0a	 movss	 xmm0, DWORD PTR [edx+ecx]
  00048	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
  0004f	b8 04 00 00 00	 mov	 eax, 4
  00054	6b c8 03	 imul	 ecx, eax, 3
  00057	8b 55 0c	 mov	 edx, DWORD PTR _dest$[ebp]
  0005a	f3 0f 11 04 0a	 movss	 DWORD PTR [edx+ecx], xmm0

; 275  : }

  0005f	5f		 pop	 edi
  00060	5e		 pop	 esi
  00061	5b		 pop	 ebx
  00062	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00068	3b ec		 cmp	 ebp, esp
  0006a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0006f	8b e5		 mov	 esp, ebp
  00071	5d		 pop	 ebp
  00072	c3		 ret	 0
_glm_quat_conjugate ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Light\source\repos\3DRendC\include\quat.h
;	COMDAT _glm_quat_dot
_TEXT	SEGMENT
_p$ = 8							; size = 4
_q$ = 12						; size = 4
_glm_quat_dot PROC					; COMDAT

; 260  : glm_quat_dot(versor p, versor q) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __20CD9DC3_quat@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 261  :   return glm_vec4_dot(p, q);

  00028	8b 45 0c	 mov	 eax, DWORD PTR _q$[ebp]
  0002b	50		 push	 eax
  0002c	8b 4d 08	 mov	 ecx, DWORD PTR _p$[ebp]
  0002f	51		 push	 ecx
  00030	e8 00 00 00 00	 call	 _glm_vec4_dot
  00035	83 c4 08	 add	 esp, 8

; 262  : }

  00038	5f		 pop	 edi
  00039	5e		 pop	 esi
  0003a	5b		 pop	 ebx
  0003b	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00041	3b ec		 cmp	 ebp, esp
  00043	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00048	8b e5		 mov	 esp, ebp
  0004a	5d		 pop	 ebp
  0004b	c3		 ret	 0
_glm_quat_dot ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Light\source\repos\3DRendC\include\quat.h
;	COMDAT _glm_quat_normalize
_TEXT	SEGMENT
_q$ = 8							; size = 4
_glm_quat_normalize PROC				; COMDAT

; 248  : glm_quat_normalize(versor q) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __20CD9DC3_quat@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 249  :   glm_quat_normalize_to(q, q);

  00028	8b 45 08	 mov	 eax, DWORD PTR _q$[ebp]
  0002b	50		 push	 eax
  0002c	8b 4d 08	 mov	 ecx, DWORD PTR _q$[ebp]
  0002f	51		 push	 ecx
  00030	e8 00 00 00 00	 call	 _glm_quat_normalize_to
  00035	83 c4 08	 add	 esp, 8

; 250  : }

  00038	5f		 pop	 edi
  00039	5e		 pop	 esi
  0003a	5b		 pop	 ebx
  0003b	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00041	3b ec		 cmp	 ebp, esp
  00043	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00048	8b e5		 mov	 esp, ebp
  0004a	5d		 pop	 ebp
  0004b	c3		 ret	 0
_glm_quat_normalize ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Light\source\repos\3DRendC\include\quat.h
;	COMDAT _glm_quat_normalize_to
_TEXT	SEGMENT
tv72 = -276						; size = 4
_dot$ = -76						; size = 4
_x0$ = -64						; size = 16
_xdot$ = -32						; size = 16
_q$ = 8							; size = 4
_dest$ = 12						; size = 4
_glm_quat_normalize_to PROC				; COMDAT

; 212  : glm_quat_normalize_to(versor q, versor dest) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 f0	 and	 esp, -16		; fffffff0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec 18 01 00
	00		 sub	 esp, 280		; 00000118H
  0001c	56		 push	 esi
  0001d	57		 push	 edi
  0001e	8d bd e8 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-280]
  00024	b9 46 00 00 00	 mov	 ecx, 70			; 00000046H
  00029	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002e	f3 ab		 rep stosd
  00030	b9 00 00 00 00	 mov	 ecx, OFFSET __20CD9DC3_quat@h
  00035	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 213  : #if defined( __SSE2__ ) || defined( __SSE2__ )
; 214  :   __m128 xdot, x0;
; 215  :   float  dot;
; 216  : 
; 217  :   x0   = glmm_load(q);

  0003a	8b 43 08	 mov	 eax, DWORD PTR _q$[ebx]
  0003d	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  00040	0f 29 45 c0	 movaps	 XMMWORD PTR _x0$[ebp], xmm0

; 218  :   xdot = glmm_vdot(x0, x0);

  00044	0f 28 4d c0	 movaps	 xmm1, XMMWORD PTR _x0$[ebp]
  00048	0f 28 45 c0	 movaps	 xmm0, XMMWORD PTR _x0$[ebp]
  0004c	e8 00 00 00 00	 call	 _glmm_vdot
  00051	0f 29 45 e0	 movaps	 XMMWORD PTR _xdot$[ebp], xmm0

; 219  :   dot  = _mm_cvtss_f32(xdot);

  00055	0f 28 45 e0	 movaps	 xmm0, XMMWORD PTR _xdot$[ebp]
  00059	f3 0f 11 85 ec
	fe ff ff	 movss	 DWORD PTR tv72[ebp], xmm0
  00061	f3 0f 10 85 ec
	fe ff ff	 movss	 xmm0, DWORD PTR tv72[ebp]
  00069	f3 0f 11 45 b4	 movss	 DWORD PTR _dot$[ebp], xmm0

; 220  : 
; 221  :   if (dot <= 0.0f) {

  0006e	0f 57 c0	 xorps	 xmm0, xmm0
  00071	0f 2f 45 b4	 comiss	 xmm0, DWORD PTR _dot$[ebp]
  00075	72 0e		 jb	 SHORT $LN2@glm_quat_n

; 222  :     glm_quat_identity(dest);

  00077	8b 43 0c	 mov	 eax, DWORD PTR _dest$[ebx]
  0007a	50		 push	 eax
  0007b	e8 00 00 00 00	 call	 _glm_quat_identity
  00080	83 c4 04	 add	 esp, 4

; 223  :     return;

  00083	eb 11		 jmp	 SHORT $LN1@glm_quat_n
$LN2@glm_quat_n:

; 224  :   }
; 225  : 
; 226  :   glmm_store(dest, _mm_div_ps(x0, _mm_sqrt_ps(xdot)));

  00085	0f 51 45 e0	 sqrtps	 xmm0, XMMWORD PTR _xdot$[ebp]
  00089	0f 28 4d c0	 movaps	 xmm1, XMMWORD PTR _x0$[ebp]
  0008d	0f 5e c8	 divps	 xmm1, xmm0
  00090	8b 43 0c	 mov	 eax, DWORD PTR _dest$[ebx]
  00093	0f 11 08	 movups	 XMMWORD PTR [eax], xmm1
$LN1@glm_quat_n:

; 227  : #else
; 228  :   float dot;
; 229  : 
; 230  :   dot = glm_vec4_norm2(q);
; 231  : 
; 232  :   if (dot <= 0.0f) {
; 233  :     glm_quat_identity(dest);
; 234  :     return;
; 235  :   }
; 236  : 
; 237  :   glm_vec4_scale(q, 1.0f / sqrtf(dot), dest);
; 238  : #endif
; 239  : }

  00096	5f		 pop	 edi
  00097	5e		 pop	 esi
  00098	8b e5		 mov	 esp, ebp
  0009a	5d		 pop	 ebp
  0009b	8b e3		 mov	 esp, ebx
  0009d	5b		 pop	 ebx
  0009e	c3		 ret	 0
_glm_quat_normalize_to ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Light\source\repos\3DRendC\include\quat.h
;	COMDAT _glm_quat_norm
_TEXT	SEGMENT
_q$ = 8							; size = 4
_glm_quat_norm PROC					; COMDAT

; 200  : glm_quat_norm(versor q) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __20CD9DC3_quat@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 201  :   return glm_vec4_norm(q);

  00028	8b 45 08	 mov	 eax, DWORD PTR _q$[ebp]
  0002b	50		 push	 eax
  0002c	e8 00 00 00 00	 call	 _glm_vec4_norm
  00031	83 c4 04	 add	 esp, 4

; 202  : }

  00034	5f		 pop	 edi
  00035	5e		 pop	 esi
  00036	5b		 pop	 ebx
  00037	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0003d	3b ec		 cmp	 ebp, esp
  0003f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00044	8b e5		 mov	 esp, ebp
  00046	5d		 pop	 ebp
  00047	c3		 ret	 0
_glm_quat_norm ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Light\source\repos\3DRendC\include\quat.h
;	COMDAT _glm_quat_copy
_TEXT	SEGMENT
_q$ = 8							; size = 4
_dest$ = 12						; size = 4
_glm_quat_copy PROC					; COMDAT

; 189  : glm_quat_copy(versor q, versor dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __20CD9DC3_quat@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 190  :   glm_vec4_copy(q, dest);

  00028	8b 45 0c	 mov	 eax, DWORD PTR _dest$[ebp]
  0002b	50		 push	 eax
  0002c	8b 4d 08	 mov	 ecx, DWORD PTR _q$[ebp]
  0002f	51		 push	 ecx
  00030	e8 00 00 00 00	 call	 _glm_vec4_copy
  00035	83 c4 08	 add	 esp, 8

; 191  : }

  00038	5f		 pop	 edi
  00039	5e		 pop	 esi
  0003a	5b		 pop	 ebx
  0003b	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00041	3b ec		 cmp	 ebp, esp
  00043	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00048	8b e5		 mov	 esp, ebp
  0004a	5d		 pop	 ebp
  0004b	c3		 ret	 0
_glm_quat_copy ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Light\source\repos\3DRendC\include\quat.h
;	COMDAT _glm_quat
_TEXT	SEGMENT
_axis$ = -24						; size = 12
__$ArrayPad$ = -4					; size = 4
_q$ = 8							; size = 4
_angle$ = 12						; size = 4
_x$ = 16						; size = 4
_y$ = 20						; size = 4
_z$ = 24						; size = 4
_glm_quat PROC						; COMDAT

; 176  : glm_quat(versor q, float angle, float x, float y, float z) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 f8	 and	 esp, -8			; fffffff8H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec e0 00 00
	00		 sub	 esp, 224		; 000000e0H
  0001c	56		 push	 esi
  0001d	57		 push	 edi
  0001e	8d bd 20 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-224]
  00024	b9 38 00 00 00	 mov	 ecx, 56			; 00000038H
  00029	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002e	f3 ab		 rep stosd
  00030	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00035	33 c5		 xor	 eax, ebp
  00037	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0003a	b9 00 00 00 00	 mov	 ecx, OFFSET __20CD9DC3_quat@h
  0003f	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 177  :   CGLM_ALIGN(8) vec3 axis = {x, y, z};

  00044	f3 0f 10 43 10	 movss	 xmm0, DWORD PTR _x$[ebx]
  00049	f3 0f 11 45 e8	 movss	 DWORD PTR _axis$[ebp], xmm0
  0004e	f3 0f 10 43 14	 movss	 xmm0, DWORD PTR _y$[ebx]
  00053	f3 0f 11 45 ec	 movss	 DWORD PTR _axis$[ebp+4], xmm0
  00058	f3 0f 10 43 18	 movss	 xmm0, DWORD PTR _z$[ebx]
  0005d	f3 0f 11 45 f0	 movss	 DWORD PTR _axis$[ebp+8], xmm0

; 178  :   glm_quatv(q, angle, axis);

  00062	8d 45 e8	 lea	 eax, DWORD PTR _axis$[ebp]
  00065	50		 push	 eax
  00066	51		 push	 ecx
  00067	f3 0f 10 43 0c	 movss	 xmm0, DWORD PTR _angle$[ebx]
  0006c	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00071	8b 4b 08	 mov	 ecx, DWORD PTR _q$[ebx]
  00074	51		 push	 ecx
  00075	e8 00 00 00 00	 call	 _glm_quatv
  0007a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 179  : }

  0007d	52		 push	 edx
  0007e	8b cd		 mov	 ecx, ebp
  00080	50		 push	 eax
  00081	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN5@glm_quat
  00087	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  0008c	58		 pop	 eax
  0008d	5a		 pop	 edx
  0008e	5f		 pop	 edi
  0008f	5e		 pop	 esi
  00090	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00093	33 cd		 xor	 ecx, ebp
  00095	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0009a	8b e5		 mov	 esp, ebp
  0009c	5d		 pop	 ebp
  0009d	8b e3		 mov	 esp, ebx
  0009f	5b		 pop	 ebx
  000a0	c3		 ret	 0
  000a1	0f 1f 00	 npad	 3
$LN5@glm_quat:
  000a4	01 00 00 00	 DD	 1
  000a8	00 00 00 00	 DD	 $LN4@glm_quat
$LN4@glm_quat:
  000ac	e8 ff ff ff	 DD	 -24			; ffffffe8H
  000b0	0c 00 00 00	 DD	 12			; 0000000cH
  000b4	00 00 00 00	 DD	 $LN3@glm_quat
$LN3@glm_quat:
  000b8	61		 DB	 97			; 00000061H
  000b9	78		 DB	 120			; 00000078H
  000ba	69		 DB	 105			; 00000069H
  000bb	73		 DB	 115			; 00000073H
  000bc	00		 DB	 0
_glm_quat ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Light\source\repos\3DRendC\include\quat.h
;	COMDAT _glm_quatv
_TEXT	SEGMENT
_s$ = -60						; size = 4
_c$ = -48						; size = 4
_a$ = -36						; size = 4
_k$ = -24						; size = 12
__$ArrayPad$ = -4					; size = 4
_q$ = 8							; size = 4
_angle$ = 12						; size = 4
_axis$ = 16						; size = 4
_glm_quatv PROC						; COMDAT

; 149  : glm_quatv(versor q, float angle, vec3 axis) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 f8	 and	 esp, -8			; fffffff8H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec 00 01 00
	00		 sub	 esp, 256		; 00000100H
  0001c	56		 push	 esi
  0001d	57		 push	 edi
  0001e	8d bd 00 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-256]
  00024	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  00029	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002e	f3 ab		 rep stosd
  00030	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00035	33 c5		 xor	 eax, ebp
  00037	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0003a	b9 00 00 00 00	 mov	 ecx, OFFSET __20CD9DC3_quat@h
  0003f	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 150  :   CGLM_ALIGN(8) vec3 k;
; 151  :   float a, c, s;
; 152  : 
; 153  :   a = angle * 0.5f;

  00044	f3 0f 10 43 0c	 movss	 xmm0, DWORD PTR _angle$[ebx]
  00049	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@3f000000
  00051	f3 0f 11 45 dc	 movss	 DWORD PTR _a$[ebp], xmm0

; 154  :   c = cosf(a);

  00056	51		 push	 ecx
  00057	f3 0f 10 45 dc	 movss	 xmm0, DWORD PTR _a$[ebp]
  0005c	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00061	e8 00 00 00 00	 call	 _cosf
  00066	83 c4 04	 add	 esp, 4
  00069	d9 5d d0	 fstp	 DWORD PTR _c$[ebp]

; 155  :   s = sinf(a);

  0006c	51		 push	 ecx
  0006d	f3 0f 10 45 dc	 movss	 xmm0, DWORD PTR _a$[ebp]
  00072	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00077	e8 00 00 00 00	 call	 _sinf
  0007c	83 c4 04	 add	 esp, 4
  0007f	d9 5d c4	 fstp	 DWORD PTR _s$[ebp]

; 156  : 
; 157  :   glm_normalize_to(axis, k);

  00082	8d 45 e8	 lea	 eax, DWORD PTR _k$[ebp]
  00085	50		 push	 eax
  00086	8b 4b 10	 mov	 ecx, DWORD PTR _axis$[ebx]
  00089	51		 push	 ecx
  0008a	e8 00 00 00 00	 call	 _glm_normalize_to
  0008f	83 c4 08	 add	 esp, 8

; 158  : 
; 159  :   q[0] = s * k[0];

  00092	b8 04 00 00 00	 mov	 eax, 4
  00097	6b c8 00	 imul	 ecx, eax, 0
  0009a	f3 0f 10 45 c4	 movss	 xmm0, DWORD PTR _s$[ebp]
  0009f	f3 0f 59 44 0d
	e8		 mulss	 xmm0, DWORD PTR _k$[ebp+ecx]
  000a5	ba 04 00 00 00	 mov	 edx, 4
  000aa	6b c2 00	 imul	 eax, edx, 0
  000ad	8b 4b 08	 mov	 ecx, DWORD PTR _q$[ebx]
  000b0	f3 0f 11 04 01	 movss	 DWORD PTR [ecx+eax], xmm0

; 160  :   q[1] = s * k[1];

  000b5	b8 04 00 00 00	 mov	 eax, 4
  000ba	c1 e0 00	 shl	 eax, 0
  000bd	f3 0f 10 45 c4	 movss	 xmm0, DWORD PTR _s$[ebp]
  000c2	f3 0f 59 44 05
	e8		 mulss	 xmm0, DWORD PTR _k$[ebp+eax]
  000c8	b9 04 00 00 00	 mov	 ecx, 4
  000cd	c1 e1 00	 shl	 ecx, 0
  000d0	8b 53 08	 mov	 edx, DWORD PTR _q$[ebx]
  000d3	f3 0f 11 04 0a	 movss	 DWORD PTR [edx+ecx], xmm0

; 161  :   q[2] = s * k[2];

  000d8	b8 04 00 00 00	 mov	 eax, 4
  000dd	d1 e0		 shl	 eax, 1
  000df	f3 0f 10 45 c4	 movss	 xmm0, DWORD PTR _s$[ebp]
  000e4	f3 0f 59 44 05
	e8		 mulss	 xmm0, DWORD PTR _k$[ebp+eax]
  000ea	b9 04 00 00 00	 mov	 ecx, 4
  000ef	d1 e1		 shl	 ecx, 1
  000f1	8b 53 08	 mov	 edx, DWORD PTR _q$[ebx]
  000f4	f3 0f 11 04 0a	 movss	 DWORD PTR [edx+ecx], xmm0

; 162  :   q[3] = c;

  000f9	b8 04 00 00 00	 mov	 eax, 4
  000fe	6b c8 03	 imul	 ecx, eax, 3
  00101	8b 53 08	 mov	 edx, DWORD PTR _q$[ebx]
  00104	f3 0f 10 45 d0	 movss	 xmm0, DWORD PTR _c$[ebp]
  00109	f3 0f 11 04 0a	 movss	 DWORD PTR [edx+ecx], xmm0

; 163  : }

  0010e	52		 push	 edx
  0010f	8b cd		 mov	 ecx, ebp
  00111	50		 push	 eax
  00112	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN5@glm_quatv
  00118	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  0011d	58		 pop	 eax
  0011e	5a		 pop	 edx
  0011f	5f		 pop	 edi
  00120	5e		 pop	 esi
  00121	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00124	33 cd		 xor	 ecx, ebp
  00126	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0012b	8b e5		 mov	 esp, ebp
  0012d	5d		 pop	 ebp
  0012e	8b e3		 mov	 esp, ebx
  00130	5b		 pop	 ebx
  00131	c3		 ret	 0
  00132	66 90		 npad	 2
$LN5@glm_quatv:
  00134	01 00 00 00	 DD	 1
  00138	00 00 00 00	 DD	 $LN4@glm_quatv
$LN4@glm_quatv:
  0013c	e8 ff ff ff	 DD	 -24			; ffffffe8H
  00140	0c 00 00 00	 DD	 12			; 0000000cH
  00144	00 00 00 00	 DD	 $LN3@glm_quatv
$LN3@glm_quatv:
  00148	6b		 DB	 107			; 0000006bH
  00149	00		 DB	 0
_glm_quatv ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Light\source\repos\3DRendC\include\quat.h
;	COMDAT _glm_quat_init
_TEXT	SEGMENT
_q$ = 8							; size = 4
_x$ = 12						; size = 4
_y$ = 16						; size = 4
_z$ = 20						; size = 4
_w$ = 24						; size = 4
_glm_quat_init PROC					; COMDAT

; 133  : glm_quat_init(versor q, float x, float y, float z, float w) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __20CD9DC3_quat@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 134  :   q[0] = x;

  00028	b8 04 00 00 00	 mov	 eax, 4
  0002d	6b c8 00	 imul	 ecx, eax, 0
  00030	8b 55 08	 mov	 edx, DWORD PTR _q$[ebp]
  00033	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _x$[ebp]
  00038	f3 0f 11 04 0a	 movss	 DWORD PTR [edx+ecx], xmm0

; 135  :   q[1] = y;

  0003d	b8 04 00 00 00	 mov	 eax, 4
  00042	c1 e0 00	 shl	 eax, 0
  00045	8b 4d 08	 mov	 ecx, DWORD PTR _q$[ebp]
  00048	f3 0f 10 45 10	 movss	 xmm0, DWORD PTR _y$[ebp]
  0004d	f3 0f 11 04 01	 movss	 DWORD PTR [ecx+eax], xmm0

; 136  :   q[2] = z;

  00052	b8 04 00 00 00	 mov	 eax, 4
  00057	d1 e0		 shl	 eax, 1
  00059	8b 4d 08	 mov	 ecx, DWORD PTR _q$[ebp]
  0005c	f3 0f 10 45 14	 movss	 xmm0, DWORD PTR _z$[ebp]
  00061	f3 0f 11 04 01	 movss	 DWORD PTR [ecx+eax], xmm0

; 137  :   q[3] = w;

  00066	b8 04 00 00 00	 mov	 eax, 4
  0006b	6b c8 03	 imul	 ecx, eax, 3
  0006e	8b 55 08	 mov	 edx, DWORD PTR _q$[ebp]
  00071	f3 0f 10 45 18	 movss	 xmm0, DWORD PTR _w$[ebp]
  00076	f3 0f 11 04 0a	 movss	 DWORD PTR [edx+ecx], xmm0

; 138  : }

  0007b	5f		 pop	 edi
  0007c	5e		 pop	 esi
  0007d	5b		 pop	 ebx
  0007e	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00084	3b ec		 cmp	 ebp, esp
  00086	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0008b	8b e5		 mov	 esp, ebp
  0008d	5d		 pop	 ebp
  0008e	c3		 ret	 0
_glm_quat_init ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Light\source\repos\3DRendC\include\quat.h
;	COMDAT _glm_quat_identity_array
_TEXT	SEGMENT
_i$ = -44						; size = 4
_v$ = -32						; size = 16
__$ArrayPad$ = -4					; size = 4
_q$ = 8							; size = 4
_count$ = 12						; size = 4
_glm_quat_identity_array PROC				; COMDAT

; 113  : glm_quat_identity_array(versor * __restrict q, size_t count) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 f0	 and	 esp, -16		; fffffff0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec f8 00 00
	00		 sub	 esp, 248		; 000000f8H
  0001c	56		 push	 esi
  0001d	57		 push	 edi
  0001e	8d bd 08 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-248]
  00024	b9 3e 00 00 00	 mov	 ecx, 62			; 0000003eH
  00029	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002e	f3 ab		 rep stosd
  00030	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00035	33 c5		 xor	 eax, ebp
  00037	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0003a	b9 00 00 00 00	 mov	 ecx, OFFSET __20CD9DC3_quat@h
  0003f	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 114  :   CGLM_ALIGN(16) versor v = GLM_QUAT_IDENTITY_INIT;

  00044	0f 57 c0	 xorps	 xmm0, xmm0
  00047	f3 0f 11 45 e0	 movss	 DWORD PTR _v$[ebp], xmm0
  0004c	0f 57 c0	 xorps	 xmm0, xmm0
  0004f	f3 0f 11 45 e4	 movss	 DWORD PTR _v$[ebp+4], xmm0
  00054	0f 57 c0	 xorps	 xmm0, xmm0
  00057	f3 0f 11 45 e8	 movss	 DWORD PTR _v$[ebp+8], xmm0
  0005c	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00064	f3 0f 11 45 ec	 movss	 DWORD PTR _v$[ebp+12], xmm0

; 115  :   size_t i;
; 116  : 
; 117  :   for (i = 0; i < count; i++) {

  00069	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00070	eb 09		 jmp	 SHORT $LN4@glm_quat_i
$LN2@glm_quat_i:
  00072	8b 45 d4	 mov	 eax, DWORD PTR _i$[ebp]
  00075	83 c0 01	 add	 eax, 1
  00078	89 45 d4	 mov	 DWORD PTR _i$[ebp], eax
$LN4@glm_quat_i:
  0007b	8b 45 d4	 mov	 eax, DWORD PTR _i$[ebp]
  0007e	3b 43 0c	 cmp	 eax, DWORD PTR _count$[ebx]
  00081	73 18		 jae	 SHORT $LN3@glm_quat_i

; 118  :     glm_vec4_copy(v, q[i]);

  00083	8b 45 d4	 mov	 eax, DWORD PTR _i$[ebp]
  00086	c1 e0 04	 shl	 eax, 4
  00089	03 43 08	 add	 eax, DWORD PTR _q$[ebx]
  0008c	50		 push	 eax
  0008d	8d 4d e0	 lea	 ecx, DWORD PTR _v$[ebp]
  00090	51		 push	 ecx
  00091	e8 00 00 00 00	 call	 _glm_vec4_copy
  00096	83 c4 08	 add	 esp, 8

; 119  :   }

  00099	eb d7		 jmp	 SHORT $LN2@glm_quat_i
$LN3@glm_quat_i:

; 120  : }

  0009b	52		 push	 edx
  0009c	8b cd		 mov	 ecx, ebp
  0009e	50		 push	 eax
  0009f	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN8@glm_quat_i
  000a5	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  000aa	58		 pop	 eax
  000ab	5a		 pop	 edx
  000ac	5f		 pop	 edi
  000ad	5e		 pop	 esi
  000ae	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000b1	33 cd		 xor	 ecx, ebp
  000b3	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000b8	8b e5		 mov	 esp, ebp
  000ba	5d		 pop	 ebp
  000bb	8b e3		 mov	 esp, ebx
  000bd	5b		 pop	 ebx
  000be	c3		 ret	 0
  000bf	90		 npad	 1
$LN8@glm_quat_i:
  000c0	01 00 00 00	 DD	 1
  000c4	00 00 00 00	 DD	 $LN7@glm_quat_i
$LN7@glm_quat_i:
  000c8	e0 ff ff ff	 DD	 -32			; ffffffe0H
  000cc	10 00 00 00	 DD	 16			; 00000010H
  000d0	00 00 00 00	 DD	 $LN6@glm_quat_i
$LN6@glm_quat_i:
  000d4	76		 DB	 118			; 00000076H
  000d5	00		 DB	 0
_glm_quat_identity_array ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Light\source\repos\3DRendC\include\quat.h
;	COMDAT _glm_quat_identity
_TEXT	SEGMENT
_v$ = -32						; size = 16
__$ArrayPad$ = -4					; size = 4
_q$ = 8							; size = 4
_glm_quat_identity PROC					; COMDAT

; 98   : glm_quat_identity(versor q) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 f0	 and	 esp, -16		; fffffff0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec e8 00 00
	00		 sub	 esp, 232		; 000000e8H
  0001c	56		 push	 esi
  0001d	57		 push	 edi
  0001e	8d bd 18 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-232]
  00024	b9 3a 00 00 00	 mov	 ecx, 58			; 0000003aH
  00029	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002e	f3 ab		 rep stosd
  00030	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00035	33 c5		 xor	 eax, ebp
  00037	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0003a	b9 00 00 00 00	 mov	 ecx, OFFSET __20CD9DC3_quat@h
  0003f	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 99   :   CGLM_ALIGN(16) versor v = GLM_QUAT_IDENTITY_INIT;

  00044	0f 57 c0	 xorps	 xmm0, xmm0
  00047	f3 0f 11 45 e0	 movss	 DWORD PTR _v$[ebp], xmm0
  0004c	0f 57 c0	 xorps	 xmm0, xmm0
  0004f	f3 0f 11 45 e4	 movss	 DWORD PTR _v$[ebp+4], xmm0
  00054	0f 57 c0	 xorps	 xmm0, xmm0
  00057	f3 0f 11 45 e8	 movss	 DWORD PTR _v$[ebp+8], xmm0
  0005c	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00064	f3 0f 11 45 ec	 movss	 DWORD PTR _v$[ebp+12], xmm0

; 100  :   glm_vec4_copy(v, q);

  00069	8b 43 08	 mov	 eax, DWORD PTR _q$[ebx]
  0006c	50		 push	 eax
  0006d	8d 4d e0	 lea	 ecx, DWORD PTR _v$[ebp]
  00070	51		 push	 ecx
  00071	e8 00 00 00 00	 call	 _glm_vec4_copy
  00076	83 c4 08	 add	 esp, 8

; 101  : }

  00079	52		 push	 edx
  0007a	8b cd		 mov	 ecx, ebp
  0007c	50		 push	 eax
  0007d	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN5@glm_quat_i
  00083	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00088	58		 pop	 eax
  00089	5a		 pop	 edx
  0008a	5f		 pop	 edi
  0008b	5e		 pop	 esi
  0008c	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0008f	33 cd		 xor	 ecx, ebp
  00091	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00096	8b e5		 mov	 esp, ebp
  00098	5d		 pop	 ebp
  00099	8b e3		 mov	 esp, ebx
  0009b	5b		 pop	 ebx
  0009c	c3		 ret	 0
  0009d	0f 1f 00	 npad	 3
$LN5@glm_quat_i:
  000a0	01 00 00 00	 DD	 1
  000a4	00 00 00 00	 DD	 $LN4@glm_quat_i
$LN4@glm_quat_i:
  000a8	e0 ff ff ff	 DD	 -32			; ffffffe0H
  000ac	10 00 00 00	 DD	 16			; 00000010H
  000b0	00 00 00 00	 DD	 $LN3@glm_quat_i
$LN3@glm_quat_i:
  000b4	76		 DB	 118			; 00000076H
  000b5	00		 DB	 0
_glm_quat_identity ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Light\source\repos\3DRendC\include\simd\sse2\quat.h
;	COMDAT _glm_quat_mul_sse2
_TEXT	SEGMENT
_r$ = -128						; size = 16
_x0$ = -96						; size = 16
_xq$ = -64						; size = 16
_xp$ = -32						; size = 16
_p$ = 8							; size = 4
_q$ = 12						; size = 4
_dest$ = 16						; size = 4
_glm_quat_mul_sse2 PROC					; COMDAT

; 17   : glm_quat_mul_sse2(versor p, versor q, versor dest) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 f0	 and	 esp, -16		; fffffff0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec 48 01 00
	00		 sub	 esp, 328		; 00000148H
  0001c	56		 push	 esi
  0001d	57		 push	 edi
  0001e	8d bd b8 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-328]
  00024	b9 52 00 00 00	 mov	 ecx, 82			; 00000052H
  00029	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002e	f3 ab		 rep stosd
  00030	b9 00 00 00 00	 mov	 ecx, OFFSET __9A782FAE_quat@h
  00035	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 18   :   /*
; 19   :    + (a1 b2 + b1 a2 + c1 d2 − d1 c2)i
; 20   :    + (a1 c2 − b1 d2 + c1 a2 + d1 b2)j
; 21   :    + (a1 d2 + b1 c2 − c1 b2 + d1 a2)k
; 22   :      a1 a2 − b1 b2 − c1 c2 − d1 d2
; 23   :    */
; 24   : 
; 25   :   __m128 xp, xq, x0, r;
; 26   : 
; 27   :   xp = glmm_load(p); /* 3 2 1 0 */

  0003a	8b 43 08	 mov	 eax, DWORD PTR _p$[ebx]
  0003d	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  00040	0f 29 45 e0	 movaps	 XMMWORD PTR _xp$[ebp], xmm0

; 28   :   xq = glmm_load(q);

  00044	8b 43 0c	 mov	 eax, DWORD PTR _q$[ebx]
  00047	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  0004a	0f 29 45 c0	 movaps	 XMMWORD PTR _xq$[ebp], xmm0

; 29   : 
; 30   :   r  = _mm_mul_ps(glmm_shuff1x(xp, 3), xq);

  0004e	0f 28 45 e0	 movaps	 xmm0, XMMWORD PTR _xp$[ebp]
  00052	0f c6 45 e0 ff	 shufps	 xmm0, XMMWORD PTR _xp$[ebp], 255 ; 000000ffH
  00057	0f 59 45 c0	 mulps	 xmm0, XMMWORD PTR _xq$[ebp]
  0005b	0f 29 45 80	 movaps	 XMMWORD PTR _r$[ebp], xmm0

; 31   : 
; 32   :   x0 = _mm_xor_ps(glmm_shuff1x(xp, 0), _mm_set_ps(-0.f, 0.f, -0.f, 0.f));

  0005f	0f 28 45 e0	 movaps	 xmm0, XMMWORD PTR _xp$[ebp]
  00063	0f c6 45 e0 00	 shufps	 xmm0, XMMWORD PTR _xp$[ebp], 0
  00068	0f 57 05 00 00
	00 00		 xorps	 xmm0, XMMWORD PTR __xmm@80000000000000008000000000000000
  0006f	0f 29 45 a0	 movaps	 XMMWORD PTR _x0$[ebp], xmm0

; 33   :   r  = _mm_add_ps(r, _mm_mul_ps(x0, glmm_shuff1(xq, 0, 1, 2, 3)));

  00073	0f 28 45 c0	 movaps	 xmm0, XMMWORD PTR _xq$[ebp]
  00077	0f c6 45 c0 1b	 shufps	 xmm0, XMMWORD PTR _xq$[ebp], 27 ; 0000001bH
  0007c	0f 28 4d a0	 movaps	 xmm1, XMMWORD PTR _x0$[ebp]
  00080	0f 59 c8	 mulps	 xmm1, xmm0
  00083	0f 28 45 80	 movaps	 xmm0, XMMWORD PTR _r$[ebp]
  00087	0f 58 c1	 addps	 xmm0, xmm1
  0008a	0f 29 45 80	 movaps	 XMMWORD PTR _r$[ebp], xmm0

; 34   : 
; 35   :   x0 = _mm_xor_ps(glmm_shuff1x(xp, 1), _mm_set_ps(-0.f, -0.f, 0.f, 0.f));

  0008e	0f 28 45 e0	 movaps	 xmm0, XMMWORD PTR _xp$[ebp]
  00092	0f c6 45 e0 55	 shufps	 xmm0, XMMWORD PTR _xp$[ebp], 85 ; 00000055H
  00097	0f 57 05 00 00
	00 00		 xorps	 xmm0, XMMWORD PTR __xmm@80000000800000000000000000000000
  0009e	0f 29 45 a0	 movaps	 XMMWORD PTR _x0$[ebp], xmm0

; 36   :   r  = _mm_add_ps(r, _mm_mul_ps(x0, glmm_shuff1(xq, 1, 0, 3, 2)));

  000a2	0f 28 45 c0	 movaps	 xmm0, XMMWORD PTR _xq$[ebp]
  000a6	0f c6 45 c0 4e	 shufps	 xmm0, XMMWORD PTR _xq$[ebp], 78 ; 0000004eH
  000ab	0f 28 4d a0	 movaps	 xmm1, XMMWORD PTR _x0$[ebp]
  000af	0f 59 c8	 mulps	 xmm1, xmm0
  000b2	0f 28 45 80	 movaps	 xmm0, XMMWORD PTR _r$[ebp]
  000b6	0f 58 c1	 addps	 xmm0, xmm1
  000b9	0f 29 45 80	 movaps	 XMMWORD PTR _r$[ebp], xmm0

; 37   : 
; 38   :   x0 = _mm_xor_ps(glmm_shuff1x(xp, 2), _mm_set_ps(-0.f, 0.f, 0.f, -0.f));

  000bd	0f 28 45 e0	 movaps	 xmm0, XMMWORD PTR _xp$[ebp]
  000c1	0f c6 45 e0 aa	 shufps	 xmm0, XMMWORD PTR _xp$[ebp], 170 ; 000000aaH
  000c6	0f 57 05 00 00
	00 00		 xorps	 xmm0, XMMWORD PTR __xmm@80000000000000000000000080000000
  000cd	0f 29 45 a0	 movaps	 XMMWORD PTR _x0$[ebp], xmm0

; 39   :   r  = _mm_add_ps(r, _mm_mul_ps(x0, glmm_shuff1(xq, 2, 3, 0, 1)));

  000d1	0f 28 45 c0	 movaps	 xmm0, XMMWORD PTR _xq$[ebp]
  000d5	0f c6 45 c0 b1	 shufps	 xmm0, XMMWORD PTR _xq$[ebp], 177 ; 000000b1H
  000da	0f 28 4d a0	 movaps	 xmm1, XMMWORD PTR _x0$[ebp]
  000de	0f 59 c8	 mulps	 xmm1, xmm0
  000e1	0f 28 45 80	 movaps	 xmm0, XMMWORD PTR _r$[ebp]
  000e5	0f 58 c1	 addps	 xmm0, xmm1
  000e8	0f 29 45 80	 movaps	 XMMWORD PTR _r$[ebp], xmm0

; 40   : 
; 41   :   glmm_store(dest, r);

  000ec	0f 28 45 80	 movaps	 xmm0, XMMWORD PTR _r$[ebp]
  000f0	8b 43 10	 mov	 eax, DWORD PTR _dest$[ebx]
  000f3	0f 11 00	 movups	 XMMWORD PTR [eax], xmm0

; 42   : }

  000f6	5f		 pop	 edi
  000f7	5e		 pop	 esi
  000f8	8b e5		 mov	 esp, ebp
  000fa	5d		 pop	 ebp
  000fb	8b e3		 mov	 esp, ebx
  000fd	5b		 pop	 ebx
  000fe	c3		 ret	 0
_glm_quat_mul_sse2 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Light\source\repos\3DRendC\include\affine.h
;	COMDAT _glm_translate_make
_TEXT	SEGMENT
_m$ = 8							; size = 4
_v$ = 12						; size = 4
_glm_translate_make PROC				; COMDAT

; 167  : glm_translate_make(mat4 m, vec3 v) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __1A33B462_affine@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 168  :   glm_mat4_identity(m);

  00028	8b 45 08	 mov	 eax, DWORD PTR _m$[ebp]
  0002b	50		 push	 eax
  0002c	e8 00 00 00 00	 call	 _glm_mat4_identity
  00031	83 c4 04	 add	 esp, 4

; 169  :   glm_vec3_copy(v, m[3]);

  00034	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  00039	6b c8 03	 imul	 ecx, eax, 3
  0003c	03 4d 08	 add	 ecx, DWORD PTR _m$[ebp]
  0003f	51		 push	 ecx
  00040	8b 55 0c	 mov	 edx, DWORD PTR _v$[ebp]
  00043	52		 push	 edx
  00044	e8 00 00 00 00	 call	 _glm_vec3_copy
  00049	83 c4 08	 add	 esp, 8

; 170  : }

  0004c	5f		 pop	 edi
  0004d	5e		 pop	 esi
  0004e	5b		 pop	 ebx
  0004f	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00055	3b ec		 cmp	 ebp, esp
  00057	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005c	8b e5		 mov	 esp, ebp
  0005e	5d		 pop	 ebp
  0005f	c3		 ret	 0
_glm_translate_make ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Light\source\repos\3DRendC\include\affine.h
;	COMDAT _glm_translate
_TEXT	SEGMENT
_m$ = 8							; size = 4
_v$ = 12						; size = 4
_glm_translate PROC					; COMDAT

; 52   : glm_translate(mat4 m, vec3 v) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __1A33B462_affine@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 53   : #if defined( __SSE__ ) || defined( __SSE2__ )
; 54   :   glmm_store(m[3],

  00028	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  0002d	6b c8 03	 imul	 ecx, eax, 3
  00030	03 4d 08	 add	 ecx, DWORD PTR _m$[ebp]
  00033	0f 10 01	 movups	 xmm0, XMMWORD PTR [ecx]
  00036	ba 04 00 00 00	 mov	 edx, 4
  0003b	d1 e2		 shl	 edx, 1
  0003d	8b 45 0c	 mov	 eax, DWORD PTR _v$[ebp]
  00040	f3 0f 10 0c 10	 movss	 xmm1, DWORD PTR [eax+edx]
  00045	0f c6 c9 00	 shufps	 xmm1, xmm1, 0
  00049	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  0004e	d1 e1		 shl	 ecx, 1
  00050	03 4d 08	 add	 ecx, DWORD PTR _m$[ebp]
  00053	0f 10 11	 movups	 xmm2, XMMWORD PTR [ecx]
  00056	0f 59 d1	 mulps	 xmm2, xmm1
  00059	0f 58 d0	 addps	 xmm2, xmm0
  0005c	ba 04 00 00 00	 mov	 edx, 4
  00061	c1 e2 00	 shl	 edx, 0
  00064	8b 45 0c	 mov	 eax, DWORD PTR _v$[ebp]
  00067	f3 0f 10 04 10	 movss	 xmm0, DWORD PTR [eax+edx]
  0006c	0f c6 c0 00	 shufps	 xmm0, xmm0, 0
  00070	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  00075	c1 e1 00	 shl	 ecx, 0
  00078	03 4d 08	 add	 ecx, DWORD PTR _m$[ebp]
  0007b	0f 10 09	 movups	 xmm1, XMMWORD PTR [ecx]
  0007e	0f 59 c8	 mulps	 xmm1, xmm0
  00081	ba 04 00 00 00	 mov	 edx, 4
  00086	6b c2 00	 imul	 eax, edx, 0
  00089	8b 4d 0c	 mov	 ecx, DWORD PTR _v$[ebp]
  0008c	f3 0f 10 04 01	 movss	 xmm0, DWORD PTR [ecx+eax]
  00091	0f c6 c0 00	 shufps	 xmm0, xmm0, 0
  00095	ba 10 00 00 00	 mov	 edx, 16			; 00000010H
  0009a	6b c2 00	 imul	 eax, edx, 0
  0009d	03 45 08	 add	 eax, DWORD PTR _m$[ebp]
  000a0	0f 10 18	 movups	 xmm3, XMMWORD PTR [eax]
  000a3	0f 59 d8	 mulps	 xmm3, xmm0
  000a6	0f 58 d9	 addps	 xmm3, xmm1
  000a9	0f 58 da	 addps	 xmm3, xmm2
  000ac	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  000b1	6b d1 03	 imul	 edx, ecx, 3
  000b4	03 55 08	 add	 edx, DWORD PTR _m$[ebp]
  000b7	0f 11 1a	 movups	 XMMWORD PTR [edx], xmm3

; 55   :              _mm_add_ps(_mm_add_ps(_mm_mul_ps(glmm_load(m[0]),
; 56   :                                               _mm_set1_ps(v[0])),
; 57   :                                    _mm_mul_ps(glmm_load(m[1]),
; 58   :                                               _mm_set1_ps(v[1]))),
; 59   :                         _mm_add_ps(_mm_mul_ps(glmm_load(m[2]),
; 60   :                                               _mm_set1_ps(v[2])),
; 61   :                                    glmm_load(m[3]))))
; 62   :   ;
; 63   : #else
; 64   :   vec4 v1, v2, v3;
; 65   : 
; 66   :   glm_vec4_scale(m[0], v[0], v1);
; 67   :   glm_vec4_scale(m[1], v[1], v2);
; 68   :   glm_vec4_scale(m[2], v[2], v3);
; 69   : 
; 70   :   glm_vec4_add(v1, m[3], m[3]);
; 71   :   glm_vec4_add(v2, m[3], m[3]);
; 72   :   glm_vec4_add(v3, m[3], m[3]);
; 73   : #endif
; 74   : }

  000ba	5f		 pop	 edi
  000bb	5e		 pop	 esi
  000bc	5b		 pop	 ebx
  000bd	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  000c3	3b ec		 cmp	 ebp, esp
  000c5	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000ca	8b e5		 mov	 esp, ebp
  000cc	5d		 pop	 ebp
  000cd	c3		 ret	 0
_glm_translate ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Light\source\repos\3DRendC\include\affine-mat.h
;	COMDAT _glm_mul_rot
_TEXT	SEGMENT
_m1$ = 8						; size = 4
_m2$ = 12						; size = 4
_dest$ = 16						; size = 4
_glm_mul_rot PROC					; COMDAT

; 103  : glm_mul_rot(mat4 m1, mat4 m2, mat4 dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __8C09B87C_affine-mat@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 104  : #if defined( __SSE__ ) || defined( __SSE2__ )
; 105  :   glm_mul_rot_sse2(m1, m2, dest);

  00028	8b 45 10	 mov	 eax, DWORD PTR _dest$[ebp]
  0002b	50		 push	 eax
  0002c	8b 4d 0c	 mov	 ecx, DWORD PTR _m2$[ebp]
  0002f	51		 push	 ecx
  00030	8b 55 08	 mov	 edx, DWORD PTR _m1$[ebp]
  00033	52		 push	 edx
  00034	e8 00 00 00 00	 call	 _glm_mul_rot_sse2
  00039	83 c4 0c	 add	 esp, 12			; 0000000cH

; 106  : #else
; 107  :   float a00 = m1[0][0], a01 = m1[0][1], a02 = m1[0][2], a03 = m1[0][3],
; 108  :         a10 = m1[1][0], a11 = m1[1][1], a12 = m1[1][2], a13 = m1[1][3],
; 109  :         a20 = m1[2][0], a21 = m1[2][1], a22 = m1[2][2], a23 = m1[2][3],
; 110  :         a30 = m1[3][0], a31 = m1[3][1], a32 = m1[3][2], a33 = m1[3][3],
; 111  : 
; 112  :         b00 = m2[0][0], b01 = m2[0][1], b02 = m2[0][2],
; 113  :         b10 = m2[1][0], b11 = m2[1][1], b12 = m2[1][2],
; 114  :         b20 = m2[2][0], b21 = m2[2][1], b22 = m2[2][2];
; 115  : 
; 116  :   dest[0][0] = a00 * b00 + a10 * b01 + a20 * b02;
; 117  :   dest[0][1] = a01 * b00 + a11 * b01 + a21 * b02;
; 118  :   dest[0][2] = a02 * b00 + a12 * b01 + a22 * b02;
; 119  :   dest[0][3] = a03 * b00 + a13 * b01 + a23 * b02;
; 120  : 
; 121  :   dest[1][0] = a00 * b10 + a10 * b11 + a20 * b12;
; 122  :   dest[1][1] = a01 * b10 + a11 * b11 + a21 * b12;
; 123  :   dest[1][2] = a02 * b10 + a12 * b11 + a22 * b12;
; 124  :   dest[1][3] = a03 * b10 + a13 * b11 + a23 * b12;
; 125  : 
; 126  :   dest[2][0] = a00 * b20 + a10 * b21 + a20 * b22;
; 127  :   dest[2][1] = a01 * b20 + a11 * b21 + a21 * b22;
; 128  :   dest[2][2] = a02 * b20 + a12 * b21 + a22 * b22;
; 129  :   dest[2][3] = a03 * b20 + a13 * b21 + a23 * b22;
; 130  : 
; 131  :   dest[3][0] = a30;
; 132  :   dest[3][1] = a31;
; 133  :   dest[3][2] = a32;
; 134  :   dest[3][3] = a33;
; 135  : #endif
; 136  : }

  0003c	5f		 pop	 edi
  0003d	5e		 pop	 esi
  0003e	5b		 pop	 ebx
  0003f	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00045	3b ec		 cmp	 ebp, esp
  00047	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004c	8b e5		 mov	 esp, ebp
  0004e	5d		 pop	 ebp
  0004f	c3		 ret	 0
_glm_mul_rot ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Light\source\repos\3DRendC\include\simd\sse2\affine.h
;	COMDAT _glm_mul_rot_sse2
_TEXT	SEGMENT
_r$ = -160						; size = 16
_l3$ = -128						; size = 16
_l2$ = -96						; size = 16
_l1$ = -64						; size = 16
_l0$ = -32						; size = 16
_m1$ = 8						; size = 4
_m2$ = 12						; size = 4
_dest$ = 16						; size = 4
_glm_mul_rot_sse2 PROC					; COMDAT

; 54   : glm_mul_rot_sse2(mat4 m1, mat4 m2, mat4 dest) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 f0	 and	 esp, -16		; fffffff0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec 68 01 00
	00		 sub	 esp, 360		; 00000168H
  0001c	56		 push	 esi
  0001d	57		 push	 edi
  0001e	8d bd 98 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-360]
  00024	b9 5a 00 00 00	 mov	 ecx, 90			; 0000005aH
  00029	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002e	f3 ab		 rep stosd
  00030	b9 00 00 00 00	 mov	 ecx, OFFSET __EF0FC99D_affine@h
  00035	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 55   :   /* D = R * L (Column-Major) */
; 56   :   __m128 l0, l1, l2, l3, r;
; 57   : 
; 58   :   l0 = glmm_load(m1[0]);

  0003a	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  0003f	6b c8 00	 imul	 ecx, eax, 0
  00042	03 4b 08	 add	 ecx, DWORD PTR _m1$[ebx]
  00045	0f 10 01	 movups	 xmm0, XMMWORD PTR [ecx]
  00048	0f 29 45 e0	 movaps	 XMMWORD PTR _l0$[ebp], xmm0

; 59   :   l1 = glmm_load(m1[1]);

  0004c	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  00051	c1 e0 00	 shl	 eax, 0
  00054	03 43 08	 add	 eax, DWORD PTR _m1$[ebx]
  00057	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  0005a	0f 29 45 c0	 movaps	 XMMWORD PTR _l1$[ebp], xmm0

; 60   :   l2 = glmm_load(m1[2]);

  0005e	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  00063	d1 e0		 shl	 eax, 1
  00065	03 43 08	 add	 eax, DWORD PTR _m1$[ebx]
  00068	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  0006b	0f 29 45 a0	 movaps	 XMMWORD PTR _l2$[ebp], xmm0

; 61   :   l3 = glmm_load(m1[3]);

  0006f	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  00074	6b c8 03	 imul	 ecx, eax, 3
  00077	03 4b 08	 add	 ecx, DWORD PTR _m1$[ebx]
  0007a	0f 10 01	 movups	 xmm0, XMMWORD PTR [ecx]
  0007d	0f 29 45 80	 movaps	 XMMWORD PTR _l3$[ebp], xmm0

; 62   : 
; 63   :   r = glmm_load(m2[0]);

  00081	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  00086	6b c8 00	 imul	 ecx, eax, 0
  00089	03 4b 0c	 add	 ecx, DWORD PTR _m2$[ebx]
  0008c	0f 10 01	 movups	 xmm0, XMMWORD PTR [ecx]
  0008f	0f 29 85 60 ff
	ff ff		 movaps	 XMMWORD PTR _r$[ebp], xmm0

; 64   :   glmm_store(dest[0],

  00096	0f 28 85 60 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR _r$[ebp]
  0009d	0f c6 85 60 ff
	ff ff aa	 shufps	 xmm0, XMMWORD PTR _r$[ebp], 170 ; 000000aaH
  000a5	0f 59 45 a0	 mulps	 xmm0, XMMWORD PTR _l2$[ebp]
  000a9	0f 28 8d 60 ff
	ff ff		 movaps	 xmm1, XMMWORD PTR _r$[ebp]
  000b0	0f c6 8d 60 ff
	ff ff 55	 shufps	 xmm1, XMMWORD PTR _r$[ebp], 85 ; 00000055H
  000b8	0f 59 4d c0	 mulps	 xmm1, XMMWORD PTR _l1$[ebp]
  000bc	0f 28 95 60 ff
	ff ff		 movaps	 xmm2, XMMWORD PTR _r$[ebp]
  000c3	0f c6 95 60 ff
	ff ff 00	 shufps	 xmm2, XMMWORD PTR _r$[ebp], 0
  000cb	0f 59 55 e0	 mulps	 xmm2, XMMWORD PTR _l0$[ebp]
  000cf	0f 58 d1	 addps	 xmm2, xmm1
  000d2	0f 58 d0	 addps	 xmm2, xmm0
  000d5	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  000da	6b c8 00	 imul	 ecx, eax, 0
  000dd	03 4b 10	 add	 ecx, DWORD PTR _dest$[ebx]
  000e0	0f 11 11	 movups	 XMMWORD PTR [ecx], xmm2

; 65   :              _mm_add_ps(_mm_add_ps(_mm_mul_ps(glmm_shuff1x(r, 0), l0),
; 66   :                                    _mm_mul_ps(glmm_shuff1x(r, 1), l1)),
; 67   :                         _mm_mul_ps(glmm_shuff1x(r, 2), l2)));
; 68   : 
; 69   :   r = glmm_load(m2[1]);

  000e3	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  000e8	c1 e0 00	 shl	 eax, 0
  000eb	03 43 0c	 add	 eax, DWORD PTR _m2$[ebx]
  000ee	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  000f1	0f 29 85 60 ff
	ff ff		 movaps	 XMMWORD PTR _r$[ebp], xmm0

; 70   :   glmm_store(dest[1],

  000f8	0f 28 85 60 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR _r$[ebp]
  000ff	0f c6 85 60 ff
	ff ff aa	 shufps	 xmm0, XMMWORD PTR _r$[ebp], 170 ; 000000aaH
  00107	0f 59 45 a0	 mulps	 xmm0, XMMWORD PTR _l2$[ebp]
  0010b	0f 28 8d 60 ff
	ff ff		 movaps	 xmm1, XMMWORD PTR _r$[ebp]
  00112	0f c6 8d 60 ff
	ff ff 55	 shufps	 xmm1, XMMWORD PTR _r$[ebp], 85 ; 00000055H
  0011a	0f 59 4d c0	 mulps	 xmm1, XMMWORD PTR _l1$[ebp]
  0011e	0f 28 95 60 ff
	ff ff		 movaps	 xmm2, XMMWORD PTR _r$[ebp]
  00125	0f c6 95 60 ff
	ff ff 00	 shufps	 xmm2, XMMWORD PTR _r$[ebp], 0
  0012d	0f 59 55 e0	 mulps	 xmm2, XMMWORD PTR _l0$[ebp]
  00131	0f 58 d1	 addps	 xmm2, xmm1
  00134	0f 58 d0	 addps	 xmm2, xmm0
  00137	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  0013c	c1 e0 00	 shl	 eax, 0
  0013f	03 43 10	 add	 eax, DWORD PTR _dest$[ebx]
  00142	0f 11 10	 movups	 XMMWORD PTR [eax], xmm2

; 71   :              _mm_add_ps(_mm_add_ps(_mm_mul_ps(glmm_shuff1x(r, 0), l0),
; 72   :                                    _mm_mul_ps(glmm_shuff1x(r, 1), l1)),
; 73   :                         _mm_mul_ps(glmm_shuff1x(r, 2), l2)));
; 74   : 
; 75   :   r = glmm_load(m2[2]);

  00145	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  0014a	d1 e0		 shl	 eax, 1
  0014c	03 43 0c	 add	 eax, DWORD PTR _m2$[ebx]
  0014f	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  00152	0f 29 85 60 ff
	ff ff		 movaps	 XMMWORD PTR _r$[ebp], xmm0

; 76   :   glmm_store(dest[2],

  00159	0f 28 85 60 ff
	ff ff		 movaps	 xmm0, XMMWORD PTR _r$[ebp]
  00160	0f c6 85 60 ff
	ff ff aa	 shufps	 xmm0, XMMWORD PTR _r$[ebp], 170 ; 000000aaH
  00168	0f 59 45 a0	 mulps	 xmm0, XMMWORD PTR _l2$[ebp]
  0016c	0f 28 8d 60 ff
	ff ff		 movaps	 xmm1, XMMWORD PTR _r$[ebp]
  00173	0f c6 8d 60 ff
	ff ff 55	 shufps	 xmm1, XMMWORD PTR _r$[ebp], 85 ; 00000055H
  0017b	0f 59 4d c0	 mulps	 xmm1, XMMWORD PTR _l1$[ebp]
  0017f	0f 28 95 60 ff
	ff ff		 movaps	 xmm2, XMMWORD PTR _r$[ebp]
  00186	0f c6 95 60 ff
	ff ff 00	 shufps	 xmm2, XMMWORD PTR _r$[ebp], 0
  0018e	0f 59 55 e0	 mulps	 xmm2, XMMWORD PTR _l0$[ebp]
  00192	0f 58 d1	 addps	 xmm2, xmm1
  00195	0f 58 d0	 addps	 xmm2, xmm0
  00198	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  0019d	d1 e0		 shl	 eax, 1
  0019f	03 43 10	 add	 eax, DWORD PTR _dest$[ebx]
  001a2	0f 11 10	 movups	 XMMWORD PTR [eax], xmm2

; 77   :              _mm_add_ps(_mm_add_ps(_mm_mul_ps(glmm_shuff1x(r, 0), l0),
; 78   :                                    _mm_mul_ps(glmm_shuff1x(r, 1), l1)),
; 79   :                         _mm_mul_ps(glmm_shuff1x(r, 2), l2)));
; 80   : 
; 81   :   glmm_store(dest[3], l3);

  001a5	0f 28 45 80	 movaps	 xmm0, XMMWORD PTR _l3$[ebp]
  001a9	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  001ae	6b c8 03	 imul	 ecx, eax, 3
  001b1	03 4b 10	 add	 ecx, DWORD PTR _dest$[ebx]
  001b4	0f 11 01	 movups	 XMMWORD PTR [ecx], xmm0

; 82   : }

  001b7	5f		 pop	 edi
  001b8	5e		 pop	 esi
  001b9	8b e5		 mov	 esp, ebp
  001bb	5d		 pop	 ebp
  001bc	8b e3		 mov	 esp, ebx
  001be	5b		 pop	 ebx
  001bf	c3		 ret	 0
_glm_mul_rot_sse2 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Light\source\repos\3DRendC\include\mat3.h
;	COMDAT _glm_mat3_quat
_TEXT	SEGMENT
_rinv$ = -32						; size = 4
_r$ = -20						; size = 4
_trace$ = -8						; size = 4
_m$ = 8							; size = 4
_dest$ = 12						; size = 4
_glm_mat3_quat PROC					; COMDAT

; 259  : glm_mat3_quat(mat3 m, versor dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec e4 00 00
	00		 sub	 esp, 228		; 000000e4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 1c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-228]
  00012	b9 39 00 00 00	 mov	 ecx, 57			; 00000039H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __D3AB5289_mat3@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 260  :   float trace, r, rinv;
; 261  : 
; 262  :   /* it seems using like m12 instead of m[1][2] causes extra instructions */
; 263  : 
; 264  :   trace = m[0][0] + m[1][1] + m[2][2];

  00028	b8 0c 00 00 00	 mov	 eax, 12			; 0000000cH
  0002d	6b c8 00	 imul	 ecx, eax, 0
  00030	03 4d 08	 add	 ecx, DWORD PTR _m$[ebp]
  00033	ba 04 00 00 00	 mov	 edx, 4
  00038	6b c2 00	 imul	 eax, edx, 0
  0003b	ba 0c 00 00 00	 mov	 edx, 12			; 0000000cH
  00040	c1 e2 00	 shl	 edx, 0
  00043	03 55 08	 add	 edx, DWORD PTR _m$[ebp]
  00046	be 04 00 00 00	 mov	 esi, 4
  0004b	c1 e6 00	 shl	 esi, 0
  0004e	f3 0f 10 04 01	 movss	 xmm0, DWORD PTR [ecx+eax]
  00053	f3 0f 58 04 32	 addss	 xmm0, DWORD PTR [edx+esi]
  00058	b8 0c 00 00 00	 mov	 eax, 12			; 0000000cH
  0005d	d1 e0		 shl	 eax, 1
  0005f	03 45 08	 add	 eax, DWORD PTR _m$[ebp]
  00062	b9 04 00 00 00	 mov	 ecx, 4
  00067	d1 e1		 shl	 ecx, 1
  00069	f3 0f 58 04 08	 addss	 xmm0, DWORD PTR [eax+ecx]
  0006e	f3 0f 11 45 f8	 movss	 DWORD PTR _trace$[ebp], xmm0

; 265  :   if (trace >= 0.0f) {

  00073	f3 0f 10 45 f8	 movss	 xmm0, DWORD PTR _trace$[ebp]
  00078	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  0007f	0f 82 1c 01 00
	00		 jb	 $LN2@glm_mat3_q

; 266  :     r       = sqrtf(1.0f + trace);

  00085	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  0008d	f3 0f 58 45 f8	 addss	 xmm0, DWORD PTR _trace$[ebp]
  00092	51		 push	 ecx
  00093	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00098	e8 00 00 00 00	 call	 _sqrtf
  0009d	83 c4 04	 add	 esp, 4
  000a0	d9 5d ec	 fstp	 DWORD PTR _r$[ebp]

; 267  :     rinv    = 0.5f / r;

  000a3	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f000000
  000ab	f3 0f 5e 45 ec	 divss	 xmm0, DWORD PTR _r$[ebp]
  000b0	f3 0f 11 45 e0	 movss	 DWORD PTR _rinv$[ebp], xmm0

; 268  : 
; 269  :     dest[0] = rinv * (m[1][2] - m[2][1]);

  000b5	b8 0c 00 00 00	 mov	 eax, 12			; 0000000cH
  000ba	c1 e0 00	 shl	 eax, 0
  000bd	03 45 08	 add	 eax, DWORD PTR _m$[ebp]
  000c0	b9 04 00 00 00	 mov	 ecx, 4
  000c5	d1 e1		 shl	 ecx, 1
  000c7	ba 0c 00 00 00	 mov	 edx, 12			; 0000000cH
  000cc	d1 e2		 shl	 edx, 1
  000ce	03 55 08	 add	 edx, DWORD PTR _m$[ebp]
  000d1	be 04 00 00 00	 mov	 esi, 4
  000d6	c1 e6 00	 shl	 esi, 0
  000d9	f3 0f 10 04 08	 movss	 xmm0, DWORD PTR [eax+ecx]
  000de	f3 0f 5c 04 32	 subss	 xmm0, DWORD PTR [edx+esi]
  000e3	f3 0f 59 45 e0	 mulss	 xmm0, DWORD PTR _rinv$[ebp]
  000e8	b8 04 00 00 00	 mov	 eax, 4
  000ed	6b c8 00	 imul	 ecx, eax, 0
  000f0	8b 55 0c	 mov	 edx, DWORD PTR _dest$[ebp]
  000f3	f3 0f 11 04 0a	 movss	 DWORD PTR [edx+ecx], xmm0

; 270  :     dest[1] = rinv * (m[2][0] - m[0][2]);

  000f8	b8 0c 00 00 00	 mov	 eax, 12			; 0000000cH
  000fd	d1 e0		 shl	 eax, 1
  000ff	03 45 08	 add	 eax, DWORD PTR _m$[ebp]
  00102	b9 04 00 00 00	 mov	 ecx, 4
  00107	6b d1 00	 imul	 edx, ecx, 0
  0010a	b9 0c 00 00 00	 mov	 ecx, 12			; 0000000cH
  0010f	6b c9 00	 imul	 ecx, ecx, 0
  00112	03 4d 08	 add	 ecx, DWORD PTR _m$[ebp]
  00115	be 04 00 00 00	 mov	 esi, 4
  0011a	d1 e6		 shl	 esi, 1
  0011c	f3 0f 10 04 10	 movss	 xmm0, DWORD PTR [eax+edx]
  00121	f3 0f 5c 04 31	 subss	 xmm0, DWORD PTR [ecx+esi]
  00126	f3 0f 59 45 e0	 mulss	 xmm0, DWORD PTR _rinv$[ebp]
  0012b	ba 04 00 00 00	 mov	 edx, 4
  00130	c1 e2 00	 shl	 edx, 0
  00133	8b 45 0c	 mov	 eax, DWORD PTR _dest$[ebp]
  00136	f3 0f 11 04 10	 movss	 DWORD PTR [eax+edx], xmm0

; 271  :     dest[2] = rinv * (m[0][1] - m[1][0]);

  0013b	b8 0c 00 00 00	 mov	 eax, 12			; 0000000cH
  00140	6b c8 00	 imul	 ecx, eax, 0
  00143	03 4d 08	 add	 ecx, DWORD PTR _m$[ebp]
  00146	ba 04 00 00 00	 mov	 edx, 4
  0014b	c1 e2 00	 shl	 edx, 0
  0014e	b8 0c 00 00 00	 mov	 eax, 12			; 0000000cH
  00153	c1 e0 00	 shl	 eax, 0
  00156	03 45 08	 add	 eax, DWORD PTR _m$[ebp]
  00159	be 04 00 00 00	 mov	 esi, 4
  0015e	6b f6 00	 imul	 esi, esi, 0
  00161	f3 0f 10 04 11	 movss	 xmm0, DWORD PTR [ecx+edx]
  00166	f3 0f 5c 04 30	 subss	 xmm0, DWORD PTR [eax+esi]
  0016b	f3 0f 59 45 e0	 mulss	 xmm0, DWORD PTR _rinv$[ebp]
  00170	b9 04 00 00 00	 mov	 ecx, 4
  00175	d1 e1		 shl	 ecx, 1
  00177	8b 55 0c	 mov	 edx, DWORD PTR _dest$[ebp]
  0017a	f3 0f 11 04 0a	 movss	 DWORD PTR [edx+ecx], xmm0

; 272  :     dest[3] = r    * 0.5f;

  0017f	f3 0f 10 45 ec	 movss	 xmm0, DWORD PTR _r$[ebp]
  00184	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@3f000000
  0018c	b8 04 00 00 00	 mov	 eax, 4
  00191	6b c8 03	 imul	 ecx, eax, 3
  00194	8b 55 0c	 mov	 edx, DWORD PTR _dest$[ebp]
  00197	f3 0f 11 04 0a	 movss	 DWORD PTR [edx+ecx], xmm0
  0019c	e9 ad 04 00 00	 jmp	 $LN7@glm_mat3_q
$LN2@glm_mat3_q:

; 273  :   } else if (m[0][0] >= m[1][1] && m[0][0] >= m[2][2]) {

  001a1	b8 0c 00 00 00	 mov	 eax, 12			; 0000000cH
  001a6	6b c8 00	 imul	 ecx, eax, 0
  001a9	03 4d 08	 add	 ecx, DWORD PTR _m$[ebp]
  001ac	ba 04 00 00 00	 mov	 edx, 4
  001b1	6b c2 00	 imul	 eax, edx, 0
  001b4	ba 0c 00 00 00	 mov	 edx, 12			; 0000000cH
  001b9	c1 e2 00	 shl	 edx, 0
  001bc	03 55 08	 add	 edx, DWORD PTR _m$[ebp]
  001bf	be 04 00 00 00	 mov	 esi, 4
  001c4	c1 e6 00	 shl	 esi, 0
  001c7	f3 0f 10 04 01	 movss	 xmm0, DWORD PTR [ecx+eax]
  001cc	0f 2f 04 32	 comiss	 xmm0, DWORD PTR [edx+esi]
  001d0	0f 82 90 01 00
	00		 jb	 $LN4@glm_mat3_q
  001d6	b8 0c 00 00 00	 mov	 eax, 12			; 0000000cH
  001db	6b c8 00	 imul	 ecx, eax, 0
  001de	03 4d 08	 add	 ecx, DWORD PTR _m$[ebp]
  001e1	ba 04 00 00 00	 mov	 edx, 4
  001e6	6b c2 00	 imul	 eax, edx, 0
  001e9	ba 0c 00 00 00	 mov	 edx, 12			; 0000000cH
  001ee	d1 e2		 shl	 edx, 1
  001f0	03 55 08	 add	 edx, DWORD PTR _m$[ebp]
  001f3	be 04 00 00 00	 mov	 esi, 4
  001f8	d1 e6		 shl	 esi, 1
  001fa	f3 0f 10 04 01	 movss	 xmm0, DWORD PTR [ecx+eax]
  001ff	0f 2f 04 32	 comiss	 xmm0, DWORD PTR [edx+esi]
  00203	0f 82 5d 01 00
	00		 jb	 $LN4@glm_mat3_q

; 274  :     r       = sqrtf(1.0f - m[1][1] - m[2][2] + m[0][0]);

  00209	b8 0c 00 00 00	 mov	 eax, 12			; 0000000cH
  0020e	c1 e0 00	 shl	 eax, 0
  00211	03 45 08	 add	 eax, DWORD PTR _m$[ebp]
  00214	b9 04 00 00 00	 mov	 ecx, 4
  00219	c1 e1 00	 shl	 ecx, 0
  0021c	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00224	f3 0f 5c 04 08	 subss	 xmm0, DWORD PTR [eax+ecx]
  00229	ba 0c 00 00 00	 mov	 edx, 12			; 0000000cH
  0022e	d1 e2		 shl	 edx, 1
  00230	03 55 08	 add	 edx, DWORD PTR _m$[ebp]
  00233	b8 04 00 00 00	 mov	 eax, 4
  00238	d1 e0		 shl	 eax, 1
  0023a	f3 0f 5c 04 02	 subss	 xmm0, DWORD PTR [edx+eax]
  0023f	b9 0c 00 00 00	 mov	 ecx, 12			; 0000000cH
  00244	6b d1 00	 imul	 edx, ecx, 0
  00247	03 55 08	 add	 edx, DWORD PTR _m$[ebp]
  0024a	b8 04 00 00 00	 mov	 eax, 4
  0024f	6b c8 00	 imul	 ecx, eax, 0
  00252	f3 0f 58 04 0a	 addss	 xmm0, DWORD PTR [edx+ecx]
  00257	51		 push	 ecx
  00258	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0025d	e8 00 00 00 00	 call	 _sqrtf
  00262	83 c4 04	 add	 esp, 4
  00265	d9 5d ec	 fstp	 DWORD PTR _r$[ebp]

; 275  :     rinv    = 0.5f / r;

  00268	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f000000
  00270	f3 0f 5e 45 ec	 divss	 xmm0, DWORD PTR _r$[ebp]
  00275	f3 0f 11 45 e0	 movss	 DWORD PTR _rinv$[ebp], xmm0

; 276  : 
; 277  :     dest[0] = r    * 0.5f;

  0027a	f3 0f 10 45 ec	 movss	 xmm0, DWORD PTR _r$[ebp]
  0027f	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@3f000000
  00287	b8 04 00 00 00	 mov	 eax, 4
  0028c	6b c8 00	 imul	 ecx, eax, 0
  0028f	8b 55 0c	 mov	 edx, DWORD PTR _dest$[ebp]
  00292	f3 0f 11 04 0a	 movss	 DWORD PTR [edx+ecx], xmm0

; 278  :     dest[1] = rinv * (m[0][1] + m[1][0]);

  00297	b8 0c 00 00 00	 mov	 eax, 12			; 0000000cH
  0029c	6b c8 00	 imul	 ecx, eax, 0
  0029f	03 4d 08	 add	 ecx, DWORD PTR _m$[ebp]
  002a2	ba 04 00 00 00	 mov	 edx, 4
  002a7	c1 e2 00	 shl	 edx, 0
  002aa	b8 0c 00 00 00	 mov	 eax, 12			; 0000000cH
  002af	c1 e0 00	 shl	 eax, 0
  002b2	03 45 08	 add	 eax, DWORD PTR _m$[ebp]
  002b5	be 04 00 00 00	 mov	 esi, 4
  002ba	6b f6 00	 imul	 esi, esi, 0
  002bd	f3 0f 10 04 11	 movss	 xmm0, DWORD PTR [ecx+edx]
  002c2	f3 0f 58 04 30	 addss	 xmm0, DWORD PTR [eax+esi]
  002c7	f3 0f 59 45 e0	 mulss	 xmm0, DWORD PTR _rinv$[ebp]
  002cc	b9 04 00 00 00	 mov	 ecx, 4
  002d1	c1 e1 00	 shl	 ecx, 0
  002d4	8b 55 0c	 mov	 edx, DWORD PTR _dest$[ebp]
  002d7	f3 0f 11 04 0a	 movss	 DWORD PTR [edx+ecx], xmm0

; 279  :     dest[2] = rinv * (m[0][2] + m[2][0]);

  002dc	b8 0c 00 00 00	 mov	 eax, 12			; 0000000cH
  002e1	6b c8 00	 imul	 ecx, eax, 0
  002e4	03 4d 08	 add	 ecx, DWORD PTR _m$[ebp]
  002e7	ba 04 00 00 00	 mov	 edx, 4
  002ec	d1 e2		 shl	 edx, 1
  002ee	b8 0c 00 00 00	 mov	 eax, 12			; 0000000cH
  002f3	d1 e0		 shl	 eax, 1
  002f5	03 45 08	 add	 eax, DWORD PTR _m$[ebp]
  002f8	be 04 00 00 00	 mov	 esi, 4
  002fd	6b f6 00	 imul	 esi, esi, 0
  00300	f3 0f 10 04 11	 movss	 xmm0, DWORD PTR [ecx+edx]
  00305	f3 0f 58 04 30	 addss	 xmm0, DWORD PTR [eax+esi]
  0030a	f3 0f 59 45 e0	 mulss	 xmm0, DWORD PTR _rinv$[ebp]
  0030f	b9 04 00 00 00	 mov	 ecx, 4
  00314	d1 e1		 shl	 ecx, 1
  00316	8b 55 0c	 mov	 edx, DWORD PTR _dest$[ebp]
  00319	f3 0f 11 04 0a	 movss	 DWORD PTR [edx+ecx], xmm0

; 280  :     dest[3] = rinv * (m[1][2] - m[2][1]);

  0031e	b8 0c 00 00 00	 mov	 eax, 12			; 0000000cH
  00323	c1 e0 00	 shl	 eax, 0
  00326	03 45 08	 add	 eax, DWORD PTR _m$[ebp]
  00329	b9 04 00 00 00	 mov	 ecx, 4
  0032e	d1 e1		 shl	 ecx, 1
  00330	ba 0c 00 00 00	 mov	 edx, 12			; 0000000cH
  00335	d1 e2		 shl	 edx, 1
  00337	03 55 08	 add	 edx, DWORD PTR _m$[ebp]
  0033a	be 04 00 00 00	 mov	 esi, 4
  0033f	c1 e6 00	 shl	 esi, 0
  00342	f3 0f 10 04 08	 movss	 xmm0, DWORD PTR [eax+ecx]
  00347	f3 0f 5c 04 32	 subss	 xmm0, DWORD PTR [edx+esi]
  0034c	f3 0f 59 45 e0	 mulss	 xmm0, DWORD PTR _rinv$[ebp]
  00351	b8 04 00 00 00	 mov	 eax, 4
  00356	6b c8 03	 imul	 ecx, eax, 3
  00359	8b 55 0c	 mov	 edx, DWORD PTR _dest$[ebp]
  0035c	f3 0f 11 04 0a	 movss	 DWORD PTR [edx+ecx], xmm0
  00361	e9 e8 02 00 00	 jmp	 $LN7@glm_mat3_q
$LN4@glm_mat3_q:

; 281  :   } else if (m[1][1] >= m[2][2]) {

  00366	b8 0c 00 00 00	 mov	 eax, 12			; 0000000cH
  0036b	c1 e0 00	 shl	 eax, 0
  0036e	03 45 08	 add	 eax, DWORD PTR _m$[ebp]
  00371	b9 04 00 00 00	 mov	 ecx, 4
  00376	c1 e1 00	 shl	 ecx, 0
  00379	ba 0c 00 00 00	 mov	 edx, 12			; 0000000cH
  0037e	d1 e2		 shl	 edx, 1
  00380	03 55 08	 add	 edx, DWORD PTR _m$[ebp]
  00383	be 04 00 00 00	 mov	 esi, 4
  00388	d1 e6		 shl	 esi, 1
  0038a	f3 0f 10 04 08	 movss	 xmm0, DWORD PTR [eax+ecx]
  0038f	0f 2f 04 32	 comiss	 xmm0, DWORD PTR [edx+esi]
  00393	0f 82 5d 01 00
	00		 jb	 $LN6@glm_mat3_q

; 282  :     r       = sqrtf(1.0f - m[0][0] - m[2][2] + m[1][1]);

  00399	b8 0c 00 00 00	 mov	 eax, 12			; 0000000cH
  0039e	6b c8 00	 imul	 ecx, eax, 0
  003a1	03 4d 08	 add	 ecx, DWORD PTR _m$[ebp]
  003a4	ba 04 00 00 00	 mov	 edx, 4
  003a9	6b c2 00	 imul	 eax, edx, 0
  003ac	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  003b4	f3 0f 5c 04 01	 subss	 xmm0, DWORD PTR [ecx+eax]
  003b9	b9 0c 00 00 00	 mov	 ecx, 12			; 0000000cH
  003be	d1 e1		 shl	 ecx, 1
  003c0	03 4d 08	 add	 ecx, DWORD PTR _m$[ebp]
  003c3	ba 04 00 00 00	 mov	 edx, 4
  003c8	d1 e2		 shl	 edx, 1
  003ca	f3 0f 5c 04 11	 subss	 xmm0, DWORD PTR [ecx+edx]
  003cf	b8 0c 00 00 00	 mov	 eax, 12			; 0000000cH
  003d4	c1 e0 00	 shl	 eax, 0
  003d7	03 45 08	 add	 eax, DWORD PTR _m$[ebp]
  003da	b9 04 00 00 00	 mov	 ecx, 4
  003df	c1 e1 00	 shl	 ecx, 0
  003e2	f3 0f 58 04 08	 addss	 xmm0, DWORD PTR [eax+ecx]
  003e7	51		 push	 ecx
  003e8	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  003ed	e8 00 00 00 00	 call	 _sqrtf
  003f2	83 c4 04	 add	 esp, 4
  003f5	d9 5d ec	 fstp	 DWORD PTR _r$[ebp]

; 283  :     rinv    = 0.5f / r;

  003f8	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f000000
  00400	f3 0f 5e 45 ec	 divss	 xmm0, DWORD PTR _r$[ebp]
  00405	f3 0f 11 45 e0	 movss	 DWORD PTR _rinv$[ebp], xmm0

; 284  : 
; 285  :     dest[0] = rinv * (m[0][1] + m[1][0]);

  0040a	b8 0c 00 00 00	 mov	 eax, 12			; 0000000cH
  0040f	6b c8 00	 imul	 ecx, eax, 0
  00412	03 4d 08	 add	 ecx, DWORD PTR _m$[ebp]
  00415	ba 04 00 00 00	 mov	 edx, 4
  0041a	c1 e2 00	 shl	 edx, 0
  0041d	b8 0c 00 00 00	 mov	 eax, 12			; 0000000cH
  00422	c1 e0 00	 shl	 eax, 0
  00425	03 45 08	 add	 eax, DWORD PTR _m$[ebp]
  00428	be 04 00 00 00	 mov	 esi, 4
  0042d	6b f6 00	 imul	 esi, esi, 0
  00430	f3 0f 10 04 11	 movss	 xmm0, DWORD PTR [ecx+edx]
  00435	f3 0f 58 04 30	 addss	 xmm0, DWORD PTR [eax+esi]
  0043a	f3 0f 59 45 e0	 mulss	 xmm0, DWORD PTR _rinv$[ebp]
  0043f	b9 04 00 00 00	 mov	 ecx, 4
  00444	6b d1 00	 imul	 edx, ecx, 0
  00447	8b 45 0c	 mov	 eax, DWORD PTR _dest$[ebp]
  0044a	f3 0f 11 04 10	 movss	 DWORD PTR [eax+edx], xmm0

; 286  :     dest[1] = r    * 0.5f;

  0044f	f3 0f 10 45 ec	 movss	 xmm0, DWORD PTR _r$[ebp]
  00454	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@3f000000
  0045c	b8 04 00 00 00	 mov	 eax, 4
  00461	c1 e0 00	 shl	 eax, 0
  00464	8b 4d 0c	 mov	 ecx, DWORD PTR _dest$[ebp]
  00467	f3 0f 11 04 01	 movss	 DWORD PTR [ecx+eax], xmm0

; 287  :     dest[2] = rinv * (m[1][2] + m[2][1]);

  0046c	b8 0c 00 00 00	 mov	 eax, 12			; 0000000cH
  00471	c1 e0 00	 shl	 eax, 0
  00474	03 45 08	 add	 eax, DWORD PTR _m$[ebp]
  00477	b9 04 00 00 00	 mov	 ecx, 4
  0047c	d1 e1		 shl	 ecx, 1
  0047e	ba 0c 00 00 00	 mov	 edx, 12			; 0000000cH
  00483	d1 e2		 shl	 edx, 1
  00485	03 55 08	 add	 edx, DWORD PTR _m$[ebp]
  00488	be 04 00 00 00	 mov	 esi, 4
  0048d	c1 e6 00	 shl	 esi, 0
  00490	f3 0f 10 04 08	 movss	 xmm0, DWORD PTR [eax+ecx]
  00495	f3 0f 58 04 32	 addss	 xmm0, DWORD PTR [edx+esi]
  0049a	f3 0f 59 45 e0	 mulss	 xmm0, DWORD PTR _rinv$[ebp]
  0049f	b8 04 00 00 00	 mov	 eax, 4
  004a4	d1 e0		 shl	 eax, 1
  004a6	8b 4d 0c	 mov	 ecx, DWORD PTR _dest$[ebp]
  004a9	f3 0f 11 04 01	 movss	 DWORD PTR [ecx+eax], xmm0

; 288  :     dest[3] = rinv * (m[2][0] - m[0][2]);

  004ae	b8 0c 00 00 00	 mov	 eax, 12			; 0000000cH
  004b3	d1 e0		 shl	 eax, 1
  004b5	03 45 08	 add	 eax, DWORD PTR _m$[ebp]
  004b8	b9 04 00 00 00	 mov	 ecx, 4
  004bd	6b d1 00	 imul	 edx, ecx, 0
  004c0	b9 0c 00 00 00	 mov	 ecx, 12			; 0000000cH
  004c5	6b c9 00	 imul	 ecx, ecx, 0
  004c8	03 4d 08	 add	 ecx, DWORD PTR _m$[ebp]
  004cb	be 04 00 00 00	 mov	 esi, 4
  004d0	d1 e6		 shl	 esi, 1
  004d2	f3 0f 10 04 10	 movss	 xmm0, DWORD PTR [eax+edx]
  004d7	f3 0f 5c 04 31	 subss	 xmm0, DWORD PTR [ecx+esi]
  004dc	f3 0f 59 45 e0	 mulss	 xmm0, DWORD PTR _rinv$[ebp]
  004e1	ba 04 00 00 00	 mov	 edx, 4
  004e6	6b c2 03	 imul	 eax, edx, 3
  004e9	8b 4d 0c	 mov	 ecx, DWORD PTR _dest$[ebp]
  004ec	f3 0f 11 04 01	 movss	 DWORD PTR [ecx+eax], xmm0

; 289  :   } else {

  004f1	e9 58 01 00 00	 jmp	 $LN7@glm_mat3_q
$LN6@glm_mat3_q:

; 290  :     r       = sqrtf(1.0f - m[0][0] - m[1][1] + m[2][2]);

  004f6	b8 0c 00 00 00	 mov	 eax, 12			; 0000000cH
  004fb	6b c8 00	 imul	 ecx, eax, 0
  004fe	03 4d 08	 add	 ecx, DWORD PTR _m$[ebp]
  00501	ba 04 00 00 00	 mov	 edx, 4
  00506	6b c2 00	 imul	 eax, edx, 0
  00509	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00511	f3 0f 5c 04 01	 subss	 xmm0, DWORD PTR [ecx+eax]
  00516	b9 0c 00 00 00	 mov	 ecx, 12			; 0000000cH
  0051b	c1 e1 00	 shl	 ecx, 0
  0051e	03 4d 08	 add	 ecx, DWORD PTR _m$[ebp]
  00521	ba 04 00 00 00	 mov	 edx, 4
  00526	c1 e2 00	 shl	 edx, 0
  00529	f3 0f 5c 04 11	 subss	 xmm0, DWORD PTR [ecx+edx]
  0052e	b8 0c 00 00 00	 mov	 eax, 12			; 0000000cH
  00533	d1 e0		 shl	 eax, 1
  00535	03 45 08	 add	 eax, DWORD PTR _m$[ebp]
  00538	b9 04 00 00 00	 mov	 ecx, 4
  0053d	d1 e1		 shl	 ecx, 1
  0053f	f3 0f 58 04 08	 addss	 xmm0, DWORD PTR [eax+ecx]
  00544	51		 push	 ecx
  00545	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0054a	e8 00 00 00 00	 call	 _sqrtf
  0054f	83 c4 04	 add	 esp, 4
  00552	d9 5d ec	 fstp	 DWORD PTR _r$[ebp]

; 291  :     rinv    = 0.5f / r;

  00555	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f000000
  0055d	f3 0f 5e 45 ec	 divss	 xmm0, DWORD PTR _r$[ebp]
  00562	f3 0f 11 45 e0	 movss	 DWORD PTR _rinv$[ebp], xmm0

; 292  : 
; 293  :     dest[0] = rinv * (m[0][2] + m[2][0]);

  00567	b8 0c 00 00 00	 mov	 eax, 12			; 0000000cH
  0056c	6b c8 00	 imul	 ecx, eax, 0
  0056f	03 4d 08	 add	 ecx, DWORD PTR _m$[ebp]
  00572	ba 04 00 00 00	 mov	 edx, 4
  00577	d1 e2		 shl	 edx, 1
  00579	b8 0c 00 00 00	 mov	 eax, 12			; 0000000cH
  0057e	d1 e0		 shl	 eax, 1
  00580	03 45 08	 add	 eax, DWORD PTR _m$[ebp]
  00583	be 04 00 00 00	 mov	 esi, 4
  00588	6b f6 00	 imul	 esi, esi, 0
  0058b	f3 0f 10 04 11	 movss	 xmm0, DWORD PTR [ecx+edx]
  00590	f3 0f 58 04 30	 addss	 xmm0, DWORD PTR [eax+esi]
  00595	f3 0f 59 45 e0	 mulss	 xmm0, DWORD PTR _rinv$[ebp]
  0059a	b9 04 00 00 00	 mov	 ecx, 4
  0059f	6b d1 00	 imul	 edx, ecx, 0
  005a2	8b 45 0c	 mov	 eax, DWORD PTR _dest$[ebp]
  005a5	f3 0f 11 04 10	 movss	 DWORD PTR [eax+edx], xmm0

; 294  :     dest[1] = rinv * (m[1][2] + m[2][1]);

  005aa	b8 0c 00 00 00	 mov	 eax, 12			; 0000000cH
  005af	c1 e0 00	 shl	 eax, 0
  005b2	03 45 08	 add	 eax, DWORD PTR _m$[ebp]
  005b5	b9 04 00 00 00	 mov	 ecx, 4
  005ba	d1 e1		 shl	 ecx, 1
  005bc	ba 0c 00 00 00	 mov	 edx, 12			; 0000000cH
  005c1	d1 e2		 shl	 edx, 1
  005c3	03 55 08	 add	 edx, DWORD PTR _m$[ebp]
  005c6	be 04 00 00 00	 mov	 esi, 4
  005cb	c1 e6 00	 shl	 esi, 0
  005ce	f3 0f 10 04 08	 movss	 xmm0, DWORD PTR [eax+ecx]
  005d3	f3 0f 58 04 32	 addss	 xmm0, DWORD PTR [edx+esi]
  005d8	f3 0f 59 45 e0	 mulss	 xmm0, DWORD PTR _rinv$[ebp]
  005dd	b8 04 00 00 00	 mov	 eax, 4
  005e2	c1 e0 00	 shl	 eax, 0
  005e5	8b 4d 0c	 mov	 ecx, DWORD PTR _dest$[ebp]
  005e8	f3 0f 11 04 01	 movss	 DWORD PTR [ecx+eax], xmm0

; 295  :     dest[2] = r    * 0.5f;

  005ed	f3 0f 10 45 ec	 movss	 xmm0, DWORD PTR _r$[ebp]
  005f2	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@3f000000
  005fa	b8 04 00 00 00	 mov	 eax, 4
  005ff	d1 e0		 shl	 eax, 1
  00601	8b 4d 0c	 mov	 ecx, DWORD PTR _dest$[ebp]
  00604	f3 0f 11 04 01	 movss	 DWORD PTR [ecx+eax], xmm0

; 296  :     dest[3] = rinv * (m[0][1] - m[1][0]);

  00609	b8 0c 00 00 00	 mov	 eax, 12			; 0000000cH
  0060e	6b c8 00	 imul	 ecx, eax, 0
  00611	03 4d 08	 add	 ecx, DWORD PTR _m$[ebp]
  00614	ba 04 00 00 00	 mov	 edx, 4
  00619	c1 e2 00	 shl	 edx, 0
  0061c	b8 0c 00 00 00	 mov	 eax, 12			; 0000000cH
  00621	c1 e0 00	 shl	 eax, 0
  00624	03 45 08	 add	 eax, DWORD PTR _m$[ebp]
  00627	be 04 00 00 00	 mov	 esi, 4
  0062c	6b f6 00	 imul	 esi, esi, 0
  0062f	f3 0f 10 04 11	 movss	 xmm0, DWORD PTR [ecx+edx]
  00634	f3 0f 5c 04 30	 subss	 xmm0, DWORD PTR [eax+esi]
  00639	f3 0f 59 45 e0	 mulss	 xmm0, DWORD PTR _rinv$[ebp]
  0063e	b9 04 00 00 00	 mov	 ecx, 4
  00643	6b d1 03	 imul	 edx, ecx, 3
  00646	8b 45 0c	 mov	 eax, DWORD PTR _dest$[ebp]
  00649	f3 0f 11 04 10	 movss	 DWORD PTR [eax+edx], xmm0
$LN7@glm_mat3_q:

; 297  :   }
; 298  : }

  0064e	5f		 pop	 edi
  0064f	5e		 pop	 esi
  00650	5b		 pop	 ebx
  00651	81 c4 e4 00 00
	00		 add	 esp, 228		; 000000e4H
  00657	3b ec		 cmp	 ebp, esp
  00659	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0065e	8b e5		 mov	 esp, ebp
  00660	5d		 pop	 ebp
  00661	c3		 ret	 0
_glm_mat3_quat ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Light\source\repos\3DRendC\include\mat4.h
;	COMDAT _glm_mat4_mulv3
_TEXT	SEGMENT
_res$ = -32						; size = 16
__$ArrayPad$ = -4					; size = 4
_m$ = 8							; size = 4
_v$ = 12						; size = 4
_last$ = 16						; size = 4
_dest$ = 20						; size = 4
_glm_mat4_mulv3 PROC					; COMDAT

; 461  : glm_mat4_mulv3(mat4 m, vec3 v, float last, vec3 dest) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 f0	 and	 esp, -16		; fffffff0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec e8 00 00
	00		 sub	 esp, 232		; 000000e8H
  0001c	56		 push	 esi
  0001d	57		 push	 edi
  0001e	8d bd 18 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-232]
  00024	b9 3a 00 00 00	 mov	 ecx, 58			; 0000003aH
  00029	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002e	f3 ab		 rep stosd
  00030	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00035	33 c5		 xor	 eax, ebp
  00037	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0003a	b9 00 00 00 00	 mov	 ecx, OFFSET __D6E4440C_mat4@h
  0003f	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 462  :   vec4 res;
; 463  :   glm_vec4(v, last, res);

  00044	8d 45 e0	 lea	 eax, DWORD PTR _res$[ebp]
  00047	50		 push	 eax
  00048	51		 push	 ecx
  00049	f3 0f 10 43 10	 movss	 xmm0, DWORD PTR _last$[ebx]
  0004e	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00053	8b 4b 0c	 mov	 ecx, DWORD PTR _v$[ebx]
  00056	51		 push	 ecx
  00057	e8 00 00 00 00	 call	 _glm_vec4
  0005c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 464  :   glm_mat4_mulv(m, res, res);

  0005f	8d 45 e0	 lea	 eax, DWORD PTR _res$[ebp]
  00062	50		 push	 eax
  00063	8d 4d e0	 lea	 ecx, DWORD PTR _res$[ebp]
  00066	51		 push	 ecx
  00067	8b 53 08	 mov	 edx, DWORD PTR _m$[ebx]
  0006a	52		 push	 edx
  0006b	e8 00 00 00 00	 call	 _glm_mat4_mulv
  00070	83 c4 0c	 add	 esp, 12			; 0000000cH

; 465  :   glm_vec3(res, dest);

  00073	8b 43 14	 mov	 eax, DWORD PTR _dest$[ebx]
  00076	50		 push	 eax
  00077	8d 4d e0	 lea	 ecx, DWORD PTR _res$[ebp]
  0007a	51		 push	 ecx
  0007b	e8 00 00 00 00	 call	 _glm_vec3
  00080	83 c4 08	 add	 esp, 8

; 466  : }

  00083	52		 push	 edx
  00084	8b cd		 mov	 ecx, ebp
  00086	50		 push	 eax
  00087	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN5@glm_mat4_m
  0008d	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00092	58		 pop	 eax
  00093	5a		 pop	 edx
  00094	5f		 pop	 edi
  00095	5e		 pop	 esi
  00096	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00099	33 cd		 xor	 ecx, ebp
  0009b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000a0	8b e5		 mov	 esp, ebp
  000a2	5d		 pop	 ebp
  000a3	8b e3		 mov	 esp, ebx
  000a5	5b		 pop	 ebx
  000a6	c3		 ret	 0
  000a7	90		 npad	 1
$LN5@glm_mat4_m:
  000a8	01 00 00 00	 DD	 1
  000ac	00 00 00 00	 DD	 $LN4@glm_mat4_m
$LN4@glm_mat4_m:
  000b0	e0 ff ff ff	 DD	 -32			; ffffffe0H
  000b4	10 00 00 00	 DD	 16			; 00000010H
  000b8	00 00 00 00	 DD	 $LN3@glm_mat4_m
$LN3@glm_mat4_m:
  000bc	72		 DB	 114			; 00000072H
  000bd	65		 DB	 101			; 00000065H
  000be	73		 DB	 115			; 00000073H
  000bf	00		 DB	 0
_glm_mat4_mulv3 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Light\source\repos\3DRendC\include\mat4.h
;	COMDAT _glm_mat4_mulv
_TEXT	SEGMENT
_m$ = 8							; size = 4
_v$ = 12						; size = 4
_dest$ = 16						; size = 4
_glm_mat4_mulv PROC					; COMDAT

; 358  : glm_mat4_mulv(mat4 m, vec4 v, vec4 dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __D6E4440C_mat4@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 359  : #if defined( __SSE__ ) || defined( __SSE2__ )
; 360  :   glm_mat4_mulv_sse2(m, v, dest);

  00028	8b 45 10	 mov	 eax, DWORD PTR _dest$[ebp]
  0002b	50		 push	 eax
  0002c	8b 4d 0c	 mov	 ecx, DWORD PTR _v$[ebp]
  0002f	51		 push	 ecx
  00030	8b 55 08	 mov	 edx, DWORD PTR _m$[ebp]
  00033	52		 push	 edx
  00034	e8 00 00 00 00	 call	 _glm_mat4_mulv_sse2
  00039	83 c4 0c	 add	 esp, 12			; 0000000cH

; 361  : #elif defined(CGLM_NEON_FP)
; 362  :   glm_mat4_mulv_neon(m, v, dest);
; 363  : #else
; 364  :   vec4 res;
; 365  :   res[0] = m[0][0] * v[0] + m[1][0] * v[1] + m[2][0] * v[2] + m[3][0] * v[3];
; 366  :   res[1] = m[0][1] * v[0] + m[1][1] * v[1] + m[2][1] * v[2] + m[3][1] * v[3];
; 367  :   res[2] = m[0][2] * v[0] + m[1][2] * v[1] + m[2][2] * v[2] + m[3][2] * v[3];
; 368  :   res[3] = m[0][3] * v[0] + m[1][3] * v[1] + m[2][3] * v[2] + m[3][3] * v[3];
; 369  :   glm_vec4_copy(res, dest);
; 370  : #endif
; 371  : }

  0003c	5f		 pop	 edi
  0003d	5e		 pop	 esi
  0003e	5b		 pop	 ebx
  0003f	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00045	3b ec		 cmp	 ebp, esp
  00047	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004c	8b e5		 mov	 esp, ebp
  0004e	5d		 pop	 ebp
  0004f	c3		 ret	 0
_glm_mat4_mulv ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Light\source\repos\3DRendC\include\mat4.h
;	COMDAT _glm_mat4_identity
_TEXT	SEGMENT
_t$ = -80						; size = 64
__$ArrayPad$ = -4					; size = 4
_mat$ = 8						; size = 4
_glm_mat4_identity PROC					; COMDAT

; 158  : glm_mat4_identity(mat4 mat) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 f0	 and	 esp, -16		; fffffff0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec 18 01 00
	00		 sub	 esp, 280		; 00000118H
  0001c	56		 push	 esi
  0001d	57		 push	 edi
  0001e	8d bd e8 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-280]
  00024	b9 46 00 00 00	 mov	 ecx, 70			; 00000046H
  00029	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002e	f3 ab		 rep stosd
  00030	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00035	33 c5		 xor	 eax, ebp
  00037	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0003a	b9 00 00 00 00	 mov	 ecx, OFFSET __D6E4440C_mat4@h
  0003f	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 159  :   CGLM_ALIGN_MAT mat4 t = GLM_MAT4_IDENTITY_INIT;

  00044	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  0004c	f3 0f 11 45 b0	 movss	 DWORD PTR _t$[ebp], xmm0
  00051	0f 57 c0	 xorps	 xmm0, xmm0
  00054	f3 0f 11 45 b4	 movss	 DWORD PTR _t$[ebp+4], xmm0
  00059	0f 57 c0	 xorps	 xmm0, xmm0
  0005c	f3 0f 11 45 b8	 movss	 DWORD PTR _t$[ebp+8], xmm0
  00061	0f 57 c0	 xorps	 xmm0, xmm0
  00064	f3 0f 11 45 bc	 movss	 DWORD PTR _t$[ebp+12], xmm0
  00069	0f 57 c0	 xorps	 xmm0, xmm0
  0006c	f3 0f 11 45 c0	 movss	 DWORD PTR _t$[ebp+16], xmm0
  00071	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00079	f3 0f 11 45 c4	 movss	 DWORD PTR _t$[ebp+20], xmm0
  0007e	0f 57 c0	 xorps	 xmm0, xmm0
  00081	f3 0f 11 45 c8	 movss	 DWORD PTR _t$[ebp+24], xmm0
  00086	0f 57 c0	 xorps	 xmm0, xmm0
  00089	f3 0f 11 45 cc	 movss	 DWORD PTR _t$[ebp+28], xmm0
  0008e	0f 57 c0	 xorps	 xmm0, xmm0
  00091	f3 0f 11 45 d0	 movss	 DWORD PTR _t$[ebp+32], xmm0
  00096	0f 57 c0	 xorps	 xmm0, xmm0
  00099	f3 0f 11 45 d4	 movss	 DWORD PTR _t$[ebp+36], xmm0
  0009e	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  000a6	f3 0f 11 45 d8	 movss	 DWORD PTR _t$[ebp+40], xmm0
  000ab	0f 57 c0	 xorps	 xmm0, xmm0
  000ae	f3 0f 11 45 dc	 movss	 DWORD PTR _t$[ebp+44], xmm0
  000b3	0f 57 c0	 xorps	 xmm0, xmm0
  000b6	f3 0f 11 45 e0	 movss	 DWORD PTR _t$[ebp+48], xmm0
  000bb	0f 57 c0	 xorps	 xmm0, xmm0
  000be	f3 0f 11 45 e4	 movss	 DWORD PTR _t$[ebp+52], xmm0
  000c3	0f 57 c0	 xorps	 xmm0, xmm0
  000c6	f3 0f 11 45 e8	 movss	 DWORD PTR _t$[ebp+56], xmm0
  000cb	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  000d3	f3 0f 11 45 ec	 movss	 DWORD PTR _t$[ebp+60], xmm0

; 160  :   glm_mat4_copy(t, mat);

  000d8	8b 43 08	 mov	 eax, DWORD PTR _mat$[ebx]
  000db	50		 push	 eax
  000dc	8d 4d b0	 lea	 ecx, DWORD PTR _t$[ebp]
  000df	51		 push	 ecx
  000e0	e8 00 00 00 00	 call	 _glm_mat4_copy
  000e5	83 c4 08	 add	 esp, 8

; 161  : }

  000e8	52		 push	 edx
  000e9	8b cd		 mov	 ecx, ebp
  000eb	50		 push	 eax
  000ec	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN5@glm_mat4_i
  000f2	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  000f7	58		 pop	 eax
  000f8	5a		 pop	 edx
  000f9	5f		 pop	 edi
  000fa	5e		 pop	 esi
  000fb	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000fe	33 cd		 xor	 ecx, ebp
  00100	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00105	8b e5		 mov	 esp, ebp
  00107	5d		 pop	 ebp
  00108	8b e3		 mov	 esp, ebx
  0010a	5b		 pop	 ebx
  0010b	c3		 ret	 0
$LN5@glm_mat4_i:
  0010c	01 00 00 00	 DD	 1
  00110	00 00 00 00	 DD	 $LN4@glm_mat4_i
$LN4@glm_mat4_i:
  00114	b0 ff ff ff	 DD	 -80			; ffffffb0H
  00118	40 00 00 00	 DD	 64			; 00000040H
  0011c	00 00 00 00	 DD	 $LN3@glm_mat4_i
$LN3@glm_mat4_i:
  00120	74		 DB	 116			; 00000074H
  00121	00		 DB	 0
_glm_mat4_identity ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Light\source\repos\3DRendC\include\mat4.h
;	COMDAT _glm_mat4_copy
_TEXT	SEGMENT
_mat$ = 8						; size = 4
_dest$ = 12						; size = 4
_glm_mat4_copy PROC					; COMDAT

; 123  : glm_mat4_copy(mat4 mat, mat4 dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __D6E4440C_mat4@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 124  : #ifdef __AVX__
; 125  :   glmm_store256(dest[0], glmm_load256(mat[0]));
; 126  :   glmm_store256(dest[2], glmm_load256(mat[2]));
; 127  : #elif defined( __SSE__ ) || defined( __SSE2__ )
; 128  :   glmm_store(dest[0], glmm_load(mat[0]));

  00028	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  0002d	6b c8 00	 imul	 ecx, eax, 0
  00030	03 4d 08	 add	 ecx, DWORD PTR _mat$[ebp]
  00033	0f 10 01	 movups	 xmm0, XMMWORD PTR [ecx]
  00036	ba 10 00 00 00	 mov	 edx, 16			; 00000010H
  0003b	6b c2 00	 imul	 eax, edx, 0
  0003e	03 45 0c	 add	 eax, DWORD PTR _dest$[ebp]
  00041	0f 11 00	 movups	 XMMWORD PTR [eax], xmm0

; 129  :   glmm_store(dest[1], glmm_load(mat[1]));

  00044	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  00049	c1 e0 00	 shl	 eax, 0
  0004c	03 45 08	 add	 eax, DWORD PTR _mat$[ebp]
  0004f	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  00052	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  00057	c1 e1 00	 shl	 ecx, 0
  0005a	03 4d 0c	 add	 ecx, DWORD PTR _dest$[ebp]
  0005d	0f 11 01	 movups	 XMMWORD PTR [ecx], xmm0

; 130  :   glmm_store(dest[2], glmm_load(mat[2]));

  00060	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  00065	d1 e0		 shl	 eax, 1
  00067	03 45 08	 add	 eax, DWORD PTR _mat$[ebp]
  0006a	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  0006d	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  00072	d1 e1		 shl	 ecx, 1
  00074	03 4d 0c	 add	 ecx, DWORD PTR _dest$[ebp]
  00077	0f 11 01	 movups	 XMMWORD PTR [ecx], xmm0

; 131  :   glmm_store(dest[3], glmm_load(mat[3]));

  0007a	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  0007f	6b c8 03	 imul	 ecx, eax, 3
  00082	03 4d 08	 add	 ecx, DWORD PTR _mat$[ebp]
  00085	0f 10 01	 movups	 xmm0, XMMWORD PTR [ecx]
  00088	ba 10 00 00 00	 mov	 edx, 16			; 00000010H
  0008d	6b c2 03	 imul	 eax, edx, 3
  00090	03 45 0c	 add	 eax, DWORD PTR _dest$[ebp]
  00093	0f 11 00	 movups	 XMMWORD PTR [eax], xmm0

; 132  : #elif defined(CGLM_NEON_FP)
; 133  :   vst1q_f32(dest[0], vld1q_f32(mat[0]));
; 134  :   vst1q_f32(dest[1], vld1q_f32(mat[1]));
; 135  :   vst1q_f32(dest[2], vld1q_f32(mat[2]));
; 136  :   vst1q_f32(dest[3], vld1q_f32(mat[3]));
; 137  : #else
; 138  :   glm_mat4_ucopy(mat, dest);
; 139  : #endif
; 140  : }

  00096	5f		 pop	 edi
  00097	5e		 pop	 esi
  00098	5b		 pop	 ebx
  00099	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0009f	3b ec		 cmp	 ebp, esp
  000a1	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000a6	8b e5		 mov	 esp, ebp
  000a8	5d		 pop	 ebp
  000a9	c3		 ret	 0
_glm_mat4_copy ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Light\source\repos\3DRendC\include\simd\sse2\mat4.h
;	COMDAT _glm_mat4_mulv_sse2
_TEXT	SEGMENT
_x2$ = -96						; size = 16
_x1$ = -64						; size = 16
_x0$ = -32						; size = 16
_m$ = 8							; size = 4
_v$ = 12						; size = 4
_dest$ = 16						; size = 4
_glm_mat4_mulv_sse2 PROC				; COMDAT

; 88   : glm_mat4_mulv_sse2(mat4 m, vec4 v, vec4 dest) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 f0	 and	 esp, -16		; fffffff0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec 28 01 00
	00		 sub	 esp, 296		; 00000128H
  0001c	56		 push	 esi
  0001d	57		 push	 edi
  0001e	8d bd d8 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-296]
  00024	b9 4a 00 00 00	 mov	 ecx, 74			; 0000004aH
  00029	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002e	f3 ab		 rep stosd
  00030	b9 00 00 00 00	 mov	 ecx, OFFSET __6C51F661_mat4@h
  00035	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 89   :   __m128 x0, x1, x2;
; 90   : 
; 91   :   x0 = glmm_load(v);

  0003a	8b 43 0c	 mov	 eax, DWORD PTR _v$[ebx]
  0003d	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  00040	0f 29 45 e0	 movaps	 XMMWORD PTR _x0$[ebp], xmm0

; 92   :   x1 = _mm_add_ps(_mm_mul_ps(glmm_load(m[0]), glmm_shuff1x(x0, 0)),

  00044	0f 28 45 e0	 movaps	 xmm0, XMMWORD PTR _x0$[ebp]
  00048	0f c6 45 e0 55	 shufps	 xmm0, XMMWORD PTR _x0$[ebp], 85 ; 00000055H
  0004d	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  00052	c1 e0 00	 shl	 eax, 0
  00055	03 43 08	 add	 eax, DWORD PTR _m$[ebx]
  00058	0f 10 08	 movups	 xmm1, XMMWORD PTR [eax]
  0005b	0f 59 c8	 mulps	 xmm1, xmm0
  0005e	0f 28 45 e0	 movaps	 xmm0, XMMWORD PTR _x0$[ebp]
  00062	0f c6 45 e0 00	 shufps	 xmm0, XMMWORD PTR _x0$[ebp], 0
  00067	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  0006c	6b d1 00	 imul	 edx, ecx, 0
  0006f	03 53 08	 add	 edx, DWORD PTR _m$[ebx]
  00072	0f 10 12	 movups	 xmm2, XMMWORD PTR [edx]
  00075	0f 59 d0	 mulps	 xmm2, xmm0
  00078	0f 58 d1	 addps	 xmm2, xmm1
  0007b	0f 29 55 c0	 movaps	 XMMWORD PTR _x1$[ebp], xmm2

; 93   :                   _mm_mul_ps(glmm_load(m[1]), glmm_shuff1x(x0, 1)));
; 94   : 
; 95   :   x2 = _mm_add_ps(_mm_mul_ps(glmm_load(m[2]), glmm_shuff1x(x0, 2)),

  0007f	0f 28 45 e0	 movaps	 xmm0, XMMWORD PTR _x0$[ebp]
  00083	0f c6 45 e0 ff	 shufps	 xmm0, XMMWORD PTR _x0$[ebp], 255 ; 000000ffH
  00088	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  0008d	6b c8 03	 imul	 ecx, eax, 3
  00090	03 4b 08	 add	 ecx, DWORD PTR _m$[ebx]
  00093	0f 10 09	 movups	 xmm1, XMMWORD PTR [ecx]
  00096	0f 59 c8	 mulps	 xmm1, xmm0
  00099	0f 28 45 e0	 movaps	 xmm0, XMMWORD PTR _x0$[ebp]
  0009d	0f c6 45 e0 aa	 shufps	 xmm0, XMMWORD PTR _x0$[ebp], 170 ; 000000aaH
  000a2	ba 10 00 00 00	 mov	 edx, 16			; 00000010H
  000a7	d1 e2		 shl	 edx, 1
  000a9	03 53 08	 add	 edx, DWORD PTR _m$[ebx]
  000ac	0f 10 12	 movups	 xmm2, XMMWORD PTR [edx]
  000af	0f 59 d0	 mulps	 xmm2, xmm0
  000b2	0f 58 d1	 addps	 xmm2, xmm1
  000b5	0f 29 55 a0	 movaps	 XMMWORD PTR _x2$[ebp], xmm2

; 96   :                   _mm_mul_ps(glmm_load(m[3]), glmm_shuff1x(x0, 3)));
; 97   : 
; 98   :   glmm_store(dest, _mm_add_ps(x1, x2));

  000b9	0f 28 45 c0	 movaps	 xmm0, XMMWORD PTR _x1$[ebp]
  000bd	0f 58 45 a0	 addps	 xmm0, XMMWORD PTR _x2$[ebp]
  000c1	8b 43 10	 mov	 eax, DWORD PTR _dest$[ebx]
  000c4	0f 11 00	 movups	 XMMWORD PTR [eax], xmm0

; 99   : }

  000c7	5f		 pop	 edi
  000c8	5e		 pop	 esi
  000c9	8b e5		 mov	 esp, ebp
  000cb	5d		 pop	 ebp
  000cc	8b e3		 mov	 esp, ebx
  000ce	5b		 pop	 ebx
  000cf	c3		 ret	 0
_glm_mat4_mulv_sse2 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Light\source\repos\3DRendC\include\vec3.h
;	COMDAT _glm_normalize_to
_TEXT	SEGMENT
_v$ = 8							; size = 4
_dest$ = 12						; size = 4
_glm_normalize_to PROC					; COMDAT

; 1075 : glm_normalize_to(vec3 v, vec3 dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __82F46937_vec3@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1076 :   glm_vec3_normalize_to(v, dest);

  00028	8b 45 0c	 mov	 eax, DWORD PTR _dest$[ebp]
  0002b	50		 push	 eax
  0002c	8b 4d 08	 mov	 ecx, DWORD PTR _v$[ebp]
  0002f	51		 push	 ecx
  00030	e8 00 00 00 00	 call	 _glm_vec3_normalize_to
  00035	83 c4 08	 add	 esp, 8

; 1077 : }

  00038	5f		 pop	 edi
  00039	5e		 pop	 esi
  0003a	5b		 pop	 ebx
  0003b	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00041	3b ec		 cmp	 ebp, esp
  00043	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00048	8b e5		 mov	 esp, ebp
  0004a	5d		 pop	 ebp
  0004b	c3		 ret	 0
_glm_normalize_to ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Light\source\repos\3DRendC\include\vec3.h
;	COMDAT _glm_vec3_crossn
_TEXT	SEGMENT
_a$ = 8							; size = 4
_b$ = 12						; size = 4
_dest$ = 16						; size = 4
_glm_vec3_crossn PROC					; COMDAT

; 596  : glm_vec3_crossn(vec3 a, vec3 b, vec3 dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __82F46937_vec3@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 597  :   glm_vec3_cross(a, b, dest);

  00028	8b 45 10	 mov	 eax, DWORD PTR _dest$[ebp]
  0002b	50		 push	 eax
  0002c	8b 4d 0c	 mov	 ecx, DWORD PTR _b$[ebp]
  0002f	51		 push	 ecx
  00030	8b 55 08	 mov	 edx, DWORD PTR _a$[ebp]
  00033	52		 push	 edx
  00034	e8 00 00 00 00	 call	 _glm_vec3_cross
  00039	83 c4 0c	 add	 esp, 12			; 0000000cH

; 598  :   glm_vec3_normalize(dest);

  0003c	8b 45 10	 mov	 eax, DWORD PTR _dest$[ebp]
  0003f	50		 push	 eax
  00040	e8 00 00 00 00	 call	 _glm_vec3_normalize
  00045	83 c4 04	 add	 esp, 4

; 599  : }

  00048	5f		 pop	 edi
  00049	5e		 pop	 esi
  0004a	5b		 pop	 ebx
  0004b	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00051	3b ec		 cmp	 ebp, esp
  00053	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00058	8b e5		 mov	 esp, ebp
  0005a	5d		 pop	 ebp
  0005b	c3		 ret	 0
_glm_vec3_crossn ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Light\source\repos\3DRendC\include\vec3.h
;	COMDAT _glm_vec3_cross
_TEXT	SEGMENT
_a$ = 8							; size = 4
_b$ = 12						; size = 4
_dest$ = 16						; size = 4
_glm_vec3_cross PROC					; COMDAT

; 580  : glm_vec3_cross(vec3 a, vec3 b, vec3 dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __82F46937_vec3@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 581  :   /* (u2.v3 - u3.v2, u3.v1 - u1.v3, u1.v2 - u2.v1) */
; 582  :   dest[0] = a[1] * b[2] - a[2] * b[1];

  00028	b8 04 00 00 00	 mov	 eax, 4
  0002d	c1 e0 00	 shl	 eax, 0
  00030	b9 04 00 00 00	 mov	 ecx, 4
  00035	d1 e1		 shl	 ecx, 1
  00037	8b 55 08	 mov	 edx, DWORD PTR _a$[ebp]
  0003a	8b 75 0c	 mov	 esi, DWORD PTR _b$[ebp]
  0003d	f3 0f 10 04 02	 movss	 xmm0, DWORD PTR [edx+eax]
  00042	f3 0f 59 04 0e	 mulss	 xmm0, DWORD PTR [esi+ecx]
  00047	b8 04 00 00 00	 mov	 eax, 4
  0004c	d1 e0		 shl	 eax, 1
  0004e	b9 04 00 00 00	 mov	 ecx, 4
  00053	c1 e1 00	 shl	 ecx, 0
  00056	8b 55 08	 mov	 edx, DWORD PTR _a$[ebp]
  00059	8b 75 0c	 mov	 esi, DWORD PTR _b$[ebp]
  0005c	f3 0f 10 0c 02	 movss	 xmm1, DWORD PTR [edx+eax]
  00061	f3 0f 59 0c 0e	 mulss	 xmm1, DWORD PTR [esi+ecx]
  00066	f3 0f 5c c1	 subss	 xmm0, xmm1
  0006a	b8 04 00 00 00	 mov	 eax, 4
  0006f	6b c8 00	 imul	 ecx, eax, 0
  00072	8b 55 10	 mov	 edx, DWORD PTR _dest$[ebp]
  00075	f3 0f 11 04 0a	 movss	 DWORD PTR [edx+ecx], xmm0

; 583  :   dest[1] = a[2] * b[0] - a[0] * b[2];

  0007a	b8 04 00 00 00	 mov	 eax, 4
  0007f	d1 e0		 shl	 eax, 1
  00081	b9 04 00 00 00	 mov	 ecx, 4
  00086	6b d1 00	 imul	 edx, ecx, 0
  00089	8b 4d 08	 mov	 ecx, DWORD PTR _a$[ebp]
  0008c	8b 75 0c	 mov	 esi, DWORD PTR _b$[ebp]
  0008f	f3 0f 10 04 01	 movss	 xmm0, DWORD PTR [ecx+eax]
  00094	f3 0f 59 04 16	 mulss	 xmm0, DWORD PTR [esi+edx]
  00099	ba 04 00 00 00	 mov	 edx, 4
  0009e	6b c2 00	 imul	 eax, edx, 0
  000a1	b9 04 00 00 00	 mov	 ecx, 4
  000a6	d1 e1		 shl	 ecx, 1
  000a8	8b 55 08	 mov	 edx, DWORD PTR _a$[ebp]
  000ab	8b 75 0c	 mov	 esi, DWORD PTR _b$[ebp]
  000ae	f3 0f 10 0c 02	 movss	 xmm1, DWORD PTR [edx+eax]
  000b3	f3 0f 59 0c 0e	 mulss	 xmm1, DWORD PTR [esi+ecx]
  000b8	f3 0f 5c c1	 subss	 xmm0, xmm1
  000bc	b8 04 00 00 00	 mov	 eax, 4
  000c1	c1 e0 00	 shl	 eax, 0
  000c4	8b 4d 10	 mov	 ecx, DWORD PTR _dest$[ebp]
  000c7	f3 0f 11 04 01	 movss	 DWORD PTR [ecx+eax], xmm0

; 584  :   dest[2] = a[0] * b[1] - a[1] * b[0];

  000cc	b8 04 00 00 00	 mov	 eax, 4
  000d1	6b c8 00	 imul	 ecx, eax, 0
  000d4	ba 04 00 00 00	 mov	 edx, 4
  000d9	c1 e2 00	 shl	 edx, 0
  000dc	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  000df	8b 75 0c	 mov	 esi, DWORD PTR _b$[ebp]
  000e2	f3 0f 10 04 08	 movss	 xmm0, DWORD PTR [eax+ecx]
  000e7	f3 0f 59 04 16	 mulss	 xmm0, DWORD PTR [esi+edx]
  000ec	b9 04 00 00 00	 mov	 ecx, 4
  000f1	c1 e1 00	 shl	 ecx, 0
  000f4	ba 04 00 00 00	 mov	 edx, 4
  000f9	6b c2 00	 imul	 eax, edx, 0
  000fc	8b 55 08	 mov	 edx, DWORD PTR _a$[ebp]
  000ff	8b 75 0c	 mov	 esi, DWORD PTR _b$[ebp]
  00102	f3 0f 10 0c 0a	 movss	 xmm1, DWORD PTR [edx+ecx]
  00107	f3 0f 59 0c 06	 mulss	 xmm1, DWORD PTR [esi+eax]
  0010c	f3 0f 5c c1	 subss	 xmm0, xmm1
  00110	b8 04 00 00 00	 mov	 eax, 4
  00115	d1 e0		 shl	 eax, 1
  00117	8b 4d 10	 mov	 ecx, DWORD PTR _dest$[ebp]
  0011a	f3 0f 11 04 01	 movss	 DWORD PTR [ecx+eax], xmm0

; 585  : }

  0011f	5f		 pop	 edi
  00120	5e		 pop	 esi
  00121	5b		 pop	 ebx
  00122	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00128	3b ec		 cmp	 ebp, esp
  0012a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0012f	8b e5		 mov	 esp, ebp
  00131	5d		 pop	 ebp
  00132	c3		 ret	 0
_glm_vec3_cross ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Light\source\repos\3DRendC\include\vec3.h
;	COMDAT _glm_vec3_normalize_to
_TEXT	SEGMENT
_norm$ = -8						; size = 4
_v$ = 8							; size = 4
_dest$ = 12						; size = 4
_glm_vec3_normalize_to PROC				; COMDAT

; 558  : glm_vec3_normalize_to(vec3 v, vec3 dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __82F46937_vec3@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 559  :   float norm;
; 560  : 
; 561  :   norm = glm_vec3_norm(v);

  00028	8b 45 08	 mov	 eax, DWORD PTR _v$[ebp]
  0002b	50		 push	 eax
  0002c	e8 00 00 00 00	 call	 _glm_vec3_norm
  00031	83 c4 04	 add	 esp, 4
  00034	d9 5d f8	 fstp	 DWORD PTR _norm$[ebp]

; 562  : 
; 563  :   if (norm == 0.0f) {

  00037	f3 0f 10 45 f8	 movss	 xmm0, DWORD PTR _norm$[ebp]
  0003c	0f 2e 05 00 00
	00 00		 ucomiss xmm0, DWORD PTR __real@00000000
  00043	9f		 lahf
  00044	f6 c4 44	 test	 ah, 68			; 00000044H
  00047	7a 0e		 jp	 SHORT $LN2@glm_vec3_n

; 564  :     glm_vec3_zero(dest);

  00049	8b 45 0c	 mov	 eax, DWORD PTR _dest$[ebp]
  0004c	50		 push	 eax
  0004d	e8 00 00 00 00	 call	 _glm_vec3_zero
  00052	83 c4 04	 add	 esp, 4

; 565  :     return;

  00055	eb 23		 jmp	 SHORT $LN1@glm_vec3_n
$LN2@glm_vec3_n:

; 566  :   }
; 567  : 
; 568  :   glm_vec3_scale(v, 1.0f / norm, dest);

  00057	8b 45 0c	 mov	 eax, DWORD PTR _dest$[ebp]
  0005a	50		 push	 eax
  0005b	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00063	f3 0f 5e 45 f8	 divss	 xmm0, DWORD PTR _norm$[ebp]
  00068	51		 push	 ecx
  00069	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0006e	8b 4d 08	 mov	 ecx, DWORD PTR _v$[ebp]
  00071	51		 push	 ecx
  00072	e8 00 00 00 00	 call	 _glm_vec3_scale
  00077	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@glm_vec3_n:

; 569  : }

  0007a	5f		 pop	 edi
  0007b	5e		 pop	 esi
  0007c	5b		 pop	 ebx
  0007d	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00083	3b ec		 cmp	 ebp, esp
  00085	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0008a	8b e5		 mov	 esp, ebp
  0008c	5d		 pop	 ebp
  0008d	c3		 ret	 0
_glm_vec3_normalize_to ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Light\source\repos\3DRendC\include\vec3.h
;	COMDAT _glm_vec3_normalize
_TEXT	SEGMENT
_norm$ = -8						; size = 4
_v$ = 8							; size = 4
_glm_vec3_normalize PROC				; COMDAT

; 537  : glm_vec3_normalize(vec3 v) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __82F46937_vec3@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 538  :   float norm;
; 539  : 
; 540  :   norm = glm_vec3_norm(v);

  00028	8b 45 08	 mov	 eax, DWORD PTR _v$[ebp]
  0002b	50		 push	 eax
  0002c	e8 00 00 00 00	 call	 _glm_vec3_norm
  00031	83 c4 04	 add	 esp, 4
  00034	d9 5d f8	 fstp	 DWORD PTR _norm$[ebp]

; 541  : 
; 542  :   if (norm == 0.0f) {

  00037	f3 0f 10 45 f8	 movss	 xmm0, DWORD PTR _norm$[ebp]
  0003c	0f 2e 05 00 00
	00 00		 ucomiss xmm0, DWORD PTR __real@00000000
  00043	9f		 lahf
  00044	f6 c4 44	 test	 ah, 68			; 00000044H
  00047	7a 3a		 jp	 SHORT $LN2@glm_vec3_n

; 543  :     v[0] = v[1] = v[2] = 0.0f;

  00049	b8 04 00 00 00	 mov	 eax, 4
  0004e	d1 e0		 shl	 eax, 1
  00050	8b 4d 08	 mov	 ecx, DWORD PTR _v$[ebp]
  00053	0f 57 c0	 xorps	 xmm0, xmm0
  00056	f3 0f 11 04 01	 movss	 DWORD PTR [ecx+eax], xmm0
  0005b	ba 04 00 00 00	 mov	 edx, 4
  00060	c1 e2 00	 shl	 edx, 0
  00063	8b 45 08	 mov	 eax, DWORD PTR _v$[ebp]
  00066	0f 57 c0	 xorps	 xmm0, xmm0
  00069	f3 0f 11 04 10	 movss	 DWORD PTR [eax+edx], xmm0
  0006e	b9 04 00 00 00	 mov	 ecx, 4
  00073	6b d1 00	 imul	 edx, ecx, 0
  00076	8b 45 08	 mov	 eax, DWORD PTR _v$[ebp]
  00079	0f 57 c0	 xorps	 xmm0, xmm0
  0007c	f3 0f 11 04 10	 movss	 DWORD PTR [eax+edx], xmm0

; 544  :     return;

  00081	eb 23		 jmp	 SHORT $LN1@glm_vec3_n
$LN2@glm_vec3_n:

; 545  :   }
; 546  : 
; 547  :   glm_vec3_scale(v, 1.0f / norm, v);

  00083	8b 45 08	 mov	 eax, DWORD PTR _v$[ebp]
  00086	50		 push	 eax
  00087	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  0008f	f3 0f 5e 45 f8	 divss	 xmm0, DWORD PTR _norm$[ebp]
  00094	51		 push	 ecx
  00095	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0009a	8b 4d 08	 mov	 ecx, DWORD PTR _v$[ebp]
  0009d	51		 push	 ecx
  0009e	e8 00 00 00 00	 call	 _glm_vec3_scale
  000a3	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@glm_vec3_n:

; 548  : }

  000a6	5f		 pop	 edi
  000a7	5e		 pop	 esi
  000a8	5b		 pop	 ebx
  000a9	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  000af	3b ec		 cmp	 ebp, esp
  000b1	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000b6	8b e5		 mov	 esp, ebp
  000b8	5d		 pop	 ebp
  000b9	c3		 ret	 0
_glm_vec3_normalize ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Light\source\repos\3DRendC\include\vec3.h
;	COMDAT _glm_vec3_negate
_TEXT	SEGMENT
_v$ = 8							; size = 4
_glm_vec3_negate PROC					; COMDAT

; 526  : glm_vec3_negate(vec3 v) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __82F46937_vec3@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 527  :   glm_vec3_negate_to(v, v);

  00028	8b 45 08	 mov	 eax, DWORD PTR _v$[ebp]
  0002b	50		 push	 eax
  0002c	8b 4d 08	 mov	 ecx, DWORD PTR _v$[ebp]
  0002f	51		 push	 ecx
  00030	e8 00 00 00 00	 call	 _glm_vec3_negate_to
  00035	83 c4 08	 add	 esp, 8

; 528  : }

  00038	5f		 pop	 edi
  00039	5e		 pop	 esi
  0003a	5b		 pop	 ebx
  0003b	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00041	3b ec		 cmp	 ebp, esp
  00043	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00048	8b e5		 mov	 esp, ebp
  0004a	5d		 pop	 ebp
  0004b	c3		 ret	 0
_glm_vec3_negate ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Light\source\repos\3DRendC\include\vec3.h
;	COMDAT _glm_vec3_negate_to
_TEXT	SEGMENT
_v$ = 8							; size = 4
_dest$ = 12						; size = 4
_glm_vec3_negate_to PROC				; COMDAT

; 513  : glm_vec3_negate_to(vec3 v, vec3 dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __82F46937_vec3@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 514  :   dest[0] = -v[0];

  00028	b8 04 00 00 00	 mov	 eax, 4
  0002d	6b c8 00	 imul	 ecx, eax, 0
  00030	8b 55 08	 mov	 edx, DWORD PTR _v$[ebp]
  00033	f3 0f 10 04 0a	 movss	 xmm0, DWORD PTR [edx+ecx]
  00038	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
  0003f	b8 04 00 00 00	 mov	 eax, 4
  00044	6b c8 00	 imul	 ecx, eax, 0
  00047	8b 55 0c	 mov	 edx, DWORD PTR _dest$[ebp]
  0004a	f3 0f 11 04 0a	 movss	 DWORD PTR [edx+ecx], xmm0

; 515  :   dest[1] = -v[1];

  0004f	b8 04 00 00 00	 mov	 eax, 4
  00054	c1 e0 00	 shl	 eax, 0
  00057	8b 4d 08	 mov	 ecx, DWORD PTR _v$[ebp]
  0005a	f3 0f 10 04 01	 movss	 xmm0, DWORD PTR [ecx+eax]
  0005f	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
  00066	ba 04 00 00 00	 mov	 edx, 4
  0006b	c1 e2 00	 shl	 edx, 0
  0006e	8b 45 0c	 mov	 eax, DWORD PTR _dest$[ebp]
  00071	f3 0f 11 04 10	 movss	 DWORD PTR [eax+edx], xmm0

; 516  :   dest[2] = -v[2];

  00076	b8 04 00 00 00	 mov	 eax, 4
  0007b	d1 e0		 shl	 eax, 1
  0007d	8b 4d 08	 mov	 ecx, DWORD PTR _v$[ebp]
  00080	f3 0f 10 04 01	 movss	 xmm0, DWORD PTR [ecx+eax]
  00085	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
  0008c	ba 04 00 00 00	 mov	 edx, 4
  00091	d1 e2		 shl	 edx, 1
  00093	8b 45 0c	 mov	 eax, DWORD PTR _dest$[ebp]
  00096	f3 0f 11 04 10	 movss	 DWORD PTR [eax+edx], xmm0

; 517  : }

  0009b	5f		 pop	 edi
  0009c	5e		 pop	 esi
  0009d	5b		 pop	 ebx
  0009e	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  000a4	3b ec		 cmp	 ebp, esp
  000a6	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000ab	8b e5		 mov	 esp, ebp
  000ad	5d		 pop	 ebp
  000ae	c3		 ret	 0
_glm_vec3_negate_to ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Light\source\repos\3DRendC\include\vec3.h
;	COMDAT _glm_vec3_scale
_TEXT	SEGMENT
_v$ = 8							; size = 4
_s$ = 12						; size = 4
_dest$ = 16						; size = 4
_glm_vec3_scale PROC					; COMDAT

; 346  : glm_vec3_scale(vec3 v, float s, vec3 dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __82F46937_vec3@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 347  :   dest[0] = v[0] * s;

  00028	b8 04 00 00 00	 mov	 eax, 4
  0002d	6b c8 00	 imul	 ecx, eax, 0
  00030	8b 55 08	 mov	 edx, DWORD PTR _v$[ebp]
  00033	f3 0f 10 04 0a	 movss	 xmm0, DWORD PTR [edx+ecx]
  00038	f3 0f 59 45 0c	 mulss	 xmm0, DWORD PTR _s$[ebp]
  0003d	b8 04 00 00 00	 mov	 eax, 4
  00042	6b c8 00	 imul	 ecx, eax, 0
  00045	8b 55 10	 mov	 edx, DWORD PTR _dest$[ebp]
  00048	f3 0f 11 04 0a	 movss	 DWORD PTR [edx+ecx], xmm0

; 348  :   dest[1] = v[1] * s;

  0004d	b8 04 00 00 00	 mov	 eax, 4
  00052	c1 e0 00	 shl	 eax, 0
  00055	8b 4d 08	 mov	 ecx, DWORD PTR _v$[ebp]
  00058	f3 0f 10 04 01	 movss	 xmm0, DWORD PTR [ecx+eax]
  0005d	f3 0f 59 45 0c	 mulss	 xmm0, DWORD PTR _s$[ebp]
  00062	ba 04 00 00 00	 mov	 edx, 4
  00067	c1 e2 00	 shl	 edx, 0
  0006a	8b 45 10	 mov	 eax, DWORD PTR _dest$[ebp]
  0006d	f3 0f 11 04 10	 movss	 DWORD PTR [eax+edx], xmm0

; 349  :   dest[2] = v[2] * s;

  00072	b8 04 00 00 00	 mov	 eax, 4
  00077	d1 e0		 shl	 eax, 1
  00079	8b 4d 08	 mov	 ecx, DWORD PTR _v$[ebp]
  0007c	f3 0f 10 04 01	 movss	 xmm0, DWORD PTR [ecx+eax]
  00081	f3 0f 59 45 0c	 mulss	 xmm0, DWORD PTR _s$[ebp]
  00086	ba 04 00 00 00	 mov	 edx, 4
  0008b	d1 e2		 shl	 edx, 1
  0008d	8b 45 10	 mov	 eax, DWORD PTR _dest$[ebp]
  00090	f3 0f 11 04 10	 movss	 DWORD PTR [eax+edx], xmm0

; 350  : }

  00095	5f		 pop	 edi
  00096	5e		 pop	 esi
  00097	5b		 pop	 ebx
  00098	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0009e	3b ec		 cmp	 ebp, esp
  000a0	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000a5	8b e5		 mov	 esp, ebp
  000a7	5d		 pop	 ebp
  000a8	c3		 ret	 0
_glm_vec3_scale ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Light\source\repos\3DRendC\include\vec3.h
;	COMDAT _glm_vec3_sub
_TEXT	SEGMENT
_a$ = 8							; size = 4
_b$ = 12						; size = 4
_dest$ = 16						; size = 4
_glm_vec3_sub PROC					; COMDAT

; 301  : glm_vec3_sub(vec3 a, vec3 b, vec3 dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __82F46937_vec3@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 302  :   dest[0] = a[0] - b[0];

  00028	b8 04 00 00 00	 mov	 eax, 4
  0002d	6b c8 00	 imul	 ecx, eax, 0
  00030	ba 04 00 00 00	 mov	 edx, 4
  00035	6b c2 00	 imul	 eax, edx, 0
  00038	8b 55 08	 mov	 edx, DWORD PTR _a$[ebp]
  0003b	8b 75 0c	 mov	 esi, DWORD PTR _b$[ebp]
  0003e	f3 0f 10 04 0a	 movss	 xmm0, DWORD PTR [edx+ecx]
  00043	f3 0f 5c 04 06	 subss	 xmm0, DWORD PTR [esi+eax]
  00048	b8 04 00 00 00	 mov	 eax, 4
  0004d	6b c8 00	 imul	 ecx, eax, 0
  00050	8b 55 10	 mov	 edx, DWORD PTR _dest$[ebp]
  00053	f3 0f 11 04 0a	 movss	 DWORD PTR [edx+ecx], xmm0

; 303  :   dest[1] = a[1] - b[1];

  00058	b8 04 00 00 00	 mov	 eax, 4
  0005d	c1 e0 00	 shl	 eax, 0
  00060	b9 04 00 00 00	 mov	 ecx, 4
  00065	c1 e1 00	 shl	 ecx, 0
  00068	8b 55 08	 mov	 edx, DWORD PTR _a$[ebp]
  0006b	8b 75 0c	 mov	 esi, DWORD PTR _b$[ebp]
  0006e	f3 0f 10 04 02	 movss	 xmm0, DWORD PTR [edx+eax]
  00073	f3 0f 5c 04 0e	 subss	 xmm0, DWORD PTR [esi+ecx]
  00078	b8 04 00 00 00	 mov	 eax, 4
  0007d	c1 e0 00	 shl	 eax, 0
  00080	8b 4d 10	 mov	 ecx, DWORD PTR _dest$[ebp]
  00083	f3 0f 11 04 01	 movss	 DWORD PTR [ecx+eax], xmm0

; 304  :   dest[2] = a[2] - b[2];

  00088	b8 04 00 00 00	 mov	 eax, 4
  0008d	d1 e0		 shl	 eax, 1
  0008f	b9 04 00 00 00	 mov	 ecx, 4
  00094	d1 e1		 shl	 ecx, 1
  00096	8b 55 08	 mov	 edx, DWORD PTR _a$[ebp]
  00099	8b 75 0c	 mov	 esi, DWORD PTR _b$[ebp]
  0009c	f3 0f 10 04 02	 movss	 xmm0, DWORD PTR [edx+eax]
  000a1	f3 0f 5c 04 0e	 subss	 xmm0, DWORD PTR [esi+ecx]
  000a6	b8 04 00 00 00	 mov	 eax, 4
  000ab	d1 e0		 shl	 eax, 1
  000ad	8b 4d 10	 mov	 ecx, DWORD PTR _dest$[ebp]
  000b0	f3 0f 11 04 01	 movss	 DWORD PTR [ecx+eax], xmm0

; 305  : }

  000b5	5f		 pop	 edi
  000b6	5e		 pop	 esi
  000b7	5b		 pop	 ebx
  000b8	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  000be	3b ec		 cmp	 ebp, esp
  000c0	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000c5	8b e5		 mov	 esp, ebp
  000c7	5d		 pop	 ebp
  000c8	c3		 ret	 0
_glm_vec3_sub ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Light\source\repos\3DRendC\include\vec3.h
;	COMDAT _glm_vec3_add
_TEXT	SEGMENT
_a$ = 8							; size = 4
_b$ = 12						; size = 4
_dest$ = 16						; size = 4
_glm_vec3_add PROC					; COMDAT

; 271  : glm_vec3_add(vec3 a, vec3 b, vec3 dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __82F46937_vec3@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 272  :   dest[0] = a[0] + b[0];

  00028	b8 04 00 00 00	 mov	 eax, 4
  0002d	6b c8 00	 imul	 ecx, eax, 0
  00030	ba 04 00 00 00	 mov	 edx, 4
  00035	6b c2 00	 imul	 eax, edx, 0
  00038	8b 55 08	 mov	 edx, DWORD PTR _a$[ebp]
  0003b	8b 75 0c	 mov	 esi, DWORD PTR _b$[ebp]
  0003e	f3 0f 10 04 0a	 movss	 xmm0, DWORD PTR [edx+ecx]
  00043	f3 0f 58 04 06	 addss	 xmm0, DWORD PTR [esi+eax]
  00048	b8 04 00 00 00	 mov	 eax, 4
  0004d	6b c8 00	 imul	 ecx, eax, 0
  00050	8b 55 10	 mov	 edx, DWORD PTR _dest$[ebp]
  00053	f3 0f 11 04 0a	 movss	 DWORD PTR [edx+ecx], xmm0

; 273  :   dest[1] = a[1] + b[1];

  00058	b8 04 00 00 00	 mov	 eax, 4
  0005d	c1 e0 00	 shl	 eax, 0
  00060	b9 04 00 00 00	 mov	 ecx, 4
  00065	c1 e1 00	 shl	 ecx, 0
  00068	8b 55 08	 mov	 edx, DWORD PTR _a$[ebp]
  0006b	8b 75 0c	 mov	 esi, DWORD PTR _b$[ebp]
  0006e	f3 0f 10 04 02	 movss	 xmm0, DWORD PTR [edx+eax]
  00073	f3 0f 58 04 0e	 addss	 xmm0, DWORD PTR [esi+ecx]
  00078	b8 04 00 00 00	 mov	 eax, 4
  0007d	c1 e0 00	 shl	 eax, 0
  00080	8b 4d 10	 mov	 ecx, DWORD PTR _dest$[ebp]
  00083	f3 0f 11 04 01	 movss	 DWORD PTR [ecx+eax], xmm0

; 274  :   dest[2] = a[2] + b[2];

  00088	b8 04 00 00 00	 mov	 eax, 4
  0008d	d1 e0		 shl	 eax, 1
  0008f	b9 04 00 00 00	 mov	 ecx, 4
  00094	d1 e1		 shl	 ecx, 1
  00096	8b 55 08	 mov	 edx, DWORD PTR _a$[ebp]
  00099	8b 75 0c	 mov	 esi, DWORD PTR _b$[ebp]
  0009c	f3 0f 10 04 02	 movss	 xmm0, DWORD PTR [edx+eax]
  000a1	f3 0f 58 04 0e	 addss	 xmm0, DWORD PTR [esi+ecx]
  000a6	b8 04 00 00 00	 mov	 eax, 4
  000ab	d1 e0		 shl	 eax, 1
  000ad	8b 4d 10	 mov	 ecx, DWORD PTR _dest$[ebp]
  000b0	f3 0f 11 04 01	 movss	 DWORD PTR [ecx+eax], xmm0

; 275  : }

  000b5	5f		 pop	 edi
  000b6	5e		 pop	 esi
  000b7	5b		 pop	 ebx
  000b8	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  000be	3b ec		 cmp	 ebp, esp
  000c0	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000c5	8b e5		 mov	 esp, ebp
  000c7	5d		 pop	 ebp
  000c8	c3		 ret	 0
_glm_vec3_add ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Light\source\repos\3DRendC\include\vec3.h
;	COMDAT _glm_vec3_norm
_TEXT	SEGMENT
_v$ = 8							; size = 4
_glm_vec3_norm PROC					; COMDAT

; 215  : glm_vec3_norm(vec3 v) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __82F46937_vec3@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 216  :   return sqrtf(glm_vec3_norm2(v));

  00028	8b 45 08	 mov	 eax, DWORD PTR _v$[ebp]
  0002b	50		 push	 eax
  0002c	e8 00 00 00 00	 call	 _glm_vec3_norm2
  00031	d9 1c 24	 fstp	 DWORD PTR [esp]
  00034	e8 00 00 00 00	 call	 _sqrtf
  00039	83 c4 04	 add	 esp, 4

; 217  : }

  0003c	5f		 pop	 edi
  0003d	5e		 pop	 esi
  0003e	5b		 pop	 ebx
  0003f	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00045	3b ec		 cmp	 ebp, esp
  00047	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004c	8b e5		 mov	 esp, ebp
  0004e	5d		 pop	 ebp
  0004f	c3		 ret	 0
_glm_vec3_norm ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Light\source\repos\3DRendC\include\vec3.h
;	COMDAT _glm_vec3_norm2
_TEXT	SEGMENT
_v$ = 8							; size = 4
_glm_vec3_norm2 PROC					; COMDAT

; 201  : glm_vec3_norm2(vec3 v) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __82F46937_vec3@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 202  :   return glm_vec3_dot(v, v);

  00028	8b 45 08	 mov	 eax, DWORD PTR _v$[ebp]
  0002b	50		 push	 eax
  0002c	8b 4d 08	 mov	 ecx, DWORD PTR _v$[ebp]
  0002f	51		 push	 ecx
  00030	e8 00 00 00 00	 call	 _glm_vec3_dot
  00035	83 c4 08	 add	 esp, 8

; 203  : }

  00038	5f		 pop	 edi
  00039	5e		 pop	 esi
  0003a	5b		 pop	 ebx
  0003b	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00041	3b ec		 cmp	 ebp, esp
  00043	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00048	8b e5		 mov	 esp, ebp
  0004a	5d		 pop	 ebp
  0004b	c3		 ret	 0
_glm_vec3_norm2 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Light\source\repos\3DRendC\include\vec3.h
;	COMDAT _glm_vec3_dot
_TEXT	SEGMENT
tv130 = -196						; size = 4
_a$ = 8							; size = 4
_b$ = 12						; size = 4
_glm_vec3_dot PROC					; COMDAT

; 184  : glm_vec3_dot(vec3 a, vec3 b) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c4 00 00
	00		 sub	 esp, 196		; 000000c4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 3c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-196]
  00012	b9 31 00 00 00	 mov	 ecx, 49			; 00000031H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __82F46937_vec3@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 185  :   return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];

  00028	b8 04 00 00 00	 mov	 eax, 4
  0002d	6b c8 00	 imul	 ecx, eax, 0
  00030	ba 04 00 00 00	 mov	 edx, 4
  00035	6b c2 00	 imul	 eax, edx, 0
  00038	8b 55 08	 mov	 edx, DWORD PTR _a$[ebp]
  0003b	8b 75 0c	 mov	 esi, DWORD PTR _b$[ebp]
  0003e	f3 0f 10 04 0a	 movss	 xmm0, DWORD PTR [edx+ecx]
  00043	f3 0f 59 04 06	 mulss	 xmm0, DWORD PTR [esi+eax]
  00048	b8 04 00 00 00	 mov	 eax, 4
  0004d	c1 e0 00	 shl	 eax, 0
  00050	b9 04 00 00 00	 mov	 ecx, 4
  00055	c1 e1 00	 shl	 ecx, 0
  00058	8b 55 08	 mov	 edx, DWORD PTR _a$[ebp]
  0005b	8b 75 0c	 mov	 esi, DWORD PTR _b$[ebp]
  0005e	f3 0f 10 0c 02	 movss	 xmm1, DWORD PTR [edx+eax]
  00063	f3 0f 59 0c 0e	 mulss	 xmm1, DWORD PTR [esi+ecx]
  00068	f3 0f 58 c1	 addss	 xmm0, xmm1
  0006c	b8 04 00 00 00	 mov	 eax, 4
  00071	d1 e0		 shl	 eax, 1
  00073	b9 04 00 00 00	 mov	 ecx, 4
  00078	d1 e1		 shl	 ecx, 1
  0007a	8b 55 08	 mov	 edx, DWORD PTR _a$[ebp]
  0007d	8b 75 0c	 mov	 esi, DWORD PTR _b$[ebp]
  00080	f3 0f 10 0c 02	 movss	 xmm1, DWORD PTR [edx+eax]
  00085	f3 0f 59 0c 0e	 mulss	 xmm1, DWORD PTR [esi+ecx]
  0008a	f3 0f 58 c1	 addss	 xmm0, xmm1
  0008e	f3 0f 11 85 3c
	ff ff ff	 movss	 DWORD PTR tv130[ebp], xmm0
  00096	d9 85 3c ff ff
	ff		 fld	 DWORD PTR tv130[ebp]

; 186  : }

  0009c	5f		 pop	 edi
  0009d	5e		 pop	 esi
  0009e	5b		 pop	 ebx
  0009f	81 c4 c4 00 00
	00		 add	 esp, 196		; 000000c4H
  000a5	3b ec		 cmp	 ebp, esp
  000a7	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000ac	8b e5		 mov	 esp, ebp
  000ae	5d		 pop	 ebp
  000af	c3		 ret	 0
_glm_vec3_dot ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Light\source\repos\3DRendC\include\vec3.h
;	COMDAT _glm_vec3_zero
_TEXT	SEGMENT
_v$ = 8							; size = 4
_glm_vec3_zero PROC					; COMDAT

; 159  : glm_vec3_zero(vec3 v) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __82F46937_vec3@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 160  :   v[0] = v[1] = v[2] = 0.0f;

  00028	b8 04 00 00 00	 mov	 eax, 4
  0002d	d1 e0		 shl	 eax, 1
  0002f	8b 4d 08	 mov	 ecx, DWORD PTR _v$[ebp]
  00032	0f 57 c0	 xorps	 xmm0, xmm0
  00035	f3 0f 11 04 01	 movss	 DWORD PTR [ecx+eax], xmm0
  0003a	ba 04 00 00 00	 mov	 edx, 4
  0003f	c1 e2 00	 shl	 edx, 0
  00042	8b 45 08	 mov	 eax, DWORD PTR _v$[ebp]
  00045	0f 57 c0	 xorps	 xmm0, xmm0
  00048	f3 0f 11 04 10	 movss	 DWORD PTR [eax+edx], xmm0
  0004d	b9 04 00 00 00	 mov	 ecx, 4
  00052	6b d1 00	 imul	 edx, ecx, 0
  00055	8b 45 08	 mov	 eax, DWORD PTR _v$[ebp]
  00058	0f 57 c0	 xorps	 xmm0, xmm0
  0005b	f3 0f 11 04 10	 movss	 DWORD PTR [eax+edx], xmm0

; 161  : }

  00060	5f		 pop	 edi
  00061	5e		 pop	 esi
  00062	5b		 pop	 ebx
  00063	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00069	3b ec		 cmp	 ebp, esp
  0006b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00070	8b e5		 mov	 esp, ebp
  00072	5d		 pop	 ebp
  00073	c3		 ret	 0
_glm_vec3_zero ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Light\source\repos\3DRendC\include\vec3.h
;	COMDAT _glm_vec3_copy
_TEXT	SEGMENT
_a$ = 8							; size = 4
_dest$ = 12						; size = 4
_glm_vec3_copy PROC					; COMDAT

; 146  : glm_vec3_copy(vec3 a, vec3 dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __82F46937_vec3@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 147  :   dest[0] = a[0];

  00028	b8 04 00 00 00	 mov	 eax, 4
  0002d	6b c8 00	 imul	 ecx, eax, 0
  00030	ba 04 00 00 00	 mov	 edx, 4
  00035	6b c2 00	 imul	 eax, edx, 0
  00038	8b 55 0c	 mov	 edx, DWORD PTR _dest$[ebp]
  0003b	8b 75 08	 mov	 esi, DWORD PTR _a$[ebp]
  0003e	8b 0c 0e	 mov	 ecx, DWORD PTR [esi+ecx]
  00041	89 0c 02	 mov	 DWORD PTR [edx+eax], ecx

; 148  :   dest[1] = a[1];

  00044	b8 04 00 00 00	 mov	 eax, 4
  00049	c1 e0 00	 shl	 eax, 0
  0004c	b9 04 00 00 00	 mov	 ecx, 4
  00051	c1 e1 00	 shl	 ecx, 0
  00054	8b 55 0c	 mov	 edx, DWORD PTR _dest$[ebp]
  00057	8b 75 08	 mov	 esi, DWORD PTR _a$[ebp]
  0005a	8b 04 06	 mov	 eax, DWORD PTR [esi+eax]
  0005d	89 04 0a	 mov	 DWORD PTR [edx+ecx], eax

; 149  :   dest[2] = a[2];

  00060	b8 04 00 00 00	 mov	 eax, 4
  00065	d1 e0		 shl	 eax, 1
  00067	b9 04 00 00 00	 mov	 ecx, 4
  0006c	d1 e1		 shl	 ecx, 1
  0006e	8b 55 0c	 mov	 edx, DWORD PTR _dest$[ebp]
  00071	8b 75 08	 mov	 esi, DWORD PTR _a$[ebp]
  00074	8b 04 06	 mov	 eax, DWORD PTR [esi+eax]
  00077	89 04 0a	 mov	 DWORD PTR [edx+ecx], eax

; 150  : }

  0007a	5f		 pop	 edi
  0007b	5e		 pop	 esi
  0007c	5b		 pop	 ebx
  0007d	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00083	3b ec		 cmp	 ebp, esp
  00085	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0008a	8b e5		 mov	 esp, ebp
  0008c	5d		 pop	 ebp
  0008d	c3		 ret	 0
_glm_vec3_copy ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Light\source\repos\3DRendC\include\vec3.h
;	COMDAT _glm_vec3
_TEXT	SEGMENT
_v4$ = 8						; size = 4
_dest$ = 12						; size = 4
_glm_vec3 PROC						; COMDAT

; 132  : glm_vec3(vec4 v4, vec3 dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __82F46937_vec3@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 133  :   dest[0] = v4[0];

  00028	b8 04 00 00 00	 mov	 eax, 4
  0002d	6b c8 00	 imul	 ecx, eax, 0
  00030	ba 04 00 00 00	 mov	 edx, 4
  00035	6b c2 00	 imul	 eax, edx, 0
  00038	8b 55 0c	 mov	 edx, DWORD PTR _dest$[ebp]
  0003b	8b 75 08	 mov	 esi, DWORD PTR _v4$[ebp]
  0003e	8b 0c 0e	 mov	 ecx, DWORD PTR [esi+ecx]
  00041	89 0c 02	 mov	 DWORD PTR [edx+eax], ecx

; 134  :   dest[1] = v4[1];

  00044	b8 04 00 00 00	 mov	 eax, 4
  00049	c1 e0 00	 shl	 eax, 0
  0004c	b9 04 00 00 00	 mov	 ecx, 4
  00051	c1 e1 00	 shl	 ecx, 0
  00054	8b 55 0c	 mov	 edx, DWORD PTR _dest$[ebp]
  00057	8b 75 08	 mov	 esi, DWORD PTR _v4$[ebp]
  0005a	8b 04 06	 mov	 eax, DWORD PTR [esi+eax]
  0005d	89 04 0a	 mov	 DWORD PTR [edx+ecx], eax

; 135  :   dest[2] = v4[2];

  00060	b8 04 00 00 00	 mov	 eax, 4
  00065	d1 e0		 shl	 eax, 1
  00067	b9 04 00 00 00	 mov	 ecx, 4
  0006c	d1 e1		 shl	 ecx, 1
  0006e	8b 55 0c	 mov	 edx, DWORD PTR _dest$[ebp]
  00071	8b 75 08	 mov	 esi, DWORD PTR _v4$[ebp]
  00074	8b 04 06	 mov	 eax, DWORD PTR [esi+eax]
  00077	89 04 0a	 mov	 DWORD PTR [edx+ecx], eax

; 136  : }

  0007a	5f		 pop	 edi
  0007b	5e		 pop	 esi
  0007c	5b		 pop	 ebx
  0007d	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00083	3b ec		 cmp	 ebp, esp
  00085	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0008a	8b e5		 mov	 esp, ebp
  0008c	5d		 pop	 ebp
  0008d	c3		 ret	 0
_glm_vec3 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Light\source\repos\3DRendC\include\vec4.h
;	COMDAT _glm_vec4_lerpc
_TEXT	SEGMENT
_from$ = 8						; size = 4
_to$ = 12						; size = 4
_t$ = 16						; size = 4
_dest$ = 20						; size = 4
_glm_vec4_lerpc PROC					; COMDAT

; 897  : glm_vec4_lerpc(vec4 from, vec4 to, float t, vec4 dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __87BB7FB2_vec4@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 898  :   glm_vec4_lerp(from, to, glm_clamp_zo(t), dest);

  00028	8b 45 14	 mov	 eax, DWORD PTR _dest$[ebp]
  0002b	50		 push	 eax
  0002c	51		 push	 ecx
  0002d	f3 0f 10 45 10	 movss	 xmm0, DWORD PTR _t$[ebp]
  00032	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00037	e8 00 00 00 00	 call	 _glm_clamp_zo
  0003c	d9 1c 24	 fstp	 DWORD PTR [esp]
  0003f	8b 4d 0c	 mov	 ecx, DWORD PTR _to$[ebp]
  00042	51		 push	 ecx
  00043	8b 55 08	 mov	 edx, DWORD PTR _from$[ebp]
  00046	52		 push	 edx
  00047	e8 00 00 00 00	 call	 _glm_vec4_lerp
  0004c	83 c4 10	 add	 esp, 16			; 00000010H

; 899  : }

  0004f	5f		 pop	 edi
  00050	5e		 pop	 esi
  00051	5b		 pop	 ebx
  00052	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00058	3b ec		 cmp	 ebp, esp
  0005a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005f	8b e5		 mov	 esp, ebp
  00061	5d		 pop	 ebp
  00062	c3		 ret	 0
_glm_vec4_lerpc ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Light\source\repos\3DRendC\include\vec4.h
;	COMDAT _glm_vec4_lerp
_TEXT	SEGMENT
_v$ = -64						; size = 16
_s$ = -32						; size = 16
__$ArrayPad$ = -4					; size = 4
_from$ = 8						; size = 4
_to$ = 12						; size = 4
_t$ = 16						; size = 4
_dest$ = 20						; size = 4
_glm_vec4_lerp PROC					; COMDAT

; 875  : glm_vec4_lerp(vec4 from, vec4 to, float t, vec4 dest) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 f0	 and	 esp, -16		; fffffff0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec 08 01 00
	00		 sub	 esp, 264		; 00000108H
  0001c	56		 push	 esi
  0001d	57		 push	 edi
  0001e	8d bd f8 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-264]
  00024	b9 42 00 00 00	 mov	 ecx, 66			; 00000042H
  00029	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002e	f3 ab		 rep stosd
  00030	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00035	33 c5		 xor	 eax, ebp
  00037	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0003a	b9 00 00 00 00	 mov	 ecx, OFFSET __87BB7FB2_vec4@h
  0003f	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 876  :   vec4 s, v;
; 877  : 
; 878  :   /* from + s * (to - from) */
; 879  :   glm_vec4_broadcast(t, s);

  00044	8d 45 e0	 lea	 eax, DWORD PTR _s$[ebp]
  00047	50		 push	 eax
  00048	51		 push	 ecx
  00049	f3 0f 10 43 10	 movss	 xmm0, DWORD PTR _t$[ebx]
  0004e	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00053	e8 00 00 00 00	 call	 _glm_vec4_broadcast
  00058	83 c4 08	 add	 esp, 8

; 880  :   glm_vec4_sub(to, from, v);

  0005b	8d 45 c0	 lea	 eax, DWORD PTR _v$[ebp]
  0005e	50		 push	 eax
  0005f	8b 4b 08	 mov	 ecx, DWORD PTR _from$[ebx]
  00062	51		 push	 ecx
  00063	8b 53 0c	 mov	 edx, DWORD PTR _to$[ebx]
  00066	52		 push	 edx
  00067	e8 00 00 00 00	 call	 _glm_vec4_sub
  0006c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 881  :   glm_vec4_mul(s, v, v);

  0006f	8d 45 c0	 lea	 eax, DWORD PTR _v$[ebp]
  00072	50		 push	 eax
  00073	8d 4d c0	 lea	 ecx, DWORD PTR _v$[ebp]
  00076	51		 push	 ecx
  00077	8d 55 e0	 lea	 edx, DWORD PTR _s$[ebp]
  0007a	52		 push	 edx
  0007b	e8 00 00 00 00	 call	 _glm_vec4_mul
  00080	83 c4 0c	 add	 esp, 12			; 0000000cH

; 882  :   glm_vec4_add(from, v, dest);

  00083	8b 43 14	 mov	 eax, DWORD PTR _dest$[ebx]
  00086	50		 push	 eax
  00087	8d 4d c0	 lea	 ecx, DWORD PTR _v$[ebp]
  0008a	51		 push	 ecx
  0008b	8b 53 08	 mov	 edx, DWORD PTR _from$[ebx]
  0008e	52		 push	 edx
  0008f	e8 00 00 00 00	 call	 _glm_vec4_add
  00094	83 c4 0c	 add	 esp, 12			; 0000000cH

; 883  : }

  00097	52		 push	 edx
  00098	8b cd		 mov	 ecx, ebp
  0009a	50		 push	 eax
  0009b	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN6@glm_vec4_l
  000a1	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  000a6	58		 pop	 eax
  000a7	5a		 pop	 edx
  000a8	5f		 pop	 edi
  000a9	5e		 pop	 esi
  000aa	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000ad	33 cd		 xor	 ecx, ebp
  000af	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000b4	8b e5		 mov	 esp, ebp
  000b6	5d		 pop	 ebp
  000b7	8b e3		 mov	 esp, ebx
  000b9	5b		 pop	 ebx
  000ba	c3		 ret	 0
  000bb	90		 npad	 1
$LN6@glm_vec4_l:
  000bc	02 00 00 00	 DD	 2
  000c0	00 00 00 00	 DD	 $LN5@glm_vec4_l
$LN5@glm_vec4_l:
  000c4	e0 ff ff ff	 DD	 -32			; ffffffe0H
  000c8	10 00 00 00	 DD	 16			; 00000010H
  000cc	00 00 00 00	 DD	 $LN3@glm_vec4_l
  000d0	c0 ff ff ff	 DD	 -64			; ffffffc0H
  000d4	10 00 00 00	 DD	 16			; 00000010H
  000d8	00 00 00 00	 DD	 $LN4@glm_vec4_l
$LN4@glm_vec4_l:
  000dc	76		 DB	 118			; 00000076H
  000dd	00		 DB	 0
$LN3@glm_vec4_l:
  000de	73		 DB	 115			; 00000073H
  000df	00		 DB	 0
_glm_vec4_lerp ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Light\source\repos\3DRendC\include\vec4.h
;	COMDAT _glm_vec4_negate
_TEXT	SEGMENT
_v$ = 8							; size = 4
_glm_vec4_negate PROC					; COMDAT

; 699  : glm_vec4_negate(vec4 v) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __87BB7FB2_vec4@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 700  :   glm_vec4_negate_to(v, v);

  00028	8b 45 08	 mov	 eax, DWORD PTR _v$[ebp]
  0002b	50		 push	 eax
  0002c	8b 4d 08	 mov	 ecx, DWORD PTR _v$[ebp]
  0002f	51		 push	 ecx
  00030	e8 00 00 00 00	 call	 _glm_vec4_negate_to
  00035	83 c4 08	 add	 esp, 8

; 701  : }

  00038	5f		 pop	 edi
  00039	5e		 pop	 esi
  0003a	5b		 pop	 ebx
  0003b	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00041	3b ec		 cmp	 ebp, esp
  00043	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00048	8b e5		 mov	 esp, ebp
  0004a	5d		 pop	 ebp
  0004b	c3		 ret	 0
_glm_vec4_negate ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Light\source\repos\3DRendC\include\vec4.h
;	COMDAT _glm_vec4_negate_to
_TEXT	SEGMENT
_v$ = 8							; size = 4
_dest$ = 12						; size = 4
_glm_vec4_negate_to PROC				; COMDAT

; 679  : glm_vec4_negate_to(vec4 v, vec4 dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __87BB7FB2_vec4@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 680  : #if defined( __SSE__ ) || defined( __SSE2__ )
; 681  :   glmm_store(dest, _mm_xor_ps(glmm_load(v), _mm_set1_ps(-0.0f)));

  00028	8b 45 08	 mov	 eax, DWORD PTR _v$[ebp]
  0002b	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  0002e	0f 57 05 00 00
	00 00		 xorps	 xmm0, XMMWORD PTR __xmm@80000000800000008000000080000000
  00035	8b 4d 0c	 mov	 ecx, DWORD PTR _dest$[ebp]
  00038	0f 11 01	 movups	 XMMWORD PTR [ecx], xmm0

; 682  : #elif defined(CGLM_NEON_FP)
; 683  :   vst1q_f32(dest, vnegq_f32(vld1q_f32(v)));
; 684  : #else
; 685  :   dest[0] = -v[0];
; 686  :   dest[1] = -v[1];
; 687  :   dest[2] = -v[2];
; 688  :   dest[3] = -v[3];
; 689  : #endif
; 690  : }

  0003b	5f		 pop	 edi
  0003c	5e		 pop	 esi
  0003d	5b		 pop	 ebx
  0003e	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00044	3b ec		 cmp	 ebp, esp
  00046	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004b	8b e5		 mov	 esp, ebp
  0004d	5d		 pop	 ebp
  0004e	c3		 ret	 0
_glm_vec4_negate_to ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Light\source\repos\3DRendC\include\vec4.h
;	COMDAT _glm_vec4_scale
_TEXT	SEGMENT
_v$ = 8							; size = 4
_s$ = 12						; size = 4
_dest$ = 16						; size = 4
_glm_vec4_scale PROC					; COMDAT

; 432  : glm_vec4_scale(vec4 v, float s, vec4 dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __87BB7FB2_vec4@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 433  : #if defined( __SSE__ ) || defined( __SSE2__ )
; 434  :   glmm_store(dest, _mm_mul_ps(glmm_load(v), _mm_set1_ps(s)));

  00028	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _s$[ebp]
  0002d	0f c6 c0 00	 shufps	 xmm0, xmm0, 0
  00031	8b 45 08	 mov	 eax, DWORD PTR _v$[ebp]
  00034	0f 10 08	 movups	 xmm1, XMMWORD PTR [eax]
  00037	0f 59 c8	 mulps	 xmm1, xmm0
  0003a	8b 4d 10	 mov	 ecx, DWORD PTR _dest$[ebp]
  0003d	0f 11 09	 movups	 XMMWORD PTR [ecx], xmm1

; 435  : #elif defined(CGLM_NEON_FP)
; 436  :   vst1q_f32(dest, vmulq_f32(vld1q_f32(v), vdupq_n_f32(s)));
; 437  : #else
; 438  :   dest[0] = v[0] * s;
; 439  :   dest[1] = v[1] * s;
; 440  :   dest[2] = v[2] * s;
; 441  :   dest[3] = v[3] * s;
; 442  : #endif
; 443  : }

  00040	5f		 pop	 edi
  00041	5e		 pop	 esi
  00042	5b		 pop	 ebx
  00043	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00049	3b ec		 cmp	 ebp, esp
  0004b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00050	8b e5		 mov	 esp, ebp
  00052	5d		 pop	 ebp
  00053	c3		 ret	 0
_glm_vec4_scale ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Light\source\repos\3DRendC\include\vec4.h
;	COMDAT _glm_vec4_mul
_TEXT	SEGMENT
_a$ = 8							; size = 4
_b$ = 12						; size = 4
_dest$ = 16						; size = 4
_glm_vec4_mul PROC					; COMDAT

; 410  : glm_vec4_mul(vec4 a, vec4 b, vec4 dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __87BB7FB2_vec4@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 411  : #if defined( __SSE__ ) || defined( __SSE2__ )
; 412  :   glmm_store(dest, _mm_mul_ps(glmm_load(a), glmm_load(b)));

  00028	8b 45 0c	 mov	 eax, DWORD PTR _b$[ebp]
  0002b	8b 4d 08	 mov	 ecx, DWORD PTR _a$[ebp]
  0002e	0f 10 01	 movups	 xmm0, XMMWORD PTR [ecx]
  00031	0f 59 00	 mulps	 xmm0, XMMWORD PTR [eax]
  00034	8b 55 10	 mov	 edx, DWORD PTR _dest$[ebp]
  00037	0f 11 02	 movups	 XMMWORD PTR [edx], xmm0

; 413  : #elif defined(CGLM_NEON_FP)
; 414  :   vst1q_f32(dest, vmulq_f32(vld1q_f32(a), vld1q_f32(b)));
; 415  : #else
; 416  :   dest[0] = a[0] * b[0];
; 417  :   dest[1] = a[1] * b[1];
; 418  :   dest[2] = a[2] * b[2];
; 419  :   dest[3] = a[3] * b[3];
; 420  : #endif
; 421  : }

  0003a	5f		 pop	 edi
  0003b	5e		 pop	 esi
  0003c	5b		 pop	 ebx
  0003d	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00043	3b ec		 cmp	 ebp, esp
  00045	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004a	8b e5		 mov	 esp, ebp
  0004c	5d		 pop	 ebp
  0004d	c3		 ret	 0
_glm_vec4_mul ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Light\source\repos\3DRendC\include\vec4.h
;	COMDAT _glm_vec4_sub
_TEXT	SEGMENT
_a$ = 8							; size = 4
_b$ = 12						; size = 4
_dest$ = 16						; size = 4
_glm_vec4_sub PROC					; COMDAT

; 366  : glm_vec4_sub(vec4 a, vec4 b, vec4 dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __87BB7FB2_vec4@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 367  : #if defined( __SSE__ ) || defined( __SSE2__ )
; 368  :   glmm_store(dest, _mm_sub_ps(glmm_load(a), glmm_load(b)));

  00028	8b 45 0c	 mov	 eax, DWORD PTR _b$[ebp]
  0002b	8b 4d 08	 mov	 ecx, DWORD PTR _a$[ebp]
  0002e	0f 10 01	 movups	 xmm0, XMMWORD PTR [ecx]
  00031	0f 5c 00	 subps	 xmm0, XMMWORD PTR [eax]
  00034	8b 55 10	 mov	 edx, DWORD PTR _dest$[ebp]
  00037	0f 11 02	 movups	 XMMWORD PTR [edx], xmm0

; 369  : #elif defined(CGLM_NEON_FP)
; 370  :   vst1q_f32(dest, vsubq_f32(vld1q_f32(a), vld1q_f32(b)));
; 371  : #else
; 372  :   dest[0] = a[0] - b[0];
; 373  :   dest[1] = a[1] - b[1];
; 374  :   dest[2] = a[2] - b[2];
; 375  :   dest[3] = a[3] - b[3];
; 376  : #endif
; 377  : }

  0003a	5f		 pop	 edi
  0003b	5e		 pop	 esi
  0003c	5b		 pop	 ebx
  0003d	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00043	3b ec		 cmp	 ebp, esp
  00045	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004a	8b e5		 mov	 esp, ebp
  0004c	5d		 pop	 ebp
  0004d	c3		 ret	 0
_glm_vec4_sub ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Light\source\repos\3DRendC\include\vec4.h
;	COMDAT _glm_vec4_add
_TEXT	SEGMENT
_a$ = 8							; size = 4
_b$ = 12						; size = 4
_dest$ = 16						; size = 4
_glm_vec4_add PROC					; COMDAT

; 322  : glm_vec4_add(vec4 a, vec4 b, vec4 dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __87BB7FB2_vec4@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 323  : #if defined( __SSE__ ) || defined( __SSE2__ )
; 324  :   glmm_store(dest, _mm_add_ps(glmm_load(a), glmm_load(b)));

  00028	8b 45 0c	 mov	 eax, DWORD PTR _b$[ebp]
  0002b	8b 4d 08	 mov	 ecx, DWORD PTR _a$[ebp]
  0002e	0f 10 01	 movups	 xmm0, XMMWORD PTR [ecx]
  00031	0f 58 00	 addps	 xmm0, XMMWORD PTR [eax]
  00034	8b 55 10	 mov	 edx, DWORD PTR _dest$[ebp]
  00037	0f 11 02	 movups	 XMMWORD PTR [edx], xmm0

; 325  : #elif defined(CGLM_NEON_FP)
; 326  :   vst1q_f32(dest, vaddq_f32(vld1q_f32(a), vld1q_f32(b)));
; 327  : #else
; 328  :   dest[0] = a[0] + b[0];
; 329  :   dest[1] = a[1] + b[1];
; 330  :   dest[2] = a[2] + b[2];
; 331  :   dest[3] = a[3] + b[3];
; 332  : #endif
; 333  : }

  0003a	5f		 pop	 edi
  0003b	5e		 pop	 esi
  0003c	5b		 pop	 ebx
  0003d	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00043	3b ec		 cmp	 ebp, esp
  00045	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004a	8b e5		 mov	 esp, ebp
  0004c	5d		 pop	 ebp
  0004d	c3		 ret	 0
_glm_vec4_add ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Light\source\repos\3DRendC\include\vec4.h
;	COMDAT _glm_vec4_norm
_TEXT	SEGMENT
_v$ = 8							; size = 4
_glm_vec4_norm PROC					; COMDAT

; 254  : glm_vec4_norm(vec4 v) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __87BB7FB2_vec4@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 255  : #if defined(CGLM_SIMD)
; 256  :   return glmm_norm(glmm_load(v));

  00028	8b 45 08	 mov	 eax, DWORD PTR _v$[ebp]
  0002b	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  0002e	e8 00 00 00 00	 call	 _glmm_norm

; 257  : #else
; 258  :   return sqrtf(glm_vec4_dot(v, v));
; 259  : #endif
; 260  : }

  00033	5f		 pop	 edi
  00034	5e		 pop	 esi
  00035	5b		 pop	 ebx
  00036	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0003c	3b ec		 cmp	 ebp, esp
  0003e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00043	8b e5		 mov	 esp, ebp
  00045	5d		 pop	 ebp
  00046	c3		 ret	 0
_glm_vec4_norm ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Light\source\repos\3DRendC\include\vec4.h
;	COMDAT _glm_vec4_norm2
_TEXT	SEGMENT
_v$ = 8							; size = 4
_glm_vec4_norm2 PROC					; COMDAT

; 240  : glm_vec4_norm2(vec4 v) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __87BB7FB2_vec4@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 241  :   return glm_vec4_dot(v, v);

  00028	8b 45 08	 mov	 eax, DWORD PTR _v$[ebp]
  0002b	50		 push	 eax
  0002c	8b 4d 08	 mov	 ecx, DWORD PTR _v$[ebp]
  0002f	51		 push	 ecx
  00030	e8 00 00 00 00	 call	 _glm_vec4_dot
  00035	83 c4 08	 add	 esp, 8

; 242  : }

  00038	5f		 pop	 edi
  00039	5e		 pop	 esi
  0003a	5b		 pop	 ebx
  0003b	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00041	3b ec		 cmp	 ebp, esp
  00043	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00048	8b e5		 mov	 esp, ebp
  0004a	5d		 pop	 ebp
  0004b	c3		 ret	 0
_glm_vec4_norm2 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Light\source\repos\3DRendC\include\vec4.h
;	COMDAT _glm_vec4_dot
_TEXT	SEGMENT
_a$ = 8							; size = 4
_b$ = 12						; size = 4
_glm_vec4_dot PROC					; COMDAT

; 219  : glm_vec4_dot(vec4 a, vec4 b) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __87BB7FB2_vec4@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 220  : #if defined(CGLM_SIMD)
; 221  :   return glmm_dot(glmm_load(a), glmm_load(b));

  00028	8b 45 0c	 mov	 eax, DWORD PTR _b$[ebp]
  0002b	0f 10 08	 movups	 xmm1, XMMWORD PTR [eax]
  0002e	8b 4d 08	 mov	 ecx, DWORD PTR _a$[ebp]
  00031	0f 10 01	 movups	 xmm0, XMMWORD PTR [ecx]
  00034	e8 00 00 00 00	 call	 _glmm_dot

; 222  : #else
; 223  :   return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];
; 224  : #endif
; 225  : }

  00039	5f		 pop	 edi
  0003a	5e		 pop	 esi
  0003b	5b		 pop	 ebx
  0003c	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00042	3b ec		 cmp	 ebp, esp
  00044	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00049	8b e5		 mov	 esp, ebp
  0004b	5d		 pop	 ebp
  0004c	c3		 ret	 0
_glm_vec4_dot ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Light\source\repos\3DRendC\include\vec4.h
;	COMDAT _glm_vec4_copy
_TEXT	SEGMENT
_v$ = 8							; size = 4
_dest$ = 12						; size = 4
_glm_vec4_copy PROC					; COMDAT

; 139  : glm_vec4_copy(vec4 v, vec4 dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __87BB7FB2_vec4@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 140  : #if defined( __SSE__ ) || defined( __SSE2__ )
; 141  :   glmm_store(dest, glmm_load(v));

  00028	8b 45 08	 mov	 eax, DWORD PTR _v$[ebp]
  0002b	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  0002e	8b 4d 0c	 mov	 ecx, DWORD PTR _dest$[ebp]
  00031	0f 11 01	 movups	 XMMWORD PTR [ecx], xmm0

; 142  : #elif defined(CGLM_NEON_FP)
; 143  :   vst1q_f32(dest, vld1q_f32(v));
; 144  : #else
; 145  :   dest[0] = v[0];
; 146  :   dest[1] = v[1];
; 147  :   dest[2] = v[2];
; 148  :   dest[3] = v[3];
; 149  : #endif
; 150  : }

  00034	5f		 pop	 edi
  00035	5e		 pop	 esi
  00036	5b		 pop	 ebx
  00037	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0003d	3b ec		 cmp	 ebp, esp
  0003f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00044	8b e5		 mov	 esp, ebp
  00046	5d		 pop	 ebp
  00047	c3		 ret	 0
_glm_vec4_copy ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Light\source\repos\3DRendC\include\vec4.h
;	COMDAT _glm_vec4
_TEXT	SEGMENT
_v3$ = 8						; size = 4
_last$ = 12						; size = 4
_dest$ = 16						; size = 4
_glm_vec4 PROC						; COMDAT

; 110  : glm_vec4(vec3 v3, float last, vec4 dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __87BB7FB2_vec4@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 111  :   dest[0] = v3[0];

  00028	b8 04 00 00 00	 mov	 eax, 4
  0002d	6b c8 00	 imul	 ecx, eax, 0
  00030	ba 04 00 00 00	 mov	 edx, 4
  00035	6b c2 00	 imul	 eax, edx, 0
  00038	8b 55 10	 mov	 edx, DWORD PTR _dest$[ebp]
  0003b	8b 75 08	 mov	 esi, DWORD PTR _v3$[ebp]
  0003e	8b 0c 0e	 mov	 ecx, DWORD PTR [esi+ecx]
  00041	89 0c 02	 mov	 DWORD PTR [edx+eax], ecx

; 112  :   dest[1] = v3[1];

  00044	b8 04 00 00 00	 mov	 eax, 4
  00049	c1 e0 00	 shl	 eax, 0
  0004c	b9 04 00 00 00	 mov	 ecx, 4
  00051	c1 e1 00	 shl	 ecx, 0
  00054	8b 55 10	 mov	 edx, DWORD PTR _dest$[ebp]
  00057	8b 75 08	 mov	 esi, DWORD PTR _v3$[ebp]
  0005a	8b 04 06	 mov	 eax, DWORD PTR [esi+eax]
  0005d	89 04 0a	 mov	 DWORD PTR [edx+ecx], eax

; 113  :   dest[2] = v3[2];

  00060	b8 04 00 00 00	 mov	 eax, 4
  00065	d1 e0		 shl	 eax, 1
  00067	b9 04 00 00 00	 mov	 ecx, 4
  0006c	d1 e1		 shl	 ecx, 1
  0006e	8b 55 10	 mov	 edx, DWORD PTR _dest$[ebp]
  00071	8b 75 08	 mov	 esi, DWORD PTR _v3$[ebp]
  00074	8b 04 06	 mov	 eax, DWORD PTR [esi+eax]
  00077	89 04 0a	 mov	 DWORD PTR [edx+ecx], eax

; 114  :   dest[3] = last;

  0007a	b8 04 00 00 00	 mov	 eax, 4
  0007f	6b c8 03	 imul	 ecx, eax, 3
  00082	8b 55 10	 mov	 edx, DWORD PTR _dest$[ebp]
  00085	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _last$[ebp]
  0008a	f3 0f 11 04 0a	 movss	 DWORD PTR [edx+ecx], xmm0

; 115  : }

  0008f	5f		 pop	 edi
  00090	5e		 pop	 esi
  00091	5b		 pop	 ebx
  00092	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00098	3b ec		 cmp	 ebp, esp
  0009a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0009f	8b e5		 mov	 esp, ebp
  000a1	5d		 pop	 ebp
  000a2	c3		 ret	 0
_glm_vec4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Light\source\repos\3DRendC\include\vec4-ext.h
;	COMDAT _glm_vec4_broadcast
_TEXT	SEGMENT
_val$ = 8						; size = 4
_d$ = 12						; size = 4
_glm_vec4_broadcast PROC				; COMDAT

; 47   : glm_vec4_broadcast(float val, vec4 d) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __5722D62A_vec4-ext@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 48   : #if defined( __SSE__ ) || defined( __SSE2__ )
; 49   :   glmm_store(d, _mm_set1_ps(val));

  00028	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR _val$[ebp]
  0002d	0f c6 c0 00	 shufps	 xmm0, xmm0, 0
  00031	8b 45 0c	 mov	 eax, DWORD PTR _d$[ebp]
  00034	0f 11 00	 movups	 XMMWORD PTR [eax], xmm0

; 50   : #else
; 51   :   d[0] = d[1] = d[2] = d[3] = val;
; 52   : #endif
; 53   : }

  00037	5f		 pop	 edi
  00038	5e		 pop	 esi
  00039	5b		 pop	 ebx
  0003a	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00040	3b ec		 cmp	 ebp, esp
  00042	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00047	8b e5		 mov	 esp, ebp
  00049	5d		 pop	 ebp
  0004a	c3		 ret	 0
_glm_vec4_broadcast ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Light\source\repos\3DRendC\include\util.h
;	COMDAT _glm_clamp_zo
_TEXT	SEGMENT
_val$ = 8						; size = 4
_glm_clamp_zo PROC					; COMDAT

; 170  : glm_clamp_zo(float val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __51BD2C42_util@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 171  :   return glm_clamp(val, 0.0f, 1.0f);

  00028	51		 push	 ecx
  00029	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00031	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00036	51		 push	 ecx
  00037	0f 57 c0	 xorps	 xmm0, xmm0
  0003a	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0003f	51		 push	 ecx
  00040	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR _val$[ebp]
  00045	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0004a	e8 00 00 00 00	 call	 _glm_clamp
  0004f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 172  : }

  00052	5f		 pop	 edi
  00053	5e		 pop	 esi
  00054	5b		 pop	 ebx
  00055	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0005b	3b ec		 cmp	 ebp, esp
  0005d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00062	8b e5		 mov	 esp, ebp
  00064	5d		 pop	 ebp
  00065	c3		 ret	 0
_glm_clamp_zo ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Light\source\repos\3DRendC\include\util.h
;	COMDAT _glm_clamp
_TEXT	SEGMENT
_val$ = 8						; size = 4
_minVal$ = 12						; size = 4
_maxVal$ = 16						; size = 4
_glm_clamp PROC						; COMDAT

; 159  : glm_clamp(float val, float minVal, float maxVal) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __51BD2C42_util@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 160  :   return glm_min(glm_max(val, minVal), maxVal);

  00028	51		 push	 ecx
  00029	f3 0f 10 45 10	 movss	 xmm0, DWORD PTR _maxVal$[ebp]
  0002e	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00033	51		 push	 ecx
  00034	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _minVal$[ebp]
  00039	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0003e	51		 push	 ecx
  0003f	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR _val$[ebp]
  00044	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00049	e8 00 00 00 00	 call	 _glm_max
  0004e	83 c4 04	 add	 esp, 4
  00051	d9 1c 24	 fstp	 DWORD PTR [esp]
  00054	e8 00 00 00 00	 call	 _glm_min
  00059	83 c4 08	 add	 esp, 8

; 161  : }

  0005c	5f		 pop	 edi
  0005d	5e		 pop	 esi
  0005e	5b		 pop	 ebx
  0005f	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00065	3b ec		 cmp	 ebp, esp
  00067	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0006c	8b e5		 mov	 esp, ebp
  0006e	5d		 pop	 ebp
  0006f	c3		 ret	 0
_glm_clamp ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Light\source\repos\3DRendC\include\util.h
;	COMDAT _glm_max
_TEXT	SEGMENT
_a$ = 8							; size = 4
_b$ = 12						; size = 4
_glm_max PROC						; COMDAT

; 144  : glm_max(float a, float b) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __51BD2C42_util@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 145  :   if (a > b)

  00028	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR _a$[ebp]
  0002d	0f 2f 45 0c	 comiss	 xmm0, DWORD PTR _b$[ebp]
  00031	76 05		 jbe	 SHORT $LN2@glm_max

; 146  :     return a;

  00033	d9 45 08	 fld	 DWORD PTR _a$[ebp]
  00036	eb 03		 jmp	 SHORT $LN1@glm_max
$LN2@glm_max:

; 147  :   return b;

  00038	d9 45 0c	 fld	 DWORD PTR _b$[ebp]
$LN1@glm_max:

; 148  : }

  0003b	5f		 pop	 edi
  0003c	5e		 pop	 esi
  0003d	5b		 pop	 ebx
  0003e	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00044	3b ec		 cmp	 ebp, esp
  00046	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004b	8b e5		 mov	 esp, ebp
  0004d	5d		 pop	 ebp
  0004e	c3		 ret	 0
_glm_max ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Light\source\repos\3DRendC\include\util.h
;	COMDAT _glm_min
_TEXT	SEGMENT
_a$ = 8							; size = 4
_b$ = 12						; size = 4
_glm_min PROC						; COMDAT

; 130  : glm_min(float a, float b) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __51BD2C42_util@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 131  :   if (a < b)

  00028	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _b$[ebp]
  0002d	0f 2f 45 08	 comiss	 xmm0, DWORD PTR _a$[ebp]
  00031	76 05		 jbe	 SHORT $LN2@glm_min

; 132  :     return a;

  00033	d9 45 08	 fld	 DWORD PTR _a$[ebp]
  00036	eb 03		 jmp	 SHORT $LN1@glm_min
$LN2@glm_min:

; 133  :   return b;

  00038	d9 45 0c	 fld	 DWORD PTR _b$[ebp]
$LN1@glm_min:

; 134  : }

  0003b	5f		 pop	 edi
  0003c	5e		 pop	 esi
  0003d	5b		 pop	 ebx
  0003e	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00044	3b ec		 cmp	 ebp, esp
  00046	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004b	8b e5		 mov	 esp, ebp
  0004d	5d		 pop	 ebp
  0004e	c3		 ret	 0
_glm_min ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Light\source\repos\3DRendC\include\simd\x86.h
;	COMDAT _glmm_norm
_TEXT	SEGMENT
tv73 = -232						; size = 4
_a$ = -32						; size = 16
_glmm_norm PROC						; COMDAT
; _a$ = xmm0

; 150  : glmm_norm(__m128 a) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 f0	 and	 esp, -16		; fffffff0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec e8 00 00
	00		 sub	 esp, 232		; 000000e8H
  0001c	56		 push	 esi
  0001d	57		 push	 edi
  0001e	8d bd 18 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-232]
  00024	b9 3a 00 00 00	 mov	 ecx, 58			; 0000003aH
  00029	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002e	f3 ab		 rep stosd
  00030	0f 29 45 e0	 movaps	 XMMWORD PTR _a$[ebp], xmm0
  00034	b9 00 00 00 00	 mov	 ecx, OFFSET __D164993B_x86@h
  00039	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 151  :   return _mm_cvtss_f32(_mm_sqrt_ss(glmm_vhadds(_mm_mul_ps(a, a))));

  0003e	0f 28 45 e0	 movaps	 xmm0, XMMWORD PTR _a$[ebp]
  00042	0f 59 45 e0	 mulps	 xmm0, XMMWORD PTR _a$[ebp]
  00046	e8 00 00 00 00	 call	 _glmm_vhadds
  0004b	f3 0f 51 c0	 sqrtss	 xmm0, xmm0
  0004f	f3 0f 11 85 18
	ff ff ff	 movss	 DWORD PTR tv73[ebp], xmm0
  00057	d9 85 18 ff ff
	ff		 fld	 DWORD PTR tv73[ebp]

; 152  : }

  0005d	5f		 pop	 edi
  0005e	5e		 pop	 esi
  0005f	8b e5		 mov	 esp, ebp
  00061	5d		 pop	 ebp
  00062	8b e3		 mov	 esp, ebx
  00064	5b		 pop	 ebx
  00065	c3		 ret	 0
_glmm_norm ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Light\source\repos\3DRendC\include\simd\x86.h
;	COMDAT _glmm_dot
_TEXT	SEGMENT
tv69 = -264						; size = 4
_b$ = -64						; size = 16
_a$ = -32						; size = 16
_glmm_dot PROC						; COMDAT
; _a$ = xmm0
; _b$ = xmm1

; 144  : glmm_dot(__m128 a, __m128 b) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 f0	 and	 esp, -16		; fffffff0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec 08 01 00
	00		 sub	 esp, 264		; 00000108H
  0001c	56		 push	 esi
  0001d	57		 push	 edi
  0001e	8d bd f8 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-264]
  00024	b9 42 00 00 00	 mov	 ecx, 66			; 00000042H
  00029	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002e	f3 ab		 rep stosd
  00030	0f 29 4d c0	 movaps	 XMMWORD PTR _b$[ebp], xmm1
  00034	0f 29 45 e0	 movaps	 XMMWORD PTR _a$[ebp], xmm0
  00038	b9 00 00 00 00	 mov	 ecx, OFFSET __D164993B_x86@h
  0003d	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 145  :   return _mm_cvtss_f32(glmm_vdots(a, b));

  00042	0f 28 4d c0	 movaps	 xmm1, XMMWORD PTR _b$[ebp]
  00046	0f 28 45 e0	 movaps	 xmm0, XMMWORD PTR _a$[ebp]
  0004a	e8 00 00 00 00	 call	 _glmm_vdots
  0004f	f3 0f 11 85 f8
	fe ff ff	 movss	 DWORD PTR tv69[ebp], xmm0
  00057	d9 85 f8 fe ff
	ff		 fld	 DWORD PTR tv69[ebp]

; 146  : }

  0005d	5f		 pop	 edi
  0005e	5e		 pop	 esi
  0005f	8b e5		 mov	 esp, ebp
  00061	5d		 pop	 ebp
  00062	8b e3		 mov	 esp, ebx
  00064	5b		 pop	 ebx
  00065	c3		 ret	 0
_glmm_dot ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Light\source\repos\3DRendC\include\simd\x86.h
;	COMDAT _glmm_vdot
_TEXT	SEGMENT
_x0$ = -96						; size = 16
_b$ = -64						; size = 16
_a$ = -32						; size = 16
_glmm_vdot PROC						; COMDAT
; _a$ = xmm0
; _b$ = xmm1

; 126  : glmm_vdot(__m128 a, __m128 b) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 f0	 and	 esp, -16		; fffffff0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec 28 01 00
	00		 sub	 esp, 296		; 00000128H
  0001c	56		 push	 esi
  0001d	57		 push	 edi
  0001e	8d bd d8 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-296]
  00024	b9 4a 00 00 00	 mov	 ecx, 74			; 0000004aH
  00029	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002e	f3 ab		 rep stosd
  00030	0f 29 4d c0	 movaps	 XMMWORD PTR _b$[ebp], xmm1
  00034	0f 29 45 e0	 movaps	 XMMWORD PTR _a$[ebp], xmm0
  00038	b9 00 00 00 00	 mov	 ecx, OFFSET __D164993B_x86@h
  0003d	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 127  : #if (defined(__SSE4_1__) || defined(__SSE4_2__)) && defined(CGLM_SSE4_DOT)
; 128  :   return _mm_dp_ps(a, b, 0xFF);
; 129  : #elif defined(__SSE3__) && defined(CGLM_SSE3_DOT)
; 130  :   __m128 x0, x1;
; 131  :   x0 = _mm_mul_ps(a, b);
; 132  :   x1 = _mm_hadd_ps(x0, x0);
; 133  :   return _mm_hadd_ps(x1, x1);
; 134  : #else
; 135  :   __m128 x0;
; 136  :   x0 = _mm_mul_ps(a, b);

  00042	0f 28 45 e0	 movaps	 xmm0, XMMWORD PTR _a$[ebp]
  00046	0f 59 45 c0	 mulps	 xmm0, XMMWORD PTR _b$[ebp]
  0004a	0f 29 45 a0	 movaps	 XMMWORD PTR _x0$[ebp], xmm0

; 137  :   x0 = _mm_add_ps(x0, glmm_shuff1(x0, 1, 0, 3, 2));

  0004e	0f 28 45 a0	 movaps	 xmm0, XMMWORD PTR _x0$[ebp]
  00052	0f c6 45 a0 4e	 shufps	 xmm0, XMMWORD PTR _x0$[ebp], 78 ; 0000004eH
  00057	0f 28 4d a0	 movaps	 xmm1, XMMWORD PTR _x0$[ebp]
  0005b	0f 58 c8	 addps	 xmm1, xmm0
  0005e	0f 29 4d a0	 movaps	 XMMWORD PTR _x0$[ebp], xmm1

; 138  :   return _mm_add_ps(x0, glmm_shuff1(x0, 0, 1, 0, 1));

  00062	0f 28 45 a0	 movaps	 xmm0, XMMWORD PTR _x0$[ebp]
  00066	0f c6 45 a0 11	 shufps	 xmm0, XMMWORD PTR _x0$[ebp], 17 ; 00000011H
  0006b	0f 28 4d a0	 movaps	 xmm1, XMMWORD PTR _x0$[ebp]
  0006f	0f 58 c8	 addps	 xmm1, xmm0
  00072	0f 28 c1	 movaps	 xmm0, xmm1

; 139  : #endif
; 140  : }

  00075	5f		 pop	 edi
  00076	5e		 pop	 esi
  00077	8b e5		 mov	 esp, ebp
  00079	5d		 pop	 ebp
  0007a	8b e3		 mov	 esp, ebx
  0007c	5b		 pop	 ebx
  0007d	c3		 ret	 0
_glmm_vdot ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Light\source\repos\3DRendC\include\simd\x86.h
;	COMDAT _glmm_vdots
_TEXT	SEGMENT
_b$ = -64						; size = 16
_a$ = -32						; size = 16
_glmm_vdots PROC					; COMDAT
; _a$ = xmm0
; _b$ = xmm1

; 111  : glmm_vdots(__m128 a, __m128 b) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 f0	 and	 esp, -16		; fffffff0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec 08 01 00
	00		 sub	 esp, 264		; 00000108H
  0001c	56		 push	 esi
  0001d	57		 push	 edi
  0001e	8d bd f8 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-264]
  00024	b9 42 00 00 00	 mov	 ecx, 66			; 00000042H
  00029	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002e	f3 ab		 rep stosd
  00030	0f 29 4d c0	 movaps	 XMMWORD PTR _b$[ebp], xmm1
  00034	0f 29 45 e0	 movaps	 XMMWORD PTR _a$[ebp], xmm0
  00038	b9 00 00 00 00	 mov	 ecx, OFFSET __D164993B_x86@h
  0003d	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 112  : #if (defined(__SSE4_1__) || defined(__SSE4_2__)) && defined(CGLM_SSE4_DOT)
; 113  :   return _mm_dp_ps(a, b, 0xFF);
; 114  : #elif defined(__SSE3__) && defined(CGLM_SSE3_DOT)
; 115  :   __m128 x0, x1;
; 116  :   x0 = _mm_mul_ps(a, b);
; 117  :   x1 = _mm_hadd_ps(x0, x0);
; 118  :   return _mm_hadd_ps(x1, x1);
; 119  : #else
; 120  :   return glmm_vhadds(_mm_mul_ps(a, b));

  00042	0f 28 45 e0	 movaps	 xmm0, XMMWORD PTR _a$[ebp]
  00046	0f 59 45 c0	 mulps	 xmm0, XMMWORD PTR _b$[ebp]
  0004a	e8 00 00 00 00	 call	 _glmm_vhadds

; 121  : #endif
; 122  : }

  0004f	5f		 pop	 edi
  00050	5e		 pop	 esi
  00051	8b e5		 mov	 esp, ebp
  00053	5d		 pop	 ebp
  00054	8b e3		 mov	 esp, ebx
  00056	5b		 pop	 ebx
  00057	c3		 ret	 0
_glmm_vdots ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Light\source\repos\3DRendC\include\simd\x86.h
;	COMDAT _glmm_vhadds
_TEXT	SEGMENT
_sums$ = -96						; size = 16
_shuf$ = -64						; size = 16
_v$ = -32						; size = 16
_glmm_vhadds PROC					; COMDAT
; _v$ = xmm0

; 53   : glmm_vhadds(__m128 v) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 f0	 and	 esp, -16		; fffffff0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec 28 01 00
	00		 sub	 esp, 296		; 00000128H
  0001c	56		 push	 esi
  0001d	57		 push	 edi
  0001e	8d bd d8 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-296]
  00024	b9 4a 00 00 00	 mov	 ecx, 74			; 0000004aH
  00029	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002e	f3 ab		 rep stosd
  00030	0f 29 45 e0	 movaps	 XMMWORD PTR _v$[ebp], xmm0
  00034	b9 00 00 00 00	 mov	 ecx, OFFSET __D164993B_x86@h
  00039	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 54   : #if defined(__SSE3__)
; 55   :   __m128 shuf, sums;
; 56   :   shuf = _mm_movehdup_ps(v);
; 57   :   sums = _mm_add_ps(v, shuf);
; 58   :   shuf = _mm_movehl_ps(shuf, sums);
; 59   :   sums = _mm_add_ss(sums, shuf);
; 60   :   return sums;
; 61   : #else
; 62   :   __m128 shuf, sums;
; 63   :   shuf = glmm_shuff1(v, 2, 3, 0, 1);

  0003e	0f 28 45 e0	 movaps	 xmm0, XMMWORD PTR _v$[ebp]
  00042	0f c6 45 e0 b1	 shufps	 xmm0, XMMWORD PTR _v$[ebp], 177 ; 000000b1H
  00047	0f 29 45 c0	 movaps	 XMMWORD PTR _shuf$[ebp], xmm0

; 64   :   sums = _mm_add_ps(v, shuf);

  0004b	0f 28 45 e0	 movaps	 xmm0, XMMWORD PTR _v$[ebp]
  0004f	0f 58 45 c0	 addps	 xmm0, XMMWORD PTR _shuf$[ebp]
  00053	0f 29 45 a0	 movaps	 XMMWORD PTR _sums$[ebp], xmm0

; 65   :   shuf = _mm_movehl_ps(shuf, sums);

  00057	0f 28 45 a0	 movaps	 xmm0, XMMWORD PTR _sums$[ebp]
  0005b	0f 28 4d c0	 movaps	 xmm1, XMMWORD PTR _shuf$[ebp]
  0005f	0f 12 c8	 movhlps xmm1, xmm0
  00062	0f 29 4d c0	 movaps	 XMMWORD PTR _shuf$[ebp], xmm1

; 66   :   sums = _mm_add_ss(sums, shuf);

  00066	0f 28 45 a0	 movaps	 xmm0, XMMWORD PTR _sums$[ebp]
  0006a	f3 0f 58 45 c0	 addss	 xmm0, XMMWORD PTR _shuf$[ebp]
  0006f	0f 29 45 a0	 movaps	 XMMWORD PTR _sums$[ebp], xmm0

; 67   :   return sums;

  00073	0f 28 45 a0	 movaps	 xmm0, XMMWORD PTR _sums$[ebp]

; 68   : #endif
; 69   : }

  00077	5f		 pop	 edi
  00078	5e		 pop	 esi
  00079	8b e5		 mov	 esp, ebp
  0007b	5d		 pop	 ebp
  0007c	8b e3		 mov	 esp, ebx
  0007e	5b		 pop	 ebx
  0007f	c3		 ret	 0
_glmm_vhadds ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_math.h
;	COMDAT _sqrtf
_TEXT	SEGMENT
tv72 = -196						; size = 4
__X$ = 8						; size = 4
_sqrtf	PROC						; COMDAT

; 759  :         {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c4 00 00
	00		 sub	 esp, 196		; 000000c4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 3c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-196]
  00012	b9 31 00 00 00	 mov	 ecx, 49			; 00000031H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __09340588_corecrt_math@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 760  :             return (float)sqrt(_X);

  00028	f3 0f 5a 45 08	 cvtss2sd xmm0, DWORD PTR __X$[ebp]
  0002d	83 ec 08	 sub	 esp, 8
  00030	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00035	e8 00 00 00 00	 call	 _sqrt
  0003a	83 c4 08	 add	 esp, 8
  0003d	d9 9d 3c ff ff
	ff		 fstp	 DWORD PTR tv72[ebp]
  00043	d9 85 3c ff ff
	ff		 fld	 DWORD PTR tv72[ebp]

; 761  :         }

  00049	5f		 pop	 edi
  0004a	5e		 pop	 esi
  0004b	5b		 pop	 ebx
  0004c	81 c4 c4 00 00
	00		 add	 esp, 196		; 000000c4H
  00052	3b ec		 cmp	 ebp, esp
  00054	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00059	8b e5		 mov	 esp, ebp
  0005b	5d		 pop	 ebp
  0005c	c3		 ret	 0
_sqrtf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_math.h
;	COMDAT _sinf
_TEXT	SEGMENT
tv72 = -196						; size = 4
__X$ = 8						; size = 4
_sinf	PROC						; COMDAT

; 749  :         {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c4 00 00
	00		 sub	 esp, 196		; 000000c4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 3c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-196]
  00012	b9 31 00 00 00	 mov	 ecx, 49			; 00000031H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __09340588_corecrt_math@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 750  :             return (float)sin(_X);

  00028	f3 0f 5a 45 08	 cvtss2sd xmm0, DWORD PTR __X$[ebp]
  0002d	83 ec 08	 sub	 esp, 8
  00030	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00035	e8 00 00 00 00	 call	 _sin
  0003a	83 c4 08	 add	 esp, 8
  0003d	d9 9d 3c ff ff
	ff		 fstp	 DWORD PTR tv72[ebp]
  00043	d9 85 3c ff ff
	ff		 fld	 DWORD PTR tv72[ebp]

; 751  :         }

  00049	5f		 pop	 edi
  0004a	5e		 pop	 esi
  0004b	5b		 pop	 ebx
  0004c	81 c4 c4 00 00
	00		 add	 esp, 196		; 000000c4H
  00052	3b ec		 cmp	 ebp, esp
  00054	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00059	8b e5		 mov	 esp, ebp
  0005b	5d		 pop	 ebp
  0005c	c3		 ret	 0
_sinf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_math.h
;	COMDAT _fabsf
_TEXT	SEGMENT
tv72 = -196						; size = 4
__X$ = 8						; size = 4
_fabsf	PROC						; COMDAT

; 671  :         {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c4 00 00
	00		 sub	 esp, 196		; 000000c4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 3c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-196]
  00012	b9 31 00 00 00	 mov	 ecx, 49			; 00000031H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __09340588_corecrt_math@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 672  :             return (float)fabs(_X);

  00028	f3 0f 5a 45 08	 cvtss2sd xmm0, DWORD PTR __X$[ebp]
  0002d	83 ec 08	 sub	 esp, 8
  00030	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00035	e8 00 00 00 00	 call	 _fabs
  0003a	83 c4 08	 add	 esp, 8
  0003d	d9 9d 3c ff ff
	ff		 fstp	 DWORD PTR tv72[ebp]
  00043	d9 85 3c ff ff
	ff		 fld	 DWORD PTR tv72[ebp]

; 673  :         }

  00049	5f		 pop	 edi
  0004a	5e		 pop	 esi
  0004b	5b		 pop	 ebx
  0004c	81 c4 c4 00 00
	00		 add	 esp, 196		; 000000c4H
  00052	3b ec		 cmp	 ebp, esp
  00054	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00059	8b e5		 mov	 esp, ebp
  0005b	5d		 pop	 ebp
  0005c	c3		 ret	 0
_fabsf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_math.h
;	COMDAT _cosf
_TEXT	SEGMENT
tv72 = -196						; size = 4
__X$ = 8						; size = 4
_cosf	PROC						; COMDAT

; 648  :         {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c4 00 00
	00		 sub	 esp, 196		; 000000c4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 3c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-196]
  00012	b9 31 00 00 00	 mov	 ecx, 49			; 00000031H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __09340588_corecrt_math@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 649  :             return (float)cos(_X);

  00028	f3 0f 5a 45 08	 cvtss2sd xmm0, DWORD PTR __X$[ebp]
  0002d	83 ec 08	 sub	 esp, 8
  00030	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00035	e8 00 00 00 00	 call	 _cos
  0003a	83 c4 08	 add	 esp, 8
  0003d	d9 9d 3c ff ff
	ff		 fstp	 DWORD PTR tv72[ebp]
  00043	d9 85 3c ff ff
	ff		 fld	 DWORD PTR tv72[ebp]

; 650  :         }

  00049	5f		 pop	 edi
  0004a	5e		 pop	 esi
  0004b	5b		 pop	 ebx
  0004c	81 c4 c4 00 00
	00		 add	 esp, 196		; 000000c4H
  00052	3b ec		 cmp	 ebp, esp
  00054	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00059	8b e5		 mov	 esp, ebp
  0005b	5d		 pop	 ebp
  0005c	c3		 ret	 0
_cosf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_math.h
;	COMDAT _atan2f
_TEXT	SEGMENT
tv75 = -196						; size = 4
__Y$ = 8						; size = 4
__X$ = 12						; size = 4
_atan2f	PROC						; COMDAT

; 633  :         {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c4 00 00
	00		 sub	 esp, 196		; 000000c4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 3c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-196]
  00012	b9 31 00 00 00	 mov	 ecx, 49			; 00000031H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __09340588_corecrt_math@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 634  :             return (float)atan2(_Y, _X);

  00028	f3 0f 5a 45 0c	 cvtss2sd xmm0, DWORD PTR __X$[ebp]
  0002d	83 ec 08	 sub	 esp, 8
  00030	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00035	f3 0f 5a 45 08	 cvtss2sd xmm0, DWORD PTR __Y$[ebp]
  0003a	83 ec 08	 sub	 esp, 8
  0003d	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00042	e8 00 00 00 00	 call	 _atan2
  00047	83 c4 10	 add	 esp, 16			; 00000010H
  0004a	d9 9d 3c ff ff
	ff		 fstp	 DWORD PTR tv75[ebp]
  00050	d9 85 3c ff ff
	ff		 fld	 DWORD PTR tv75[ebp]

; 635  :         }

  00056	5f		 pop	 edi
  00057	5e		 pop	 esi
  00058	5b		 pop	 ebx
  00059	81 c4 c4 00 00
	00		 add	 esp, 196		; 000000c4H
  0005f	3b ec		 cmp	 ebp, esp
  00061	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00066	8b e5		 mov	 esp, ebp
  00068	5d		 pop	 ebp
  00069	c3		 ret	 0
_atan2f	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_math.h
;	COMDAT _acosf
_TEXT	SEGMENT
tv72 = -196						; size = 4
__X$ = 8						; size = 4
_acosf	PROC						; COMDAT

; 623  :         {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c4 00 00
	00		 sub	 esp, 196		; 000000c4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 3c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-196]
  00012	b9 31 00 00 00	 mov	 ecx, 49			; 00000031H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __09340588_corecrt_math@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 624  :             return (float)acos(_X);

  00028	f3 0f 5a 45 08	 cvtss2sd xmm0, DWORD PTR __X$[ebp]
  0002d	83 ec 08	 sub	 esp, 8
  00030	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00035	e8 00 00 00 00	 call	 _acos
  0003a	83 c4 08	 add	 esp, 8
  0003d	d9 9d 3c ff ff
	ff		 fstp	 DWORD PTR tv72[ebp]
  00043	d9 85 3c ff ff
	ff		 fld	 DWORD PTR tv72[ebp]

; 625  :         }

  00049	5f		 pop	 edi
  0004a	5e		 pop	 esi
  0004b	5b		 pop	 ebx
  0004c	81 c4 c4 00 00
	00		 add	 esp, 196		; 000000c4H
  00052	3b ec		 cmp	 ebp, esp
  00054	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00059	8b e5		 mov	 esp, ebp
  0005b	5d		 pop	 ebp
  0005c	c3		 ret	 0
_acosf	ENDP
_TEXT	ENDS
END
